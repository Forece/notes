# 一、PHP 环境

PHP（Hypertext Preprocessor） 是超文本预处理器，一门服务器端的脚本语言。PHP 文件不能脱离服务器环境独立运行。不像HTML双击就可以看到结果，PHP必须通过服务器访问。



PHP 环境一般需要三个模块：

- Apache（Nginx） 提供服务器 Web 支持
- PHP  提供 PHP 脚本运行环境（这里的PHP只是服务器Web支持的一个扩展包）
- Mysql  提供数据库环境



编辑器：

- Visual Studio Code
- phpstorm（收费）



VSCODE 插件：

- PHP Intelephense（格式化插件）
- auto rename tag
- auto close tag
- tabout



## 1. Windows 中的 PHP 环境

phpStudy, XAMPP, WAMP



### 1.1 下载 WAMP

https://www.wampserver.com/



### 1.2 目录结构

~~~
- wamp
|---- bin  // 程序包文件夹
|		| ---- apache
|		|		| ---- bin  // 操作 Apache 的命令执行文件
|		|		|		| ---- php.ini  // PHP 配置文件
|		|		| ---- conf  // Apache 配置文件
|		|		|		| ---- extra  // Apache 配置扩展文件
|		| ---- php
|		|		| ---- ext  // 模块文件夹
|		| ---- mysql
|		|		| ---- bin  // mysql 所有命令执行文件
|		|		| ---- data  // 数据库文件路径
| ---- logs  // Apache、php、mysql 日志文件
| ---- alias  // 别名配置文件夹
| ---- www  // 发布网站根目录
~~~



### 1.3 WAMP 配置虚拟域名

在 D:\wamp\bin\apache\Apache2.2.11\conf 文件夹下，找到 httpd.conf ，使用诸如 Editplus 之类的编辑器打开它（不然会出现没有换行的情况），搜索

~~~
#Include conf/extra/httpd-vhosts.conf
~~~

把前面的#去掉，然后保存。



然后再去 D:\wamp\bin\apache\Apache2.2.11\conf\extra 文件夹下，找到 httpd-vhosts.conf
里边有两个 Example 的例子，直接按照例子改下就好了，如：

~~~
<VirtualHost *:80>
ServerAdmin admin@forece.net
DocumentRoot "d:/wamp/www/forece.net"
ServerName forece-local.net
</VirtualHost>
~~~



然后在 wamp/www 创建文件夹 forece.net



然后我们在 c:\windows\system32\drivers\etc\host 里边在将刚才创建的虚拟域名

~~~
127.0.0.1 forece-local.net
~~~



重启 WAMP



### 1.4 PHP 配置文件查询

~~~php
<?php phpinfo(); ?>
~~~

> 在页面中可以查看 PHP 配置文件位置



### 1.5 补充

- 集成环境 WAMP 中，index.php 的权重要比 index.html 权重要高，同时拥有 index.php 和 index.html 的情况下，会先访问 index.php 文件
- 如果出现中文乱码，注意 HTML 和 php 文件中的 charset，还有 WAMP 中 php.ini 中的 charset



## 2. Linux 安装 PHP 环境

- LAMP
- LNMP



## 二、PHP 语法

## 1. PHP 语言标记

PHP 标记是可以嵌入 HTML 代码当中的，可以在任意 HTML 代码中插入 PHP 标记。PHP语言在服务端经过解析，然后生成新的HTML页面返回给用户。如：



~~~php+HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="<?php echo KEYWORDS; ?>" content="">
    <meta name="<?php echo DESCRIPTION; ?>" content="">
    <title><?php echo TITLE; ?></title>
</head>

~~~





1. 标准格式： 

  ~~~php 
  <?php // 代码  ?> 
  ~~~

  > 标准风格标记，属于 XML 风格，如无特殊要求，开发中一般都用这种标记。

  

2. 长风格： 

  ~~~php
  <script language="php> 代码 </script>
  ~~~

  > 类似 javascript 风格，并不常用

  

3. 短风格：

  ~~~php
  <? 代码 ?>
  ~~~

  > 默认是被配置文件禁用的，需要通过 php.ini 中的 short_open_tag 才可以正常是使用

  

4. ASP/JSP风格：

  ~~~php
   <% 代码 %>
  ~~~

  > 属于 ASP 风格，默认也是被禁用的，需要将 php.ini 中的 asp_tags 打开才可以正常使用

  

- 短风格和ASP风格默认是被关闭的，因为可能会与一些其他技术发生冲突，例如 XML，所以一般如果书写 PHP 代码的话，只使用标准格式即可。
- 如果整篇代码只有 PHP 代码的文件， 结束标志 ?> 是不允许存在的，因为 PHP 自身并不需要 ?> ，这样做可以防止它的末尾被以外的注入。
- PHP 代码中，任意一行PHP代码都是是以 `;` （指令分隔符）结尾的，如果是在整个脚本的最后一行，`;` 可以不用写
- 空白、Tab、回车换行在PHP中是不被解析的。一般用来做风格控制
- 所有符号都是英文符号



### 1.1 echo 语句

echo 可以输出一个或多个字符串，echo 是一个语言结构，使用的时候可以不用加括号，也可以加上括号： echo 或 echo()。

~~~php
<?php
echo "hello world";
~~~



## 2. 注释

~~~php
// 单行注释

/* 
多行注释
多行注释
多行注释
*/

/**
文档注释
文档注释
*/


~~~

> 注释要写在代码的上方或后边



## 3. 代码风格

下列情况应该总是使用两个空行

- 一个源文件的两个代码片段之间
- 两个类的声明之间



下列情况应该总是使用一个空行

- 两个函数声明之间
- 函数内的局部变量和函数的第一条语句之间
- 块注释或单行注释之前。
- 一个函数内的两个逻辑代码段之间，用来提高可读性。



# 三、变量

变量是用于临时（程序运行时）存储数据的容器。PHP 是弱类型语言，不要声明变量的数据种类，给变量赋值，数据是什么类型，变量就是什么类型。用柜子打比方来说，将书放进柜子，柜子就是书柜。衣服放进柜子，柜子就是衣柜。



## 1. 定义变量

定义变量的方法

~~~php
$变量名 = 数据;
~~~



变量名的命名规则：

- 不能以数字开头
- 不能使用PHP运算符号（+, -, *, / % &)
- 可以使用系统关键字（if, for）（因为加了$符，如 $if ）
- 变量区分大小写，命令不区分大小写
- 变量命名规则：$timeInfoLocation; （小驼峰命名法，首单词字母小写，次单词首字母大写）
- 变量名最好有意义，不要使用无意义的变量名。



在变量使用范围内，我们可以借助 `unset()` 函数释放指定的变量，使用 `isset()` 函数检测变量是否设置，使用 `empty()` 函数检查一个变量的内容是否为空。如：使用 `isset()` 测试变量是否存在

~~~php
if(isset($a));  {
    echo $a;
}
else{
    echo "not exist!";
}
~~~



## 2. 可变变量

~~~php
$one="######";
$two="one";
$three="two";
$four="three";

echo $four.<br/>; 
echo $$four.<br/>;  //相当于$three, 也就是 two
echo $$$four.<br/>; //相当于 $$three, $two, 也就是 one
echo $$$$four.<br/>; //相当于 $one， ######
~~~



## 3. 变量的引用赋值

类似于指针，指向原始变量，使用引用赋值，用 “&” 符号指向目标变量。



~~~php
$one=10;
$two=&$one;
$two=100;

echo $one."<br>";
echo $two."<br>";  // 指向 one 变量，只要其中之一改变，另外一个也改变。

// 输出结果：
100
100
~~~



PHP 引用并不像 C 语言中的地址指针，例如， 在表达式 $a=&$b 中，不会导致 $a 和 $b 在内存上同体，只是把各自的值相关联起来，基于这一点，使用 unset() 则不会导致所引用的变量消失。



在执行 unset() 后，变量 $a 和 $b 仅仅是互相取消值关联， $a 并没有因为 $b 的释放而消失。

~~~php
<?php
$a = 10;
$b = &$a;

unset($b);
echo $a;

// 输出结果：
10;
~~~



## 4. 变量类型

变量类型是指保存在该变量中的数据类型。 PHP 语言是一种弱类型检查语言，和其他语言不同的是，变量或常量的数据类型由程序的上下文决定。强类型语言中，变量需要先指定类型，如C语言，`int m=3;` 而在PHP语言中直接可以用 `$m=3;` 具体是什么类型由存放的内容决定，而不是人为事先指定的。

- 标量：整形、布尔型、浮点型、字符串
- 复合类型：数组、对象
- 特殊类型：资源类型、空类型



~~~php
var_dump(变量或值); // 查看变量值和类型

如：
var_dump(3); 
var_dump($a);
~~~



### 4.1 布尔型

最简单的类型，只有 true 或 false。即真或假。在PHP中进行关系运算（比较）或者逻辑运算中，返回值都是布尔型。



以下值都被认为是 False，其他都是 Ture（包括任何资源）

1. False
2. 整型0，（-1或其他任何非零，不论正负，都是 True）
3. 浮点型值 0.0 （其他任何浮点型都是 True）
4. 空白字符串和字符串“0” // 空白字符串是 "" ，而不是 " "，空格字符串是有值的。
5. 没有成员变量的数组
6. 没有单元的对象
7. 特殊类型 NULL 



### 4.2 整型

整型变量用于存储整数，如 -2，-1,0,1,2..... 等等。一般用十进制，不过也支持八进制或十六进制。定义变量时，需要注意进制。



定义变量：

~~~php
$int=10; // 十进制
$int=045; //  八进制
$int=0xff; // 十六进制
~~~



整型数值有最大的使用范围，32位系统中，最大值整数为二十多亿，具体为 2,147,483,647。 int型占4个字节，一个字节8位，也就是 1111 1111 1111 1111 1111 1111 1111 1111，值为：4294967295，但PHP 不支持无符号整数，所以最小值为 -2,147,483,648。 ，如果给定一个数据超出了整型这个范围，则自动转换为 float 型。同样，如果运算结果超出了 integer 的范围，也会返回 float 型。



### 4.3 浮点型

浮点数，也就是小数（也称为双精度数或实数），通常用来表示整数无法表示的数据，例如金钱值、距离值、速度值等。浮点数的字长也是和平台相关的，允许表示的范围为 1.7E-38~1.7E+38.

浮点数只是一种近似的数值，如果用浮点数表示 8，则该结果内部的表示其实是类似 7.99999999999，所以永远不要比较两个浮点数是否相等。

~~~php
$float=10;
$float=-10;
$float=3.14E+5;  // 科学计数法：相当于 3.14 x 10^5
$float=3.14E-5;  // 科学计数法：相当于 3.14 x 10^-5
~~~



### 4.4 字符串

字符串也是 PHP 中的标量类型之一，它是一系列字符，和强类型语言不通，PHP 没有字符一说，也就是没有 char 类型，所有字符都算是字符串类型。字符串可以使用单引号，双引号，定界符三种方法定义。



**单引号**

~~~php
$str= 'Hello World'; 
~~~



指定一个简单字符串的最简单的方法使用单引号括起来。在单引号引起来的字符串中不能再包含单引号。如果需要在单引号中表示另一个单引号的话，需要用反斜线（\) 转义。如：

~~~php
$str ='This is an \'Apple\'';

输出：
This is an 'Apple'
~~~



注意：

- 在单引号中不能使用其他转义字符，只能转义单引号和转义符号本身

- 另外，在单引号字符串中出现的变量不会被变量的值替代，即 PHP 不会解析单引号中的变量，而是将变量名原样输出。



所以在定义简单字符串时，使用单引号效率会更高，因为 PHP 解析时不会花费一些处理字符转移和解析变量上的开销。因为，如果没特殊需求，应使用单引号定义字符串。



**双引号**
如果使用双引号括起字符串，PHP 懂得更多特殊字的转义序列。另外，双引号字符串最重要的一点是其中的变量名会被变量值替代。



常用转义字符：

![image-20210315173929804](images/php/image-20210315173929804.png)



~~~php
$str="aa$int aaa"; // 用空格隔开，使变量可以正常解析
$str="aa{$int}aaa"; // 用大括号隔开变量旁边的两个字符串
$str="aa${int}aaa"; // 用大括号隔开，但一般不使用这种方法。
$str="\$int"; // 不解析变量，直接显示 $int 这个字符串，
~~~



**定界符**（大量字符串使用）：

在大篇幅文章中，里边可能包含很多的单引号和双引号，我们不可能一个一个用转义符将这些特殊符号转义。所以我们用定界符。

~~~php
$str=<<<one
        This is an "example" text; it can contain any characters
        and sympols.
one;
~~~

> //one后边不能有任何符号，结束符前不能有任何符号



- 使用 <<< 小于号

- 小于号后边可以任意命名一个标记名，左侧挨着<<<，直接回车，不能加任何字符。

- 在结尾的字符串定界中，一定要顶头写，和开始的字符串要一致，并且直接回车。

- 定界符文本不能初始化类成员，和双引号的功能一样。虽然定界符文本不需要转义符号，不过仍然可以使用转义符号。定界符中的变量也会被解析。

- 在开始的定界符号中，如果使用单引号将标记括起来，则不对变量进行转义。如：$str=<<<'EOF' 





### 4.5 其他类型

**数组**

数组是 PHP 中一种重要的复合数据类型，数组可以存放多个数据。之后会详解数组~~

~~~php
$arr = array(1,2,3,4,5);
~~~



**对象**
对象在 PHP 中也是一种复合数据类型，但对象是一种更高级的数据类型，一个对象类型的变量，是由一组属性值和一组方法构成的。其中属性表明对象的一种状态，方法通常用来表明对象的功能。

~~~
$obj = {name:"Jay"};
~~~



**资源类型**

资源是一种特殊类型，保存了到外部资源的一个引用。资源是通过专门的函数来建立和使用的。使用资源类型变量保存有为打开文件、数据库连接、图形画布区域等的特殊句柄。



**空类型**

空类型也是一种特殊变量，它没有值， NULL 不表示空格，也不表示为零，也不是空字符串。 NULL 不区分大小写。



**NULL**

尚未被赋值的变量或被 `unset()` 函数销毁的变量。



**伪类型**
一般用在解释说明中，不是真实类型，只是为了确保代码的易读性。

~~~php
/*  
@param number $a 
demo (mixed $a) 
*/
~~~

- mixed 说明一个参数可以接受多种不同的类型
- number 说明一个参数可以使整型或浮点型
- callback 说明可以用自定义函数来作为一个参数。



## 5. 数据之间类型的转换

类型转换是指将变量或值从一种数据类型转换成其他数据类型。转换方法有两种，一种强制转换，另外一种是自动转换。如果是数字类型之间的转换，注意精度的丢失。



### 5.1 自动转换

在参与运算时，小类型会往大类型转。

- 布尔型参与运算时，TRUE转换为整型1，FALSE 将转换为整型0后再参与运算

- 有NULL参与运算时，NULL值将转换为整型0再参与运算，NULL转换为字符串为''

- 有 int 和 float 型参与运算时，先将 integer 型变量转换为 float 再参与运算

- 有字符串和数值型数据参与运算时，字符串先转换为数字，再参与运算，如123abc 转换为整数123，字符串123.45abc转换为123.45，字符串abc，则转换为0。123e3abc自动变换为123e3。

> 注意，如果浮点型转整型，注意数值范围，有可能会丢失数据。



### 5.2 强制转换

用 `settype()` 函数强制转换，将原变量给转换。

~~~php
gettype();  // 获取变量类型
settype(); // 转换变量类型
~~~



例：

~~~php
$int = 10;
echo gettype($int); // 获取 $int 变量的类型
settype($int, "string"); // 将 $int 变量转换为字符串型
~~~



### 5.3 追加类型符号

在变量使用时，前边加上类型符号，是在赋值时，给新变量一个新类型，原类型不变。

- (int), (integer)
- (bool), (boolean)
- (float), (double), (real)
- (string)
- (array)
- (object)



例：

~~~php
<?php
$int = "10000";
$d = (int)$int;
echo gettype($d);
echo "<br/>";
echo gettype($int);

# 结果：
integer
string
~~~



### 5.4 转换函数

还可以使用专门的转换函数强制转换

- intval() 
- floatval()
- strval()

```php
$str = "123.45abc";
$int = intval($str); // 获取变量 $str 的整型值 123
$flo = floatval($str); // 获取变量 $str 的浮点值 123.45
$str = strval(123.45); // 转换123.45为字符串。
```



### 5.5 判断变量类型的函数

可以用 gettype(); 函数来进行判断变量类型，如：

~~~php
<?php
$a = "name";
if(gettype($a) == "string") {
	echo "\$a is string type";
}
~~~



也可以使用 php 提供的判断函数

- is_bool()
- is_int(), is_integer(), is_long()
- is_float(), is_double(), is_real()
- is_string()
- is_array()
- is_object()
- is_resource()
- is_null()
- is_scalar()
- is_numberic()
- is_callable()



~~~php
if (empty($a));  // 是判断变量内容是否为空
if (is_null($a));  // 是判断变量类型是否为空
~~~



## 6. 常量

在php中声明常量是通过 define(); 函数来定义的。常量的命名和变量类似，也要遵循php命名规则。另外，声明常量默认和常量一样区分大小写。不过按照惯例来说，常量名称总是大写的。但不要在前边加$符号



### 6.1 常量的声明

声明格式如下：

~~~php
define("NAME", "张三");
~~~



默认常量是区分大小写的，当声明函数时，在后边添加一个参数，则可以使定义的常量不区分大小写。如：

~~~php
define("NAME", "张三", true);
~~~



- 常量一旦声明，则不会改变
- 常量可以参与计算，如果常量没有声明值，则系统在使用时，会被当作字符串使用。如果不加单引号或双引号，虽然会被自动转换，但是速度要慢很多（效率低）。所以，如果常量是字符串，则需要用双引号或单引号来引用。
- 常量只支持标量数据类型
- 常量不能使用 unset(); 清除一个常量。
- 常量可以使用 defined(); 函数来查看是否被定义。
- 常量的范围是全局的
- 也可以使用 echo constant ("常量名"); 来输出常量。



### 6.2 系统中预定义的常量

像 M_PI 数学中的 π，还有 NULL，TRUE，FALSE 等这些都是系统预定义好的常量。用 `get_defined_constants();` 来获取所有已定义常量。



获取所有预定义变量

~~~php
print_r(get_defined_constants());
~~~

> 因为是数组，所以不能用 echo 来输出到屏幕



简单的预定义变量

~~~php
PHP_OS			// 当前系统名
PHP_VERSION		// PHP 当前版本
DIRECTORY_SEPARATOR  // 目录分隔符
~~~





### 6.3 PHP 中的魔术常量

魔术常量，虽然常量会能改变其本身的值，但是下边这几个常量的值是根据其所在文件的位置而改变。

~~~php
__LINE__		// 当前文行数
__FILE__		// 当前的文件名
__DIR__			// 当前文件夹
__FUNCTION__	// 当前的函数名
__CLASS__		// 当前的类名
__METHOD__		// 当前对象的方法名
__NAMESPACE__	// 当前命名空间的名称
~~~



# 四、PHP中的运算符

运算符可以根据操作数的个数分为一元运算符、二元运算符、三元运算符。

- 一元运算符只运算一个值，如!（取反运算符）或 ++ （加一运算符）。
- 二元运算符可以运算两个值，比如，加减乘除等等。
- 三元运算符只有一个 (?:)



~~~php
运算元		运算符		运算元
1			+			1
~~~



一元运算符：! ++ -- +1 -1
二元运算符：+ - * / % > < = 
三元运算符：1?(2:3)



按不同功能分类，可以分为算数运算符、字符串运算符、赋值运算符、比较运算符、逻辑运算符、位运算符和其他运算符。

- 算术运算符： + - * / % ++ --
- 赋值运算符： = += -= *= /= %=
- 比较运算符： > < == >= <= ===  != !==
- 逻辑运算符： && || !
- 位运算符： & | ^ ~ >> <<
- 其他运算符： 1?2:3, @ -> 





### 1. 算数运算符

算数运算符中除了常见的 + - * / 之外，还有 %, ++, --

使用方法和平常的用法一样，以下说一下几个特别的算术运算符。



####  1.1 加号

其他语言中，+号除了有加法的作用，还有连接字符串的功能，但是PHP中不能连接字符串，如：Javascript 语言中的加号

~~~javascript
<script>
var a=10;
alert(1+1+"4+5+6"+1+1);  // 结果是24+5+611，前边是数学运算，后边是字符串连接
</script>
~~~



在PHP中，如果用 + 的话，

~~~php
echo 1+1+"4+5+6"+1+1;
~~~

> 结果为8，因为字符串会自动转换整数4。



#### 1.2 % 号

% 是模运算符，作用是求余数。也称作求余运算符。正负号由前边的数决定，浮点数求余将%运算符两侧数字自动转换为整数后然后进行运算。

~~~php
<?php
echo 5 % 2;
echo "<br/>";
echo 6.2 % 4;

结果：
1
2
~~~



用途：

- 求余数
- 让一个数不超过一个值（任何数和5求模都不会超过5）
- 求什么被整除  `if($num % 5 == 0){ }`



#### 1.3 ++ 、-- 运算符

~~~php
++$a // 运算符在前边，先做运算在使用变量
$a++  // 变量在前边，先使用变量在运算
~~~



例：

~~~php
$a = 5;
$b = $a++ + ++$a; // 先用$a, 为5，然后自增变6，再自增为7
echo $b; // 12
echo "<br/>";
echo $a; // 7
~~~




$a = $a+1 与 $a++ 区别

- $a= $a+1 的话，布尔型会转换为整型参与计算，而使用递增/递减运算符的话，布尔型不参与++ -- 运算，结果依然是布尔型。

- 递减运算符对 NULL 也没有效果，但是递增 NULL 的结果为1.



用 echo 输出布尔型时，真为1，假为 NULL（空，什么都不显示）

```php
$a = true; 
$b = false; 
echo $a;
echo $b;
```



另外，在处理字符串变量运算时，字符串会被自动转换为数字型或者0，而自增运算符的话，会自增字符串中的字母，如：

```python
$a = "a";
$a++;
echo $a; // 会显示b

$a = "z";
$a++;
echo $a // 显示aa

$a = "aaaa"
$a++;
echo $a; // 会显示 aaab
```

> 注意：字符变量只能递增不能递减



### 2. 字符串运算符

在PHP中字符串运算符只有一个，是英文的句号（.) ，也称为连接运算符，它是一个二元运算符，返回其左右参数连接后的字符串。这个运算符不仅可以将两个字符串连接起来，也可以将一个字符串和任何标量数据类型相连接，合并成新的字符串。

~~~php
$name = "Tom";
echo "My name is ".$name;
~~~

> 字符串连接符不能连数值，只能连变量或字符串。



echo 输出字符串与变量的几种方法：

~~~php
<?php
$a = 10;
echo '这个变量的值：'.$a.'<br>';  // 字符串连接符连接变量与字符串
echo "这个变量的值：{$a}<br>";  // 双引号解析变量
echo "这个变量的值：",$a,"<br>"; // 参数
~~~



### 3. 赋值运算符

= 赋值运算符，将右侧表达式的值赋给左侧的变量。如： `x=3;`

~~~php
$a +=1; // $a = $a +1;
$a -=1; // $a = $a -1;
$a *=1; // $a = $a *1;
$a /=1; // $a = $a /1;
$a %=1; // $a = $a %1;
$a .="1"; // $a = $a."1";
~~~



### 4. 比较运算符

比较运算符也称为关系运算符，是一种常用的二元运算符，用于对运算符两边的操作数进行比较。比较运算符的结果是布尔型。比较后的关系为真，true，假为false。

~~~php
$a > $b;
$a < $b;
$a == $b;
$a >= $b;
$a <= $b;
$a <> $b; 或 $a != $b;
$a === $b; // 全等于，左侧操作数等于右侧操作数，并且类型也相同时，返回 TRUE
$a !== $b; // 非全等于，左侧不等于右侧，并且类型也不相同时，返回 TRUE

$a = "007";
$b = 7;
var_dump( $a == $b);  // 返回 ture，因为比较运算符会将两测的操作数自动转换为相同类型。
var_dump( $a === $b); // 返回 false，因为类型不同
~~~



### 5. 逻辑运算符

逻辑运算符用来判断一件事情是 “对” 还是 “错” ，或者说是成立还是不成立，逻辑运算符只能操作布尔型数值，处理后的结果也是布尔型的数值。逻辑运算符有 and, or, not, xor ，还有 &&, ||, !  ，符号和英文的作用是一样的，只不过符号的优先级要比英文的要高，建议使用符号。



#### 5.1 and 和 &&  -  逻辑与

两边操作数都为 True 时，返回 True，否则 False

~~~php
$a=4;
$a > 5 && $a <100;  // 前边判断不成立，后方即不判断直接判定为 False

~~~



#### 5.2 or 和 ||  -  逻辑或

两边都为 False，返回 False，否则 True

~~~php
$a=4;
$a<5 || $a<100; // 前方判断成立，直接为 True, 后边不执行
~~~



例：

~~~php
$link = mysql_connect("localhost", "root", "") or die("数据库连接失败!");
// 如果连接成功则不显示后方数据，如果失败则显示连接数据库失败
~~~



#### 5. 3 not 和 !   -  逻辑非

当操作数为 True 时返回 False，否则 True

~~~php
$a = true;
// 当$a为true的时候不执行代码，当$a为false的时候执行代码
if(!$a){
    // 代码
}
~~~



#### 5.4 xor -  逻辑异或

两边操作数只有一个为 True 时，返回 True，否则 False



例：判断是否是闰年

~~~php
<?php 
$year =2000;
if(( $year%4==0 && $year%100!=0) || $year%400==0) {
echo "$year is leap year";
}
else {
echo "$year is not leap year";
}
~~~



#### 5.5 短路

在逻辑运算符中，运算是从左向右的，指如果在进行前面的表达式的运算过程，通过判断已经明确的知道整个表达式的结果，那么就不会进行后面表达式的运算判断。

```php
$a = 0;
$b = 0;
if ($a = 3 || $b = 3) {
    $a++;
    $b++;
}
echo $a.",".$b;
```

> 赋值运算符优先级最低， 可以看成 $a=(3||$b=3)，因为在 || 运算中，左侧 3 已经是 true 了，所以短路，右侧不进行运算，得到布尔型数据 true, $a = ture; 又因为 ++ 自增运算符对布尔型不起作用，所以 $a 输出为 1， 而$b没执行，$b 还是0，$b++ 后为 1；



~~~php
$a = 0;
$b = 0;
if ($a = 3 && $b = 3) {
    $a++;
    $b++;
}
echo $a.",".$b;
~~~

> 和上方一样，先判断 3 && $b=3，左侧为真，右侧是赋值运算符，也为真，等式成立，$a 为 true，自增对布尔型数据无效，$a 输出为 $1，$b被赋值为3，然后$b++后为 4。



### 6. 位运算符

任何信息在计算机中都是以二进制数形式保存的，位运算符允许对整型数中指定的位进行置位。如果左右参数都是字符串，则位运算符将操作字符的 ASCII 值，如果是浮点数则会自动转换为整型再参与位运算。位运算用于对操作数中的每个二级制位进行运算，包括位逻辑运算符和位移运算符，没有错位和进位。



32位计算机，整型数据由4个字节保存，1个字节8个位，所以是一共32个0，左侧第一个位时符号位（0为正数，1为负数），剩下的代表数据。

0 0000000 00000000 00000000 00000000



二进制最后一位是2的0次方，第二位是2的1次方，以此类推一直到2的31次方，可以把一个数拆解成 2的n次方相加，就可以得到这个数的二进制。

```
104 = 64 + 32 + 8  = 2^6 + 2^5 + 2^3 
01101000 = 104
```



位运算符：

```
&		按位与			参与运算的两位都为1，运算结果为1，否则为0
| 		按位或			参与运算的两位都为0，运算结果为0，否则为1
^		按位异或		参与运算的两位不同，运算结果为1，否则为0
~		按位非			将二进制表示的操作数中的1变成0,0变成1
<<		左移			
>>		右移
```



#### 6.1 & 按位与：

```
00001100

00001101   &
-------------------

00001100
```



#### 6.2 | 按位或：

```
00001100

00001101  |
-------------------

00001101
```



#### 6.3 按位异或

```
00001100

00001101    ^
--------------------------

00000001
```



#### 6.4 按位非：

```
~00001100
-------------------
11110011
```



#### 6.5 << 左移

```
var dump (12 << 2);

00001100 <<2
---------------

00110000
```

> 二进制整体左移，左侧溢出，右侧补0。
> 每移动一位，相当于*2。



#### 6.6 >> 右移 

```
varm dump(12>>2);

00001100 >>2
---------------------

00000011
```

> 二进制整体右移，右侧溢出，左侧补0
> 每移动一位，相当于 /2。



补充：

在正数进行位移的时候，位运算以0补位，负数位移的时候，位运算以1补位。

```
varm dump(-5>>2);

11111011 >>2
---------------------

11111110

结果：
-2
```



负数二进制换算，反码 + 1 

```
-1 的二进制

正数： 1
0000 0000 0000 0000 0000 0000 0000 0001
反码：
1111 1111 1111 1111 1111 1111 1111 1110
补码：（反码+1）
1111 1111 1111 1111 1111 1111 1111 1111
```



负数二进制转换为十进制

```
二进制：
1111 1111 1111 1111 1111 1111 1111 1111
补码：（二进制-1）
1111 1111 1111 1111 1111 1111 1111 1110
反码：
0000 0000 0000 0000 0000 0000 0000 0001
```

> 由该二进制转为十进制，结果为1，然后加上负号，-1



其他语言中还有 >>> 和 <<< ，也是位运算符，忽略符号位，带着符号位整体移动，补位只补0。如：

```
-1 >>> 2

二进制：
1111 1111 1111 1111 1111 1111 1111 1111
无符号右移两位：
0011 1111 1111 1111 1111 1111 1111 1111

```



#### 6.7 位运算

整型位运算

```
var_dump(2 & 4);  //结果为0

0010
0100  &
-------
0000
```



字符串的位运算


位运算时的数据类型为 string/integer时，分析时要转换为二进制，但是在程序中书写及输出结果时仍为 string / integer 类型。如： 

```
var_dump( 'A' & 'a'); // 结果为 A
var_dump('A' | 'a'); // 结果为 a


相当于
65 & 97;
65 | 97;
```

> 先将 A 转换为 ASCII 码的值，然后再做位运算，运算后再将数值换源成 ASCII 吗转换为字符串。多个字符串同样适用，如 'AA'



字符串和整型进行位运算时，相当于字符串和整型进行运算，数字类字符串会自动转换为整型，其他文字字符串转换为0，规则与之前介绍的一样。

```
var_dump('a' & 97);  // 结果为0
```

>因为 a 是字符串，字符串与数字做运算，字符串先要转换为整型，文本类型字符串会变为0，与 97 做位运算，结果还是0。



#### 6.8 逻辑运算符与位运算符的区别

逻辑运算符结果是布尔型，而位运算符运算出来的结果是数值

```
var_dump( true && false); // 结果为 false
var_dump( true & false);  // 结果为 0
```

> & 也可以用作 if 的条件判断中，因为 1 和 0 也可以当做判断。



- && 或 || 会短路（如果左侧不成立，右侧不会执行）
- & 或 | 不会短路（两侧都会执行）

> - 所以如果只有一个条件或者不需要短路，可以使用位运算符。
> - 如果多个条件，又需要短路，最好还是用逻辑运算符



### 7. 其他运算符

#### 7.1 ?: 三元运算符

?: 可以提供简单的逻辑判断，是 PHP 中唯一的三元运算符，类似于条件语句 "if ... else...."

```
运算元 ? 运算元 : 运算元 （条件 ? 表达式1 ： 表达式2）
```

> 如果条件为真，则执行表达式1，否则执行表达式2



```
$a < $b ? $c = 1:$c = 0
```



#### 7.2 ?? 运算符

?? 运算符由三元运算符进化而来



**普通三元运算符：(expr1) ? (expr2) : (expr3) **

表达式 (expr1) ? (expr2) : (expr3) 在 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。

其中false的值的判断跟 if (expr1)一样，包括空字符串 ''   false   为空empty    null   0   0.0  ‘0’



例子

```
$a = $a ? $a : 1;
```



**进阶三元运算符：(expr1) ? :(expr2)**   

> 这个是php5.3开始才有的功能

在 expr1 求值为 TRUE 时返回 expr1，否则返回 expr2。



例子

```
$a = $a ?: 1;
```


它等价于1的例子

 

**?? 运算符：(expr1) ? ？(expr2)**  

> 这个是php7才有的功能

这个运算符相当于：

```php
$a = isset(expr1) ? expr1 :  expr2;
$b = isset($a) ? $a : 1;
```





#### 7.2 ``执行运算符 

注意，这个符号不是引号，是键盘上数字1左侧的反引号

反引号中的语句，是被 PHP 当做 shell 命令来执行的，如：

~~~php
$a = `ls -al`;
echo `ipconfig`;  // 返回系统命令执行的结果
~~~

> 效果与函数 shell_exec(); 相同

虽然可以执行 shell 命令，但是有安全隐患，并且对平台有要求，因为不同系统 shell 命令不同，所以对跨平台支持不太好。



#### 7.3 @ 错误控制运算符

当将其放置在一个 PHP 表达式之前时，该表达式可能产生的任何错误信息都会被忽略。它只对表达式有效。如果用@屏蔽掉警告信息，这些信息不会输出给浏览器，存在的错误并没有被真正解决。

```php
@$num = 100/0;  // 除数不能为0
```

> 注意不要写在关键字上，而需要写在表达式上，如：echo @num;  而不能写成 @echo $num; 因为 echo 不是表达式。



### 8. 运算符优先级

| 结合方向 | 运算符                                                       | 附加信息                   |
| :------- | :----------------------------------------------------------- | :------------------------- |
| 不适用   | `clone` `new`                                                | clone 和 new               |
| 右       | `**`                                                         | 算术运算符                 |
| 不适用   | `++` `--` `~` `(int)` `(float)` `(string)` `(array)` `(object)` `(bool)` `@` | 类型、递增／递减           |
| 左       | `instanceof`                                                 | 类型                       |
| 不适用   | `!`                                                          | 逻辑运算符                 |
| 左       | `*` `/` `%`                                                  | 算术运算符                 |
| 左       | `+` `-` `.`                                                  | 算术运算符 和 字符串运算符 |
| 左       | `<<` `>>`                                                    | 位运算符                   |
| 无       | `<` `<=` `>` `>=`                                            | 比较运算符                 |
| 无       | `==` `!=` `===` `!==` `<>` `<=>`                             | 比较运算符                 |
| 左       | `&`                                                          | 位运算符 和 引用           |
| 左       | `^`                                                          | 位运算符                   |
| 左       | `|`                                                          | 位运算符                   |
| 左       | `&&`                                                         | 逻辑运算符                 |
| 左       | `||`                                                         | 逻辑运算符                 |
| 右       | `??`                                                         | null 合并运算符            |
| 左       | `? :`                                                        | 三元运算符                 |
| 右       | `=` `+=` `-=` `*=` `**=` `/=` `.=` `%=` `&=` `|=` `^=` `<<=` `>>=` `??=` | 赋值运算符                 |
| 不适用   | `yield from`                                                 | yield from                 |
| 不适用   | `yield`                                                      | yield                      |
| 不适用   | `print`                                                      | print                      |
| 左       | `and`                                                        | 逻辑运算符                 |
| 左       | `xor`                                                        | 逻辑运算符                 |
| 左       | `or`                                                         | 逻辑运算符                 |

> 括号可以提升优先级，将表达式中的某个部分看做一个整体。如果不清楚优先级，最好使用括号。



例：

```php
if($a = 3 && $b = 3){
	// 代码
}
```

> && 优先级比 = 要高，所以这个表达式应该看做 $a = (3 && $b = 3) ，结果 $a = true



### 9. 表达式

在 PHP 中，几乎所编写的任何代码都可以看做一个表达式，通常只要有变量、常量和运算符参与的的组合。简单但最精确的定义：“任何有值的东西”



# 五、流程控制

流程控制对于任何一门编程语言来说都是至关重要的，它提供了程序控制步骤的基本手段，是程序的核心部分。在任何一门程序设计语言中，都需要支持满足程序结构化所需要的三种结构：

- 顺序结构
- 分支结构（选择结构）
- 循环结构



## 1. 顺序结构

在程序结构中，最基本的就是顺序结构，顺序结构就是语句按出现的先后次序顺序执行。在 PHP 程序中，顺序结构的语句主要是赋值语句、输入/输出语句等。如：

```php
$a = 10;
$b = 20;
$sum = $a * $b;
echo $sum;
```



## 2. 分支结构

分支结构的执行是依据一定的条件选择执行，分支结构可以有以下几种形式：

- 单一条件分支结构

- 双向条件分支结构

- 多向条件分支结构

- 巢状条件分支结构



### 2.1 单一条件分支结构

```php
if (表达式)  // 不能在后边加分号
语句块; // 条件成立则执行，不成立则跳过
```



如果是多条语句，则可以用 { } 如：

```php
if (表达式) {
    语句1;
    语句2;
    语句3;
    语句4;
}
```

> 建议不论包含多少语句，都使用大括号 { }



### 2.2 双向条件分支结构

if 语句中也可以包含 else 子句，经常需要在满足某个条件时执行一条语句，而在不满足该条件时执行其他语句。 else 可以在 if 语句中的表达式为 False 时执行。 else 语句是 if 语句的子句，必须和 if 一起使用，不能单独存在。



~~~php
if (表达式) {		// if 判断是否成立
    语句;			// 条件成立则执行的语句
}
else {			
	语句;			// if 条件失败则执行 else 中的语句
}
~~~



### 2.3 多向条件分支结构

**多向条件分支结构 elseif() 子句，也可以用 else if()**

~~~php
语法格式：
if(表达式1){  // 如果表达式1为true，执行语句1
    语句1;
}elseif (表达式2){  //如果表达式2为True，则执行语句2
    语句2;
}else if(表达式3){  // 如果表达式所有条件都不成立（FALSE），执行 语句n
    语句3;
}else{
    语句n;
}		
~~~



在 elseif 语句中同时只能有一个表达式为 TRUE，即在 elseif 语句中只能有一个语句块被执行，即从多个 elseif 从句是排斥关系。这种多向条件分支结构适合对同一个变量的值在不同范围内进行判断。



使用 elseif 语句有一条基本规则，即总是有限把包含范围小的条件放在前边处理，如 $hour < 6 和 $hour < 9 两个条件。

```
if ($hour < 6) {
    echo "凌晨好";
} elseif ($hour < 9) {
    echo "早上好";
} else {
    echo "你好";
}
```



**多向条件分支结构还有一个 Switch 结构：**

判断表达式中的值是否 == case 值，如果为 true，则执行 case 中的代码。

~~~php
<?php
switch (表达式) {       //使用 switch 语句，对表达式求值
    case 值1：		    // 如果表达式的值和 “值1” 匹配，则执行 语句1、2、3、4，然后退出
        语句1;
        语句2;
        语句3;
        语句4;
        break;		    // break 用来退出分支结构
    case 值2:
        语句5;
        break;
    case 值3:
        语句6;
        break;
        ......			// case 语句可以无限增加
    default:			// 如果和其他 case 都不匹配的话，执行 default 默认，但 default 不必须的
        语句n+1;
        }				// 不要忘了花括号结束
        
~~~



switch - case 需要注意的一些细节：

1. 如果 case 语句过多，需要将多个语句做成一个函数或对象

2. switch（变量）的类型，允许整型或字符串或布尔型。

3. switch 语句是顺序执行，根据变量匹配好case后，依次执行case中的语句，直到switch结束或者碰到 break，break 是退出 switch 结构使用的，如果需要同时匹配多个值，可以使用多个 case，而不用加 break。

   ```
   case 1:
   case11:
   case111:
   echo " 这些case都符合";
   break;
   ```

4. 单个值匹配的时候，switch - case 比较方便，但 general 来说，else if 要比 switch 强大。一般判断范围的时候，我们用 else if



### 2.4 巢状条件分支结构

巢状条件分支结构就是 if 语句的嵌套，即指在 if 或 else 后边的语句块中又包含 if 语句。 if 语句可以无限层的嵌套在其他的 if 语句中。语法表达式如下：

~~~php
if (表达式1) {
	if (表达式2) {
		...
	} else {
		...
	}
} else {
	if (表达式3) {
		...
	} else {
		...
	}
}
~~~



例：

~~~php
<?php
$name = "Jason";
$sex = "F";
$age = 30;

if ($sex == "Male") {
    if ($age > 60) {
        echo "{$name}, This guy has been retired " . ($age - 60) . " years";
    } else {
        echo "{$name}, This guy has to wait " . (60 - $age) . " years to retire";
    }
} else {
    if ($age > 55) {
        echo "{$name} has been retired " . ($age - 55) . " years";
    } else {
        echo "{$name} has to wait " . (55 - $age) . " years to retire";
    }
}

~~~



### 2.5 HTML 条件语句拆分写法：

~~~php
<?php if(2 > 1){ ?>
    <p>输出HTML语句</p>
<?php } ?>
~~~



## 3. 循环结构

根据循环停止的条件不同、PHP提供两种类型的循环语句，一种是计数类循环语句，通常使用 for 语句，另外一种是条件循环语句，通常使用 while 或 do...while 来完成。另外还有一个已经不怎么使用的 goto 语句。

- while
- do...while
- for 
- goto



### 3.1 while

while 语句中的表达式结果一定要是布尔型的 true 或 false，如果是其他类型的值也会自动转换为布尔型。当表达式为 true 时，执行代码块。然后继续判断表达式，进入循环。直到表达式为 false 跳出循环。语法如下：

~~~php
while (表达式){
	语句块; // 循环体
}
~~~



一般会再 while 外，定义一个计数器，然后在 while 循环中给出一个跳出条件。



例：

~~~php
$i=0;
while($i<=100){
	echo "$i <br/>";
	$i++;
}
~~~



练习题：

请说出以下两端代码中最后 $i 的结果，以及两端代码中输出有什么不同。

~~~php
// 代码1
$i = 0;
while($i<10){
    echo ++$i;

}

echo "<br/>".$i;

// 代码2
$i = 0;
while($i<10){
    echo $i++;

}

echo "<br/>".$i;
~~~

> - 第一段代码循环体是 ++$i ，先做自增再执行 echo 显示，所以显示的 123456789，在 $i == 8 的时候，继续进入循环，然后自增再显示9，此时 $i 还是比10 小。进入循环，$i 自增到 10，然后 echo 输出 10。此时表达式变为 false，跳出循环，然后显示 $i ，$i 依然是 10
> - 第二段代码循环体是 $i++，先显示再自增，所以显示的是 0123456789，在 $i == 8 的时候，进入循环，显示 8 ，自增到9，然后继续进入循环，显示 9 ，自增到 10 ，跳出循环。输出 $i = 10



while 语句也可以用 break; 来退出循环。一般针对于死循环，循环内部一定要有跳出条件。

~~~php
$i = 0;
while (ture) {
    echo "{$i}";
    $i++;
    if ($i>=100) {
        break;
    }
}
~~~



**输出10行10列的表格**

~~~php
<?php

echo '<table border="1" align="center" width="800"';
echo '<caption><h1>Table</h1></caption>';

$i=0;
while ($i<100) {
    if ($i % 10 ==0) {
        echo '<tr>';
    }
    echo '<td>'.$i.'</td>';
    $i++;
    if ($i % 10 ==0) {
        echo '</tr>';
    }
}
echo '</table>';
echo '<br/>';
echo '<br/>';
~~~



while 语句也和 if 语句一样可以进行多层嵌套，通常是在有矩阵形式的输出时使用。while 虽然可以嵌套多层，但是如果没有必要最好不要超过3层以上

~~~php
<?php

echo '<table border="1" align="center" width="800"';
echo '<caption><h1>Table</h1></caption>';
$j=0;
while ($j<10) {
    $i=0;                                     // 如果内循环需要不断执行的话，不能放在外边，置零重新开始
    echo '<tr>';
    while ($i<10) {
        echo '<td>'.$i.'</td>';
        $i++;
    }
    echo '</tr>';
    $j++;
}
echo '</table>';
echo '<br/>';
echo '<br/>';

~~~



### 3.2 do...while

do...while 循环和 while 循环类似，区别是在于表达式的值是在每次循环结束时而不是在开始时检查。和 while 的区别是 do...while 循环语句保证会执行一次，之后再进入 while 循环。



do...while 语句格式：

~~~php
<?php

do {
    语句块;    
} while(表达式){
    语句块;
};  // 记得这里有分号。
~~~



do...while 循环在 PHP 中使用的较少，它最适合循环中的语句至少必须执行一次的情况。当然也可以用 while 语句完成同样的工作。



### 3.3 for

while 和 do...while 循环通常用于条件型循环，即遇到特定条件才停止循环。而 for 语句循环适用于明显知道重复执行次数的情况。



for 语句的使用格式：

~~~php
<?php
for（初始化; 条件表达式; 增量) {
    语句块;
}
~~~

- 初始化总是一个赋值语句，它用来给循环控制变量赋初值

- 条件表达式是一个判断，一般是布尔型，当表达式为真则执行循环体，假则退出循环体。
- 增量是定义循环控制变量，每循环一次，控制变量按什么方式变化。一般是自增或自减。每次循环后执行。



for 语句执行顺序：

第一次循环：

1. 执行初始化

2. 执行条件表达式

3. 执行循环体

4. 执行增量



进入第二次循环：

5. 执行表达式
6. 执行循环体

6. 执行增量



进入第三次循环：

7. 执行表达式

   .......



例：

~~~php
for ($i=1; $i<10; $i++) {
    echo "这是第 $i 次循环";
}
~~~



在 for 语句中，一个或多个表达式是允许为空的，如：

**缺少初始化**

~~~php
$i=1;
for (; $i<10; $i++) {
    echo "这是第 $i 次循环";
}
~~~



**缺少表达式**

~~~php
for ($i=1; ; $i++) {
    echo "这是第 $i 次循环";
    if ($i>10) {
        break;
    }
}
~~~



**缺少增量**

~~~php
for ($i=1; $i<10;) {
    echo "这是第 $i 次循环";
    $i++;
}
~~~



for 语句中，可以在每个表达式中编写多条语句。多个表达式用逗号隔开，如：

~~~php
<?php
for ($i=1, $j=2; $i<=10 && $j <= 100; $i++, $j++){
    // 循环体
}
~~~



for 语句中，也可以进行嵌套

~~~php
<?php
for ($i=1; $i<=9; $i++) {
    for ($j=1; $j<=$i; $j++) {
        echo "$j x $i = ".$j*$i." ";
    }    
    echo "<br/>";
}
~~~



## 4. 特殊流程控制语句

如果想在循环体执行过程中终止循环，或是跳过一些循环继续执行其他循环，需要使用一些特殊的流程控制语句。



### 4.1 break 语句

break 可以结束当前 for、foreach、while、do...while 或者 switch 结构的执行。 

~~~php
for ($i=1; $i<=10; $i++) {
    echo $i;
    if ($i=5) {
        break;
    }
}
~~~



如果是多层嵌套，可以通过 break 接收一个可选的数字参数来决定跳出几层循环语句，或是几重 switch 语句。从里层开始计数，默认 break 参数为 1，默认跳出1层循环。

~~~php
for ($i = 0; $i < 10; $i++) {
    if ($i > 5) {
        break;
    }
    for ($j = 0; $j < 10; $j++) {
        if ($j > 5) {
            break 2;
        }
        echo "#";
    }
    echo '<br>';
}
~~~



### 4.2 continue 语句

continue 语句只能用再循环语句内部，功能是跳过该次循环，继续执行下一次循环结构。在 while 和 do...while 语句中， continue 语句跳转到循环条件开始处开始继续执行下一步循环，对于 for 语句，是执行增量更新，然后再继续下一步循环。如：



~~~php
// 求1-100之间所有不被3整除数之合
$sum = 0;
for ($i = 1; $i <= 100; $i++) {
    if ($i % 3 == 0)
        continue;
    $sum += $i;
}
echo "结果为: $sum";
~~~



如果是在 while 循环语句中使用 continue，在循环中遇到 continue 语句后，就不会继续执行该循环中在 contitnue 之后的语句。需要注意增量的问题，如：

~~~php
$i = 0;
while ($i < 100) {
    if ($i % 3 == 0)
        continue;
    echo "{$i} @@@@@@@@@@@@<br>";
    $i++;
}
~~~

> 上边的程序是死循环，因为 continue 后，虽然跳出本次循环，但是又回到 while($i<100) 条件判断语句这里，而增量$i并没有增加。所以会出现死循环。



另外和 break 语句一样， continue 语句也可以接受一个可选的参数来决定跳出多重语句，如：

~~~php
<?php
for($i = 1; $i<10; $i++){
    echo $i."<br/>";
    for($j = 9; $j>=0; $j--){
        echo $j."<br/>";
        if($j==7){            
            continue 2;
        }
    }
}
~~~



### 4.3 exit 语句

如果遇到 exit; 或 exit(); 程序直接退出，可以待一个参数输出一条信息。如：

~~~php
$conn = mysql_connect("localhost", "root", "123456") or exit ("连接数据库失败");
~~~

> die(); 函数是 exit(); 函数的别名。



### 4.4 goto 语句

goto 语句 需要一个标记，格式为标记名 + 冒号，由于 goto 语句的缺陷很多，所以一般不建议使用，只做了解即可。

~~~php
$a = 1;
$b = 2;
if ($a > $b){
    goto big;
}else{
    goto small;
}

big:
echo "BIG";

small:
echo "SMALL";
~~~



利用 goto 语句做循环：

~~~php
xx:
echo "#######";
goto xx;  // 死循环
~~~



不过很容易出现死循环，一般在里边加增量，用 if 判断，再用 goto 跳出。

~~~php
xx:
echo "######";
$i = 0;
$i++;
if ($i > 5) goto next;

next:
echo "!!!!!!!";
~~~



最好是用 { } 将代码段括起来

~~~php
xx: {
    echo "######";
    $i = 0;
    $i++;
    if ($i > 5) {
        goto next;
    }
}

next: {
    echo "!!!!!!!";
}
~~~



另外， PHP 中的 goto 语句使用时只能在同一个文件的作用域中跳转，也就是说无法跳出一个函数或类方法，也无法跳入另一个函数，更无法跳入任何循环或者switch结构中。 goto 语句常见的用法是跳出循环或者switch语句，可以代替多层的 break。



# 六、PHP 函数应用

## 1. 函数的定义

函数是被命名的：每个函数都有唯一的名称，在程序的其他部分使用该名称，可以执行函数中的语句。称为调用函数。



函数就是有一定功能的一些语句组织在一起的一种形式，函数可以遵照给它的一组值或参数完成特定的任务，并且可能返回一个值，定义函数的目的是将程序按功能分块，方便程序的使用。函数分为两种，一种是系统内部提供的函数，比如  gettype(), isset(), die()。



当系统函数无法满足我们的需求时，或者需要一个特殊功能的函数，我们可以自己自定义一个函数。比如：

- 走路();

- 吃药();



走路或吃药都是自定义函数，里边包含了很多语句，这些语句块的作用就是为了完成这个走路这个目的。而我们需要使用的时候，直接调用函数，就会直接运行函数中包含的语句，达到目的。不用再重新写函数中的语句。

- 控制程序设计的复杂性
- 提高软件的可靠性
- 提高软件的开发效率
- 提高软件的可维护性
- 提高程序的重用性



## 2. 函数的声明

在PHP中声明一个自定义的函数语法格式：

~~~php
function 函数名 (参数1, 参数2, 参数3, ..., 参数n) {
	函数体;
	return 返回值;
}
~~~

函数名不区分大小写。命名函数时不能重复定义相同名字的函数，也不能与系统函数重名。



例：

~~~php
<?php

// 声明一个函数
function table()
{
    echo '<table border="1" align="center" width="800">';
    echo '<caption><h1>Table</h1></caption>';

    for ($i = 0; $i < 10; $i++) {
        $bg = ($i % 2 == 0) ? "#cccccc" : "";
        echo '<tr bgcolor="' . $bg . '">';
        for ($j = 0; $j < 10; $j++) {
            echo '<td>' . $j . '</td>';
        }
        echo '</tr>';
    }
    echo '</table>';
}

// 调用函数
table();
~~~



## 3. 函数的调用

table 就是函数的名字，我们之后调用函数就可以用 table(); 这样就执行了函数中的语句。在 PHP 中可以在函数的声明之后调用函数，也可以在函数的声明之前调用，还可以在函数中调用函数。但是如果只是写了 function，而没有调用函数的话，则函数中的语句不会被执行。



## 4. 函数的参数

参数列表是由0个、1个或多个参数组成的。每一个参数是一个表达式，用逗号分隔。对于有参函数，在PHP程序中和被调用函数之间有数据传递关系。定义函数时，函数名后边括号内的表达式为形式参数，在调用函数时，括号内的表达式为实际参数。实参和形参需要按顺序对应传递数据。

函数参数的作用是让用户在调用函数的时候，改变函数内部的执行行为，从而达到用户自定函数的执行效果。



例：

~~~php
<?php

function add($num1, $num2){
    echo $num1 + $num2;
}

add(10, 20);

输出：
30
~~~



输出一个表格：

~~~php
<?php

/**
自定义函数 table()， 声明三个参数，参数之间使用逗号分隔
@param	string	$tablename	字符串类型的表名
@param	int		$rows		整型的行数
@param	int		$cols		整型的列数
 */

//声明函数时，提供的参数（形式上的参数）
function table($tablename, $rows, $cols)
{
    echo '<table border="1" align="center" width="800">';
    echo '<caption><h1>' . $tablename . '</h1></caption>';

    for ($i = 0; $i < $rows; $i++) {
        $bg = ($i % 2 == 0) ? "#cccccc" : "";
        echo '<tr bgcolor="' . $bg . '">';
        for ($j = 0; $j < $cols; $j++) {
            echo '<td>' . $j . '</td>';
        }
        echo '</tr>';
    }
    echo '</table>';
}

table("Table1", 5, 10); //实参(实际的参数）
echo '<br/>';
table("Table2", 10, 10);

~~~



## 5. 函数的返回值

函数的返回值是将函数执行后的结果返回给调用者。如果函数没有返回值，就是只能算一个执行过程。由于作用域的差异，调用函数的脚本程序不能直接使用函数体里边的信息，但可以通过关键字 return 向调用者传递数据。 return 语句在函数体中使用时， 有以下两个作用。

- return 语句可以向函数调用者返回函数体中任意确定的值。
- 将程序控制权返回到调用者的作用域，即退出函数。在函数体中如果执行了return语句，它后边的语句就不会执行了。
- 函数没有 return 时，返回 null



return 语句可以向函数调用者返回函数体中任意确定的值。如：

~~~php
<?php

function add($num1, $num2){
    return $num1 + $num2;
}

$result = add(10, 20);
echo $result;

输出：
30
~~~



return 语句可以起到 break 的作用

~~~php
function add($num1, $num2){
    while(true){
        $num1+=$num2;
        $num2++;
        if($num2==10){
            return $num1;  // 当 $num2 == 10 的时候，中断函数，返回 $num1 的值
        }

    }
}

$result = add(0, 1);
echo $result;
~~~



函数没有 return 时，返回 null

~~~php
<?php

function add($num1, $num2){
    echo $num1 + $num2;
}

$result = add(10, 20);
var_dump($result);

输出：
30
C:\wamp64\www\php.php:8:null
~~~



用参数的形式输出一个表格，并保存为 html 文件：

~~~php
<?php


/**
自定义函数 table()， 声明三个参数，参数之间使用逗号分隔
@param	string	$tablename	字符串类型的表名
@param	int		$rows		整型的行数
@param	int		$cols		整型的列数
 */

//声明函数时，提供的参数（形式上的参数）
function table($tablename, $rows, $cols)
{
    $str = "";
    $str .= '<table border="1" align="center" width="800">';
    $str .= '<caption><h1>' . $tablename . '</h1></caption>';

    for ($i = 0; $i < $rows; $i++) {
        $bg = ($i % 2 == 0) ? "#cccccc" : "";
        $str .= '<tr bgcolor="' . $bg . '">';
        for ($j = 0; $j < $cols; $j++) {
            $str .= '<td>' . $j . '</td>';
        }
        $str .= '</tr>';
    }
    $str .= '</table>';

    return $str;
}

table("Table1", 5, 10);  // 屏幕上不会显示任何表格
echo table("Table1", 5, 10); // 实际上相当于 echo 函数中最后返回的 $str;
echo '<br/>';
file_put_contents("demo.html", table("Table2", 10, 10));  // 用 file_put_contents() 内部函数将 $str 保存在 html 文件中。

~~~

所有的输出语句都是字符串，我们创建一个变量 $str ，然后将所有的输出语句全都放在这个 $str 变量中，最后返回这个变量，这个就是 table 函数的返回值，当你执行 table(); 的时候，虽然函数运行了，但是因为函数体里边已经没有了输出语句，所以并不会在屏幕上输出任何数据。但是这些数据已经保存在了 $str 这个变量里。这个 $str 返回给了函数，也就是说执行 table(); 之后，table(); 最后得到的值就是 $str。也就是说 table(); 变成了一个变量。那么这时候我们再想输出表格时，就需要用 echo 语句来输出表格了。

另外函数多了返回值，用处也比没有返回值的功能要强，因为我们可以利用返回值来做各种事情，既可以输出，也可以将输出的文字保存在数据库中或文件中。



函数的优先级是很高的，先执行函数，得到返回值后再进行其他计算。



## 6. function_exists()

可以用 function_exists() 函数判断函数是否存在 

~~~php
if (function_exists("table")) {
    echo " table 函数存在";
} else {
    echo " table 函数不存在";
}
~~~



## 7. 变量的范围

大部分的 PHP 变量只有一个单独的使用范围，也包含了 include 和 require 引入的文件。当一个变量执行赋值动作后，会随着声明区域位置的差异而由不同的使用范围。大体上变量根据位置分为局部变量和全局变量。



### 7.1 局部变量

当函数被调用完，函数里边所有被声明的变量，都会被释放，无法在函数外使用。函数内部声明的变量，值能在函数内部调用，这就是局部变量。

局部变量也称为内部变量，是在函数内部声明的变量，离开函数后再使用这种变量是非法的。不仅在函数中声明的变量是局部变量，函数的参数也是一个局部变量，和函数体内部的变量是一样的。区别在于参数可以在调用时从外部传值。

- 局部变量的值，无法在函数外部使用，如果想在外部使用，则需要使用 return 关键字将值传回函数。

- 函数内部的局部变量，在函数结束后就会被释放了。



~~~php
<?php

function add($num1, $num2){
    $total = $num1 + $num2;
}

$result = add(10, 20);
echo $result;
echo $total;
~~~

> 不论是 $result 还是 $total 都无法显示，因为没有返回值，所以 $result 是 null，而 $total 是函数内部变量，也无法在函数外部使用。



### 7.2 全局变量

全局变量也称为外部变量，是在函数的外部定义的，它的作用域为从变量定义处开始，到本程序文件的末尾。和其他编程语言不通，全局变量不是自动设置为可用的。在PHP中，由于函数可以视为单独的程序片段，所以局部变量会覆盖全局变量的能见度，因此在函数中无法直接调用全局变量。

如果需要在函数中调用全局变量，则需要用 global 重新在函数中声明变量。告诉函数这些变量是全局变量，如：

~~~php
<?php

$one = 1;
$two = 2;
function demo()
{
    global $one, $two;
    echo '$one + $two = ' . $one + $two . '<br/>';
}
~~~



- 如果函数中需要使用的全局变量，不仅仅需要在函数中使用 global 关键字，还需要注意顺序问题，需要将变量声明在函数调用之前。

- 全局变量或函数外部变量在程序结束后或被 unset() 之后才会释放



### 7.3 常量

在程序中，常量可以在任何地方使用，包括函数内部。

~~~php
<?php

define("NAME", "TEXT");
function demo()
{
    echo NAME;
}
demo();
~~~



像 `$_POST`、`$_GET`这些算是全局数组，默认为全局变量，不用在函数内再次用 global 重新声明，如：

~~~php
<?php

$_POST['a'] = 100;
$_GET['b'] = 300;
function demo()
{
    echo $_POST['a'];
}
demo();
~~~



### 7.4 静态变量

局部变量从存储方式上可分为动态存储类型和静态存储类型。局部变量在函数中，如不专门声明为 static 存储类别，默认都是动态存储的。变量在函数调用完则会被自动释放。

如果希望在函数执行后，变量依旧想保存在内存中，应使用静态变量。在函数执行完毕后，静态变量并不会消失。静态变量将接续前次结果继续运算。

**静态变量仅在脚本执行期间函数第一次被调用时初始化**。第二次被使用时，程序会查看变量是否是静态，如果是静态变量，则到静态区查看是否存在同名变量，如果有则使用，不会再重新声明。声明静态函数，需要用关键字 static 。静态变量，只在同一函数多次调用中共享。（如果在其他函数中同样声明同名静态函数，互不影响）



~~~php
<?php

function demo()
{
    static $a = 0;
    $a++;
    echo $a . "<br>";
}
demo();		// 第一次执行 a=1
demo();		// 第二次执行 a=2
demo();		// 第三次执行 a=3
demo();		// 第四次执行 a=4
demo();		// 第五次执行 a=5
~~~



全局也可以声明 static 静态变量，但是没有意义~ 



## 8. 函数文档说明

无论是使用系统函数还是自定义函数，我们都要通过如下函数的三要素来了解一个函数：

- 函数的功能描述
- 函数的参数
- 函数的返回值

所以在文档中，我们需要将这些要素写在文档中，以便他人使用我们定义的函数。



如下所示，一般函数声明时所写的文档注释，第一行为功能描述，然后是参数描述，返回值描述，文档最后一行是函数使用格式说明。

~~~php
<?php

/**
功能：处理两个数相加
@param int $a		第一个加数
@param int $b		第二个加数
@return int		返回两个加数的和
add(int $a, int $b) //参数传整型
 */

function add($a, $b)
{
    return $a + $b;
}
~~~



### 8.1 常规参数的函数格式文档

常规参数的函数格式说明：

~~~php
string example(string $name, int $age, double $height)
~~~

在上边常规参数的函数语法格式示例中，声明一个名为 example 的函数函数执行后返回一个字符串类型的值。该函数有三个参数，调用时传递的参数个数和顺序必须一致，第一个参数是字符串型，第二个是整型，第三个是双精度浮点型。



### 8.2 伪类型参数的函数

有些参数无法定义数据类型，比如说下边的这个 number ，实际上 PHP 中并没有 number 这个类型，只是我们给它起的一个名，这个类型可以传整型和浮点型。

~~~php
/**
功能：处理两个数相加
@param number $a		第一个加数
@param number $b		第二个加数
@return number 		返回两个加数的和

add(number $a, number $b) //参数传伪类型
*/
~~~

> 除了 number 这种伪类型，还可以使用 mixed 或 callback。



## 9. 参数的传递

### 91. 传递引用参数



在 PHP 中默认是按值传递参数，而且函数的参数也属于局部变量，所以即使在函数内部改变参数的值，它并不会改变函数外部的值。函数为子程序，而调用函数的程序可以称为父程序。父程序直接传递指定的值或变量给函数使用。由于所传递的值或变量与函数里的数值分别储存于不同的内存区块。所以如果函数对所导入的数值做了任何改动，并不会对父程序造成直接影响。



如果希望允许函数修改传入变量的值，则必须通过引用传递参数。直接把该变量的内存地址传递给参数，因此，在变量在函数中有任何变动时，则会连队父程序造成影响。在函数定义中，需要加上符号 & 即可。

1. 只有在内存中的变量，才有地址

2. 有引用关系的两个变量，只要有一个变量值发生改变，另一个也发生改变



如果在函数说明中，有 & 出现，说明这个参数是一个引用参数，你调用传参数时，就必须传一个变量。如：

~~~php
<?php

$b = 20;
function demo(&$a)
{
    $a = 100;
}

demo(20); // 错误，不能将20这个数值传送给地址。
demo($b); // 正确，可以将$b的地址传送给&$a，那么在函数中 $a 的值变了，那么 $b 也跟着变化。
~~~

> 引用参数的目的是为了函数中将参数处理后，外部的变量也会同时改变。



### 9.2 默认参数（可选参数）的传递

给函数参数设定默认值，如果没有传值，自动按默认处理，但是一定要按顺序传值。如果部分参数有默认值的话，一定要将有默认值的参数定义时放在后边。

~~~php
<?php

/**
默认参数
demo(string $name, int $age, [string $sex, string $email]); // 中括号为可选参数
 */

function demo($name,  $age, $sex = "three", $email = "four")
{
    echo "{$name} -- {$age} -- {$sex} -- {$email} <br/>";
}

demo();  // 无法执行，因为没有传参
demo("妹子");  // 无法执行，因为只传递了一个必选参数
demo("妹子", 20, "女");  // 可以执行，最后的 $email 变量没有传参但是有默认值，自动以默认值作为参数的值
~~~

> 有默认值的为可选参数，没有默认值的为必选参数。



### 9.3 可变个数参数的函数

目的是让可以传的实参可以比形参多，当我们不知道参数个数的时候，可以使用PHP提供的几个内部函数：

- func_get_args() 
- func_get_arg()
- func_num_args()



~~~php
<?php

function demo(){
    var_dump(func_get_args());  // 以数组形式获取所有参数
    var_dump(func_get_arg(3));  // 获取第4个参数
    var_dump(func_num_args());  // 获取参数的总个数
}

demo(1,2,3,4,"name");
~~~

> 虽然函数没有定义任何参数，但是还是可以通过 func_get_args() 获取传递过来的参数，以数组形式获得。



例：求所有参数的和

~~~php
<?php

function demo()
{
    $arr = func_get_args();     //将所有实参放入数组 $arr 中。
    $sum = 0;
    for ($i = 0; $i < count($arr); $i++) {    // count 是统计数组中的个数
        $sum += $arr[$i];
    }
    return $sum;
}

$result = demo(1, 2, 3, 4, 5, 6);
echo $result;
~~~



## 10. 回调函数

所谓回调函数，就是指调用函数是并不是传递一个标准的变量作为参数，而是将一个函数作为参数传递到调用的函数中。如果函数的格式说明中出现 "callback" 类型的参数，则该函数就是回调函数。如：

~~~php
usort ( array &$array , callable $value_compare_func ) : bool
~~~

> usort 函数是一个系统内部函数，将用用户自定义的比较函数对一个数组中的值进行排序。其中 $value_compare_func 就是一个回调函数。需要传入一个函数当做 usort 函数的参数。



如果传一个变量（值）到函数中，如果并不能解决问题时，就需要传一个过程进入到函数。在函数调用时，在参数中传的不是一个变量或值，而是一个函数，这就是回调函数。例：

~~~php
<?php
function mycom($a, $b)
{
    if ($a > $b)
        return 1;
    else if ($a < $b)
        return -1;
    else
        return 0;
}

$arr = array(1, 5, 8, 9, 3, 2, 4, 7, 6);
print_r($arr);

// usort 是一个用来给数组排序的函数，排序方法是按照我们自定义函数的方法来进行排序的。
// 调用 mycom() 函数，来判断return的值，只要将需要调用的函数的名称以字符串形式放在参数中，就可以实现回调参数的作用。
usort($arr, "mycom");
echo '<br>';
print_r($arr);
~~~



制作一个回调函数，例：

~~~php
// 过滤能被5整除的数字

<?php
function demo($num, $callBack)
{    
    for ($i = 0; $i < $num; $i++) {   // 循环，让 $i 从 0 开始一直到 $num
        if ($callBack($i))        // 如果 test($i) 为真的话，那么跳过（相当于过滤功能）
            continue;
        echo $i . "<br/>"; // 否则输出 $i 
    }
}

function test($i)
{
    if ($i % 5 == 0)
        return true;
    else
        return false;
}

demo(500, "test");
~~~



利用 call_user_func_array() 制作回调函数，例：

~~~php
mixed call_user_func_array ( callable $callback , array $param_arr )
~~~

> 该函数有两个参数：把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的的参数传入。
>
> - 注意：参数个数如果是变化的时候，就不能直接调用这个函数



~~~php
function fun( $msg1 , $msg2 )
{
    echo 'msg1:'.$msg1;
    echo "<br />\n";
    echo 'msg2:'.$msg2;
}
call_user_func_array('fun', array('Hello', 'World'));  // 第一个是需要调用的函数 fun()，第二个是一个数组，数组里边的元素是 fun 的定义参数，当调用 fun() 函数时，会依次将数组中的值传递给 fun() 当做 fun() 函数中的参数。
~~~

> 这里使用了PHP内置的函数call_user_func_array来进行调用。call_user_func_array有两个参数，第1个参数是一个字符串，表示要调用的函数名，第2个参数是一个数组，表示参数列表，按照顺序依次会传递给要调用的函数。
>
> 数组中的元素必须要和 fun() 函数中定义的参数数量相等



利用 call_user_func_array 对自定义回调函数的修改

~~~php
<?php
// 将500传入$num， 将 test() 传入 $fun
function demo($num, $fun)
{    	
    for ($i = 0; $i < $num; $i++) {
        if (call_user_func_array($fun, array($i)))
            // 利用系统函数调用另一个函数test, 而test的参数为$i，虽然是数组，但是这个数组中只有一个成员。即每次循环得到的 $i 的值。
            continue;
        echo $i . "<br/>";
    }
}

function test($i)
{
    if ($i % 5 == 0)
        return true;
    else
        return false;
}

demo(500, "test");
~~~





## 11. 递归函数

在函数中调用自己就是递归函数，但是如果不加条件的自己调用自己就会陷入死循环，如：

~~~php
<?php
function test()
{
    test(); // 自己调用自己，但是会陷入死循环，需要有退出自己的条件
}
test();
~~~



~~~php
<?php
function test($n)
{
    echo $n . "<br>";
    if ($n > 0) {
        test($n - 1);
    } else {
        echo "--------<br>";
    }
    echo $n . "<br/>";
}

test(10);

运行结果：
10
9
8
7
6
5
4
3
2
1
0
----------
0
1
2
3
4
5
6
7
8
9
10
~~~



~~~
第一步，执行test(10)，echo 10，然后因为10>0，执行test(9)，
第二步，执行test（9），echo 9，然后因为9>0，执行test（8）
第三步，执行test（8），echo 8，然后因为8>0，执行test（7）
...
第十步，执行test（0），echo 0，此时0>0的条件不满足，不在执行test（）函数，而是echo “----------”，并且执行后面的 echo 0
第十一步，最里边的一层执行完毕，返回上一层的 test(1)，继续执行 if 后边的语句 echo $n 这时候的 $n = 1，然后输出1
第十二步，返回上一层，执行 echo 2
...
最后一步，回到最外层，执行 echo 10
~~~



遍历目录下所有文件

~~~php
<?php
$dirname = "/.phpmyadmin";

function fordir($dirname)
{
    $dir = opendir($dirname); // 打开目录资源，返回资源给 $dir
    readdir($dir) . '<br>'; //读当前目录的第一个文件名，读到结尾后返回假
    readdir($dir); // 过滤头 . 和 ..
    readdir($dir);
    while ($file = readdir($dir)) {
        $file = $dirname . "/" . $file;
        if (is_dir($file)) {
            echo "目录: {$file}<br>";
        } else {
            echo "文件: {$file}<br>";
        }
    }
    closedir($dir);
}
fordir($dirname);

~~~



## 12. 引用外部php文件（自定义函数库）

函数库并不是定义函数的 PHP 语法，而是编程时的一种设计模式。为了更好地组织代码，使自定义的函数可以在同一个项目的多个文件中使用，通常将多个自定义的函数组织到同一个文件或多个文件中。



### 12.1 include

在文件中直接用 include 命令直接引入其他文件中的函数，即可以在本文件中使用其他文件中的函数。

假设我们在 function.inc.php 中定义了三个函数：one(), two(), three() 。我们需要在 index.php 中调用这些函数。那么在 index.php 中我们可以这样写：

~~~php
<?php
include "function.inc.php";  // 也可以直接写 include("function.inc.php"); 以参数形式传递（效率低，不建议）
one();
two();
three();
~~~

> - 如果是当前路径用可以直接写文件名，或用 ./function.inc.php
> - 如果是上一级路径需要写 ../function.inc.php
> - 如果是下一级路径需要写 ./folderName/function.inc.php



include 不仅仅可以引入 php 文件，也可以引入其他类型的文件 txt、html 等等。如：

```php
include "demo.txt";
include "text.html";
```



### 12.2 include_once

为了避免重复命名函数或者变量的情况出现，在 include 命令中包含的文件不能再次被 include。

include_once 命令比 include 多了一个判断功能，用 include_once 包含文件，系统会判断该文件是否已经被包含了。如果已包含过了，则不会再次包括。

```php
include_once "demo.php";
include_once "demo.php";
include_once "demo.php";
include_once "demo.php"; //可以重复使用，不会报错
```

> 由于需要做判断，所以 include_once 效率要比 include 低，建议尽量用 include



### 12.3 require 和 require_once

require 和 require_once 和 include 与 include_once 类似，include() 与 require() 的区别

- 当PHP程序处理失败时，include() 会出现警告，脚本还会继续执行。而 require() 会出现致命错误，脚本停止运行。
- PHP在执行前就会读入 require() 语句所引入的文件。 而当PHP脚本文件读到 include 语句时，才将它包含的文件读进来。
- include()执行时需要引用的文件每次都要进行读取和评估，require()执行时需要引用的文件只处理一次(实际上执行时需要引用的文件内容替换了require()语句)
- include() 当在if判断为false的时候，不会被引入。require不管是不是false都会被引入
- include() 有返回值，require() 没有。



什么时候使用 include() 和 require()

- require通常使用方法，这个函数通常放在 PHP 程序的最前面，PHP 程序在执行前，就会先读入 require 所指定引入的文件，使它变成 PHP 程序网页的一部份。常用的函数，亦可以这个方法将它引入网页中。如果可能执行多次的代码，则使用 require(); 语句效率比较高。

- include通常使用方法，这个函数一般是放在流程控制的处理部分中。PHP 程序网页在读到 include 的文件时，才将它读进来。这种方式，可以把程序执行时的流程简单化。如果每次执行代码时读取不同的文件，或者有通过一组文件迭代的循环，就使用 include() 语句。



## 13. 可变函数（变量函数）

变量函数也称为可变函数，如果一个变量名后边有圆括号，PHP将寻找与变量的值同名的函数，并且尝试执行它。如：

~~~php
<?php

function test() {
    echo "test";
    }
    
$demo = "test";
$demo();  // 这句相当于先把$demo直接转换成$demo的值（test），然后再加括号，意义等同于 test();
~~~

> 可变函数不能用于 echo, print, unset(), isset(), empty(), include, require 以及类似的语言结构



## 14. 匿名函数和闭包

闭包概念：在一个内部函数中，对外部作用域的变量进行引用



### 14.1 匿名函数

匿名函数只在 PHP 5.3 以上的版本存在，它允许临时创建一个没有指定名称的函数，常用作回调函数参数的值。

~~~php
<?php
$var = function ($a, $b, $c) {
    return $a + $b + $c;
}; //如果使用匿名参数，必须给函数赋值，然后一定要加分号
echo $var(1, 2, 3); // 用变量函数来调用
var_dump($var); //  对象类型，是内置类 Closure（闭包） 的对象实例
~~~



### 14.2 嵌套函数

PHP 内部函数，当创建一个函数时，该函数里边又包括两个函数，这两个函数就是内部函数，属于局部变量，外部无法直接调用。就起到了一个封装的作用。如：

~~~php
<?php
function demo()
{
    echo "11111111<br/>";
    function one()
    {
        echo "222222<br/>";
    }
}

demo();
one(); // 当demo(); 被执行后， one(); 才会被声明，才可以被执行。如果单独调用 one 则无法正常调用。
~~~



### 14.3 闭包

闭包的实现主要靠匿名函数，将匿名函数在普通函数中当做参数传入，也可以被返回，就实现了一个简单的闭包。通俗的说，就是子函数可以使用父函数中的局部变量。这种行为就叫做闭包。

闭包概念：在一个内部函数中，对外部作用域的变量进行引用，(并且一般外部函数的返回值为内部函数)，那么内部函数就被认为是闭包。

~~~php
<?php
function demo()
{
    $one = function ($str) {
        echo $str;
    };
    $one('hello world');
}

demo();
~~~

> 在函数中使用匿名函数，但是这个不是真正的闭包，只是在内部函数中，执行了我们需要运行的函数



连接闭包和外界变量的关键字： use

~~~php
<?php
function demo()
{
    $a = 10;
    $b = 20;
    $one = function ($str) use ($a, $b) { // 只传了副本进来，函数内部改变了值，对外部不影响
        echo $str . "<br>";
        $a++;
        echo $a . "<br>";
        echo $b . "<br>";
    };

    $one('hello world');
    echo $a;
}

demo();

输出结果：
hello world
11
20
10
~~~



如果想让内部变量变化，外部变量同样变化的话，那么在用 use 的时候需要加上 &，通过引用地址来连接内部变量和外部变量。

~~~php
<?php
function demo()
{
    $a = 10;
    $b = 20;
    $one = function ($str) use (&$a, &$b) {
        echo $str . "<br>";
        $a++;
        echo $a . "<br>";
        echo $b . "<br>";
    };
    return $one;
}

$var = demo();  // 相当于 $var = $one
$var("hello world");  // 因为运行过 demo(); 所以可以执行里边的子函数 $one()
~~~



闭包的两个特点：

1. 作为一个函数变量的一个引用，当函数返回时，其处于激活状态

2. 一个闭包就是当一个函数返回时，一个没有释放的栈区。



# 七、数组

数组是PHP中最重要的数据类型之一，因为PHP是弱类型语言，所以数组变量可以存储任意多个、任意类型的数据。使用数组的目的就是将多个相互关联的数据组织在一起形成集合，作为一个单元使用。以达到批量处理数据的目的。



- 把若干变量按有序的形式组织起来的一种形式，这些数据元素的集合称为数组。
- 数组按下标个数分类有一维数组，二维数组等，二维数组以上数组通常称为多维数组。
- 数组是一个容器，使用目的是可以批量操作。



## 1. 数组的分类

PHP中有两种数组：索引数组和关联数组

- 索引（indexed）数组的索引值是整数，以0开始。当通过位置来标识东西时用索引数组。

- 关联（associative）数组以字符串作为索引值，关联数组更像操作表。索引值为列名，用于访问列数据。



~~~php
$arr= array("one", 10, 13.4, true);  // 一个数组可以存各种类型的变量。
$arr[0] = "aaaa";  // 索引数组
$arr['one'] = "bbbb"; // 关联数组
~~~



数组中存的是多个内容，数组中的内容叫做“元素”， 每个元素都是由键和值组成的（key / value），key 也称作下标，值则为元素内容

~~~php
$a = array(1,2,3,4,5);  // 索引数组， 索引从0开始，0,1,2,3,4,5 是键。 1,2,3,4,5 是值
$b = array("one" =>"111111", "two"=>"222222");  // 关联数组 one 是键、11111为值
~~~



当key为数字的时候为索引数组，当key为字符串时为关联数组。

```
// 索引数组
$arr[0] = 1;
$arr[1] = 2;
$arr[2] = 3;

// 关联数组
$arr["one"] = 1;
$arr["two"] = 2;
$arr["three"] = 3;
```



索引数组和关联数组是可以同时存在于一个数组变量当中，如：

~~~php
$arr[0] = 1;
$arr[1] = 2;
$arr[2] = 3;
$arr["one"] = 1;
$arr["two"] = 2;
$arr["three"] = 3;
~~~





## 2. 创建数组

在PHP中自定义数组可以使用以下几种方法：

- 直接赋值的方式声明数组
- 使用 array() 语言结构声明数组
- 使用 `[ ]` 声明数组



### 2.1 索引数组创建方法

~~~php
// 直接赋值
$arr[0] = 1;
$arr[1] = 2;
$arr[3] = 3;

// 使用[]单独创建，默认为索引下标，从0开始计数
$arr[] = 1;
$arr[] = 2;
$arr[] = 3

// 使用[]批量创建
$arr = [1,2,3];

// 使用 array() 创建
$arr = array(1,2,3);

// 使用 array() 创建
$arr = array(
	0 => 10,
    1 => 20,
    2 => 30
);
~~~



还有一些其他赋值方法，比如说 for 循环，给数组赋值，本质上还是用 [ ] 赋值。

~~~php
<?php
$arr = array();
for ($i = 0; $i < 5; $i++) {
    $arr[] = $i * $i;
}
var_dump($arr);
~~~



### 2.2 关联数组声明方法

~~~php
// 直接赋值
$arr['num'] = 10;
$arr['name'] = 'zhangsan';

// 使用 [] 创建
$arr = ["one" =>"111111", "two"=>"222222"];

// 使用 array()
$arr = array("one" =>"111111", 
             "two"=>"222222"
);

~~~



### 2.3 { } 与 [ ]

可以用 [] 来操作下标，也可以使用 {} 进行互换，建议使用中括号。

```php
$arr1['one'] = 1;
$arr[0] = 1;
echo $arr['one'];

$arr{'one'} = 1;
$arr{0}=1;
echo $arr{'one'};
```



在PHP中，中括号不会被认为特殊符号，如果使用 {} 则会输出字符串。

```php
$arr = array("one" =>"111111", "three"=>"222222");
echo "11111$arr[three]11111";  //[]中不要再加引号
echo "11111$arr{three}11111";  //会输出 three 字符串，并且有警告

输出结果：
1111122222211111
11111Array{three}11111
```



### 2.4 关联数组中的双引号

~~~php
echo $arr[four];
echo $arr["four"];
~~~

> 如果在下标中不加双引号，会被认为是常量，自动转换为字符串。效率会低。



### 2.5 下标

包含有合法整型值的字符串会被转换为整型

~~~php
$arr["2"] = 2; //下标为2
$arr["02"] = 2; // 下标为02
$arr[2.7] = 2; // 下标为2;
$arr[true] = 5; // 下标为1;
$arr[false] = 6; // 下标为0;
$arr[null] =7; // 下标为空
~~~



在 PHP 中，索引数组的下标可以使非连续的值，只要在初始化时指定非连续的下标值即可。

~~~php
$arr[] = 1;						// 下标为0
$arr[14] = 14;					// 指定非连续的下标为14
$arr[] = "中石化";				// 紧跟最高的下标值增1后为15
$arr[14] = 18;					// 重新定义14键值的元素
$arr[] = "gao@gmail.com";		// 会紧跟最高的下标值增1
~~~



关联数组字符串下标不会影响索引下标的排列规则。

~~~php
$arr[] = 1;
$arr[4] = 4;
$arr['one'] = 5;
$arr[] = 6; // 下标为5
~~~



负数也可以作为下标

~~~php
$arr[-100] = 'aa';
~~~









## 3. 输出数组

用 print_r() 或 var_dump() 输出数组，如：

~~~php
print_r($arr);
var_dump($arr);
~~~



用源代码格式输出

~~~php
echo '<pre>'; 
print_r($arr);
echo '</pre>';
~~~



用函数调用数组：

~~~php
<?php
function demo()
{
    return array("one", "two", "three");
}
$arr = demo();
echo $arr[0];
echo '<br>';
echo demo()[1]; // 直接用函数后边带中括号的方式调用已声明的数组。
~~~



## 4. 数组函数isset()

isset() 可以判断数组是否存在





# N、POST & GET 请求

将表单数据传送给 php 有两种，一种是 GET （URL 传送数据） 另外一种是 POST （HTTP协议传送），一般上传文件、表单都用POST，链接用 GET。

GET  因为是明文，不太安全，并且有长度限制。

**GET 传送数据**

**1. URL 传送数据**

client.html

```
server.php?name=zhangsan&age=10
```



**2. FORM 传送数据**

client.html

```
username: 
age: 
```



**PHP 接收数据**

server.php

```
$_GET['name'];
$_GET['age'];
```



**POST 传送数据**

client.html

```
username: 
age: 
```



**PHP 接收数据**

server.php

```
$_POST['name'];
$_POST['age']";
```

> $\_GET 和 $_POST 都是数组变量，可以用 var_dump() 查看变量内容。







# N、MySQL

MySQL 是一个关系型数据库管理系统，可以将数据保存到不同的表中。并且是一款开元、免费的数据库管理系统。



## 1. Mysql 控制台命令

### 1.1 进入 MySQL 控制台：

在 Windows 或 Linux 中进入 Mysql 控制台的命令是一样的，如：

```mysql
mysql -h 数据库地址 -u 用户名 - p 密码
mysql -h localhost -u root -p
```

> 在 Windows 环境中可以直接将 `wamp64/bin/ mysql/mysql8.0.18/bin` 加入到环境变量中，就可以直接执行 mysql.exe 命令进入到控制台了。



### 1.2 退出 MySQL 控制台

```mysql
exit
quit
\q
```



### 1.3 常见到的错误提示

```
1. -> 表示当前命令没有命令执行符或者说等待命令执行符来确认
2. '> 表示前面的SQL语句缺少单引号
3. "> 表示前面的SQL语句缺少双引号
```



## 2. MySQL 编码规范

- 关键字与函数名全部大写
- 数据库名称，表名称，字段名称全部小写
- SQL 语句必须以分号结尾（命令执行符确认执行）



## 3. 常用字符集

关于 ASCII、GBK、UTF-8 等一些说明：

- **ASCII** (American Standard Code for Information Interchange，美国标准信息交换代码)是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC 646。

- **GBK编码** 由于ASCII编码不支持中文，因此，当中国人用到计算机时，就需要寻求一种编码方式来支持中文。于是，国人就定义了一套编码规则。加了7000多个汉字进去，当时叫做 GB2312，BIG5 后来又扩展了一下增加了繁体和更多汉字，作为一个扩展，这套字符编码叫做 GBK。双字节编码

- **Unicode 字符集** 是当时 ISO （国际标准化组织） 为了国际化，将世界上所有文字、字符整合起来，形成的这么一套编码集。

- **UTF-8** 是因为 Unicode 传输起来太慢了，所以开发的这么一个编码规则，1~4字节。是目前互联网广泛使用的字符集。类似的还有 UTF-16。



在 Mysql 中 utf8 是 utf8mb3， 不是真正的 utf8，如果需要设置 utf8，选择 utf8mb4



数据库字符集依赖关系：

内容字符集 -> 字段字符集 -> 表字符集 -> 库字符集



## 4. SQL语句

结构化查询语句，主要分4大类：

DDL 数据库定义语言 （CREATE DROP ALTER）

DML 数据库操作语言 （INSERT DELETE UPDATE）

DQL 数据库查询语言 （SELECT WHERE 等）

DCL 数据库控制语言（了解）



数据库操作离不开四个字：增、删、改、查

- 对库的操作、对表的操作、对字段的操作、对内容的操作





## 5. 对数据库的操作 DDL

### 5.1 查询数据库命令

```
SHOW DATABASES;  // 显示数据库
```



系统默认数据库：

- information_schema  

  主要存储系统中的一些数据库对象信息，如用户表信息，列信息，权限信息，字符集信息，分区信息等等。

- mysql

  保存MySQL的权限、参数、对象和状态信息。

- performance_schema

  主要存储数据库服务器性能参数

- sys

  该库所有数据来自performancce_schema。主要是快速了解数据库运行情况。



### 5.2 创建数据库

```
CREATE DATABASE 数据库名;
```

> 不能重复创建同名的数据库名



```
CREATE DATABASE IF NOT EXISTS 数据库名;
```

> 可以用 IF 语句判断，但是不推荐，尽量减少数据库压力



```
CREATE DATABASE 数据库名 CHARSET UTF8MB4;
```

> 创建 utf8mb4 字符集的数据库



### 5.3 删除数据库

MySQL 没有提供修改数据库名的操作，如果需要修改名称，则需要删除数据库，重新创建新的数据库。

```
DROP DATABASE 数据库名;
```

> 无法删除不存在的数据库



### 5.4 选择数据库

```
USE 数据库名;
```



### 5.5 修改数据库默认字符集

查看数据库信息：

```
SHOW CREATE DATABASE 数据库名;
```



修改数据库默认字符集：

```
ALTER DATABASE 数据库名 CHARSET utf8mb4;
```



## 6. 数据库表的操作

### 6.1 显示数据库表

```
SHOW TABLES;
```



### 6.2 创建表

用 CREATE TABLE 命令可以创建表名，可单条创建也可以一次性创建多个表。初始化表的时候，可以定义字段的数据类型以及列的约束条件。

~~~mysql
CREATE TABLE 表名(
	字段1 字段1数据类型 列的约束条件,
	字段2 字段2数据类型 列的约束条件
	...
	字段n 字段n数据类型 列的约束条件);
~~~

> 列的约束条件默认为 null ，可以不填



```
CREATE TABLE user(
	id INT AUTO_INCREMENT PRIMARY KEY,
	username VARCHAR(18) NOT NULL,
	psw CHAR(32), NOT NULL,
	sex TINYINT NOT NULL DEFAULT 0,
	age TINYINT UNSIGNED NOT NULL);
```

>密码字段 psw 使用 CHAR 固定长度，一般用 MD5 32位加密



例：

~~~mysql
CRETAE TABLE t1(t1 INT);  // 创建表 t1 ，字段类型为 INT 型。
CRETAE TABLE t1(t1 INT(5));  // 创建表 t1 ，字段类型为 INT 型，显示宽度为5
~~~



### 6.3 数据类型

数据库类型：

https://www.cnblogs.com/-xlp/p/8617760.html



#### 6.3.1 整型

| MySQL数据类型 | 含义（有符号）                       |
| ------------- | ------------------------------------ |
| tinyint(m)    | 1个字节 范围(-128~127)               |
| smallint(m)   | 2个字节 范围(-32768~32767)           |
| mediumint(m)  | 3个字节 范围(-8388608~8388607)       |
| int(m)        | 4个字节 范围(-2147483648~2147483647) |
| bigint(m)     | 8个字节 范围(+-9.22*10的18次方)      |



**UNSIGNED**

注意类型取值范围，合理配置，默认为有符号，如果字段内容不需要有负数的存在，最好在类型后边加上 UNSIGNED，UNSIGNED 只能用于数值整型如：

~~~mysql
CREATE TABLE t1(age INT UNSIGNED);
~~~

>取值范围如果加了UNSIGNED，则最大值翻倍，如 TINYINT UNSIGNED的取值范围为 (0~256)。





**ZEROFILL**

int(m)里的m是表示SELECT查询结果集中的显示宽度，并不影响实际的取值范围，不会影响到显示的宽度，一般配合 zerofill 填充 0 显示，如：

```mysql
CREATE TABLE t1(id INT(5) ZEROFILL);  // 创建表t1，整型数据，显示范围为5个单位，不够位以0填充。如插入表数据为5，显示的是00005
ALTER TABLE t2 MODIFY 
```

> - ZEROFILL 只能用于数值整型
> - 如果没有 zerofill，INT(5) 与 INT(10) 没有区别
> - 当使用zerofill 时，默认会自动加unsigned（无符号）属性，宽度变为原来的2倍。
> - 如果数据的宽度超出 zerofill 的宽度，则按实际数据的宽度，如：INT(5) ZEROFILL , 数据为 123456, 显示的值还是 123456



#### 6.3.2 **浮点型**(float和double)

| MySQL数据类型 | 含义                                             |
| ------------- | ------------------------------------------------ |
| float(m,d)    | 单精度浮点型  8位精度(4字节)   m总个数，d小数位  |
| double(m,d)   | 双精度浮点型  16位精度(8字节)   m总个数，d小数位 |



创建浮点型字段

~~~mysql
CREATE TABLE t1(field1 float);
CREATE TABLE t1(field2 float(6,3));
~~~

> 设一个字段定义为float(6,3)，如果插入一个数123.45678，实际数据库里存的是123.457，但总个数还以实际为准，即6位。整数部分最大是3位，如果插入数12.123456，存储的是12.1234，如果插入12.12，存储的是12.1200。



#### 6.3.3 **定点数**

浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。 是以字符串形式表示的浮点数。适合用来表示货币等不能出错的小数。长度取决于存储单元的字节数。

| MySQL数据类型 | 含义                                                   |
| ------------- | ------------------------------------------------------ |
| decimal(m,d)  | 以字符串形式表示的浮点数 ， 参数m是总个数，d是小数位。 |



在数据库创建定点数类型的字段

~~~mysql
CREATE TABLE t1(price DECIMAL);  // 在 t1 中创建 price 字段，DECIMAL类型，默认参数为（10, 0）
CREATE TABLE t2(price DECIMAL(7,2))  // 默认最大数值 99999.99 
~~~



精度丢失案例：

https://www.cnblogs.com/ypha/p/14018470.html





#### 6.3.4 字符串

**普通字符串**

| 类型       | 大小                              | 用途             |
| :--------- | :-------------------------------- | :--------------- |
| CHAR(n)    | 0-255 bytes（实际上可以存储更多） | 定长字符串       |
| VARCHAR(n) | 0-65535 bytes                     | 变长字符串       |
| TINYTEXT   | 0-255 bytes                       | 短文本字符串     |
| TEXT       | 0-65 535 bytes                    | 长文本数据       |
| MEDIUMTEXT | 0-16 777 215 bytes                | 中等长度文本数据 |
| LONGTEXT   | 0-4 294 967 295 bytes             | 极大文本数据     |



**CHAR**

- 定长字符串，参数 n 在老版本（5.0 以下 MySQL）中，这个参数是字节数，一个汉字占3个字节。
- 新版本的 MySQL 中， 参数 n 代表字符数，如果参数是 10 的话，代表可以存储10个字符（包括汉字）
- CHAR 可以不加参数，则默认长度为1个字符，占用字节数与字符集有关。
- 如果存储值得长度不足 n 的话，则用空格占位
- 使用查询语句的时候会将 CHAR 类型中数据尾部的空格去掉，所以 CHAR 类型存储的字符串末尾不能有空格。VARCHAR 可以保留空格
- CHAR 类型字符串检索速度要比其他类型快（固定长度的关系）

> CHAR 类型一般用于固定长度的表单提交数据存储 ；例如：身份证号，手机号，电话，密码等



**VARCHAR**

- VARCHAR 后边必须跟参数

- VARCHAR 是变长字符串，存储空间以插入数据的大小来决定。
- VARCHAR 中的参数和 CHAR 一样，也是指定字符数，1个汉字也是1个字符。



**关于 VARCHAR 最多能存多少值**

- mysql 的记录行长度是有限制的，不是无限长的，这个长度是`64K`，即`65535`个字节，对所有的表都是一样的。
- MySQL 对于变长类型的字段会有 1-2 个字节来保存字符长度。
- 当字符数小于等于 255 时，MySQL 只用 1 个字节来记录，因为 2 的 8 次方减 1 只能存到 255。
- 当字符数多余 255 时，就得用 2 个字节来存长度了。
- 在 `utf8mb4` 状态下的 varchar，最大只能到 (65535-2) / 4 = 16383 余 1.
- 在`utf8mb3`状态下的 varchar，最大只能到 (65535 - 2) / 3 = 21844 余 1。
- 在`gbk`状态下的 varchar, 最大只能到 (65535 - 2) / 2 = 32766 余 1



无效，需要重新查看：

https://www.cnblogs.com/mq0036/p/11647530.html

> 那么那余数的那一个字节用来干什么呢？**答案：MySQL记录中，如果用 MyISAM 引擎的话，有任何一个字段允许为空，那么系统会自动从整个记录中保留一个字节来存储null。如果想释放该字节，那么所有字段设置 not null（无论有多少个字段允许为空，只会保留一个字节去存储null）。** 对于InnoDB 则没有区别，可以直接把余数也加上。



**补充字符占位：**

- 字符类型若为gbk，每个字符最多占2个字节
- 字符类型若为utf8，每个字符最多占3个字节
- 字符类型若为utf8mb，每个字符最多占4个字节

> 但是，如果超过 5000 以上的字符我们就会用 text 而不会去用 varchar 了。



**最后来看个练习题：**

https://ruby-china.org/topics/24920

```
CREATE DATABASE demo CHARSET utf8mb4;
USE demo;
CREATE TABLE t1(
	name_chn VARCHAR(8))
	name_en VARCHAR(8));
INSERT INTO t1 value('GBK中文字符集', 'abcde');
```

英文和中文所占的字节数？

> 英文占 5+1 = 6 Bytes
>
> 中文占 3 + 5*4 = 23 Bytes



可以通过以下代码验证：

```
select length(name_chn) from t1;
select length(name_en) from t1;
```



对于 UTF8MB4 最好设置不超过 varchar(60); 避免超过255个字节。



**CHAR 和 VARCHAR 到底用哪个？**

对于MyISAM表，尽量使用Char，对于那些经常需要修改而容易形成碎片的myisam和isam数据表就更是如此，它的缺点就是占用磁盘空间；

对于InnoDB表，因为它的数据行内部存储格式对固定长度的数据行和可变长度的数据行不加区分（所有数据行共用一个表头部分，这个表头部分存放着指向各有关数据列的指针），所以使用char类型不见得会比使用varchar类型好。事实上，因为char类型通常要比varchar类型占用更多的空间， 所以从减少空间占用量和减少磁盘i/o的角度，使用varchar类型反而更有利。



- 在确定字段为短小且定长的时候，用char会好一些
- 在某字段需要频繁改写的时候，用char会好一些（因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。
- 设计varchar()值的时候，不要一股脑的都用varchar(255)：mysql会把表信息放到内存中（查询第一次后，就缓存住 了，linux下很明显，但windows下似乎没有，不知道为啥），这时内存的申请是按照固定长度来的，如果varchar很大就会有问题。
- 关于varchar(255)和varchar(256) ：根据mysql官方文档，varchar(255)需要一个字节记录字段的长度 256以上需要两个字节记录长度。设置长度超过256会有点浪费。
- 因为在业务中使用innoDB多一些，所以尽量还是用varchar好一些



效率来说基本是char>varchar>text，但是如果使用的是Innodb引擎的话，推荐使用varchar代替char。



**VARCHAR 和 TEXT 的区别：** 

- varchar可指定参数n，text不能指定，
- 内部存储varchar是存入的实际字符数+1个字节（n<=255）或2个字节(n>255)，text是实际字符数+2个字节。 

- text类型不能有默认值。

- varchar可直接创建索引，text创建索引要指定前多少个字符。
- varchar查询速度快于text，在都创建索引的情况下，text的索引似乎不起作用。



**二进制字符串**

| 类型       | 大小                  | 用途                            |
| :--------- | :-------------------- | :------------------------------ |
| TINYBLOB   | 0-255 bytes           | 不超过 255 个字符的二进制字符串 |
| BLOB       | 0-65 535 bytes        | 二进制形式的长文本数据          |
| MEDIUMBLOB | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据    |
| LONGBLOB   | 0-4 294 967 295 bytes | 二进制形式的极大文本数据        |



二进制字符串

- 将字符串以二进制存储在文件中
- 可以有参数，如 BLOG(800)
- 可读取字符串，在 PHP 中还原文件在硬盘中，如 BASE64 图片类型文件



**枚举类型字符串**

一般很少用到枚举类型，一般选择，我们只给数字就可以做判断了。比如 0,1,2。要比字符串判断简单很多。在数据库中能存整型存整型，不能再考虑字符串。减少 MySQL 服务器压力。

| 类型                          | 大小                | 用途                                   |
| :---------------------------- | :------------------ | :------------------------------------- |
| ENUM('value1', 'value2', ...) | 1或2个字节          | 枚举：可赋予某个枚举成员，65535 个成员 |
| SET('value1', 'value2', ...)  | 1、2、3、4或8个字节 | 集合：可赋予多个集合成员，64个成员     |



1. ENUM 枚举类型

   类似于选项，定义的时候可以给定可选值，插入数据库的时候只能选择当初定义的值，如果插入了其他值会报错。最多可以定义 65535 个成员（选项）如：

   ~~~mysql
   CREATE TABLE t1(sex ENUM('Male', 'Female'));
   INSERT INTO t1(sex) VALUES('Male');
   ~~~

   

2. SET 集合类型

   类似于多选，比如说爱好（运动、看书...）可包括最多 64 个成员，成员数不同，存储所占字节也不同。 如：

   ~~~mysql
   CREATE TABLE t1(sex SET('Male', 'Female'));  
   INSERT INTO t1(sex) VALUES('Male', 'Female');  // 插入数据的时候，可以同时插入 Male 和 Female
   ~~~

   

可以利用 Find_in_set 函数对 Set 进行查询

~~~mysql
SELECT * FROM t1 where find_in_set('Male', 'sex');
~~~



#### 6.3.5 日期时间类型

关于日期类型的字段，一般不会使用，而是使用后端程序如 PHP，来获取时间戳来转换时间。

| MySQL数据类型 | 含义                                                      |
| ------------- | --------------------------------------------------------- |
| date          | 日期 '2008-12-2'，范围：1000-01-01 ~ 9999-12-31           |
| time          | 时间 '12:25:36'，范围：-839:59:59 ~ 839:59:59             |
| datetime      | 日期时间 '2008-12-2 22:06:44'，最大值 9999-12-31 23:59:59 |
| timestamp     | 自动存储记录修改时间 19700101000000 到 2037年的某个时刻   |
| year          | 'YYYY' 格式的年份值，1901-2155                            |

> 若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。



创建日期类型的字段

~~~mysql
CREATE TABLE t1(time datetime);
~~~





#### 6.3.6 数据类型的属性（列的约束）

| MySQL关键字        | 含义                     |
| ------------------ | ------------------------ |
| NULL               | 数据列可包含NULL值       |
| NOT NULL           | 数据列不允许包含NULL值   |
| DEFAULT            | 默认值                   |
| PRIMARY KEY        | 主键                     |
| AUTO_INCREMENT     | 自动递增，适用于整数类型 |
| UNSIGNED           | 无符号                   |
| CHARACTER SET name | 指定一个字符集           |

 

**NULL**

数据中可以包含空值，默认为 NULL



**NOT NULL**

插入数据时，该字段必须有值

```mysql
CREATE TABLE t1 MODIFY score INT NOT NULL;
ALTER TABLE t1 MODIFY score INT NOT NULL;
```



**DEFAULT**

当数据被写入数据库中，如果插入的数据中，没有该字段的数据，用 DEFAULT 替换。

```mysql
CREATE TABLE t1(score INT DEFAULT 0);
ALERT TABLE t1 MODIFY score INT DEFAULT 0;
```



**AUTO_INCREMENT - 自增属性**

- 只能应用于整数类型，一般从1开始，每行自增1
- 一个表中最多只能有一个 AUTO_INCREMENT 列
- 对于 AUTO_INCREMENT 应定义为 NOT NULL 并且定义为 PRIMARY KEY 或 UNIQUE 键



```
CREATE TABLE t1(id INT AUTO_INCREMENT NOT NULL PRIMARY KEY);
CREATE TABLE t1(id INT AUTO_INCREMENT NOT NULL, PRIMARY KEY(id)); 
```



修改自增

```
ALERT TABLE t1 MODIFY id int AUTO_INCREMENT;  // 修改自增
```



**PRIMARY KEY - 主键**

主键可以唯一标识某条记录的一个字段或多个字段，作用是便于查找或删除某条记录，可以根据唯一值查找多个字段作为主键（如姓名+地址），但不推荐用多个字段作为主键。一般一个表中只有一个字段做为主键。



- 主键最好是正整数， NOT NULL, AUTO_INCREMENT
- 主键最好不要设置在某个与实际信息相关的字段上，一般主键为 id  // 为什么？
- 一个表只能有一个主键，最好是单一字段  // 复合主键？
- 根据主键的值进行查询速度更快，是因为创建了索引
- 设置主键后，插入数据可以不用写主键名（需要设置 AUTO_INCREMENT 属性后）
- 主键不一定自增，但自增一定是需要配合主键使用。



创建主键为id的表单

```
CREATE TABLE t1(id INT, score INT, PRIMARY KEY(id));
CREATE TABLE t1(id INT PRIMARY KEY, score INT);
```



创建多个主键的表

```
CREATE TABLE t1(id INT, score INT, PRIMARY KEY(id, score));
```



添加主键（创建时没有添加的话）

```
ALTER TABLE t1 ADD PRIMARY KEY(id);
```



删除主键

```
ALTER TABLE t1 DROP PRIMARY KEY;
```



如果字段中有 AUTO_INCREMENT 属性的话，必须先删除该属性再删除主键

```
ALTER TABLE t1 MODIFY id INT;
```



**CHARSET** 

```
CREATE TABLE user(id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
	name VARCHAR(30) NOT NULL)
	ENGINE=MYSISAM DEFAULT CHARSET=UTF8MB4;
```

> 使用 DEFAULT CHARSET 可以设置默认字符集



**ENGINE**

- MYSISAM
- INNODB

```
CREATE TABLE user(id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
	name VARCHAR(30) NOT NULL) ENGINE=MYSIAM DEFAULT CHARSET=UTF8MB4;
```



### 6.4 查看表

1. 查看表数据结构

```
DESC 表名;
```



2. 查询建表语句

```
SHOW CREATE TABLE 表名\G;
```

> \G 是以格式化显示



### 6.5 删除表

```
DROP TABLE 表名[,表名2,表名3];
```



### 6.6 修改表

```
ALTER TABLE 原表名 RENAME 新表名;  // 修改表名
```



### 6.7 复制表

```
CREATE TABLE 空表 SELECT * FROM 源表;
```

> 用此方法复制表，无法复制主键和自增属性，需要重新添加



## 7. 对数据库字段的操作

### 7.1 添加字段

```
ALTER TABLE 表名 ADD [COLUMN] 字段名 数据类型 [属性][添加位置];
ALTER TABLE users ADD COLUMN address VARCHAR(60) NOT NULL;
```

> 如果不设置位置，默认添加到表的最后



```
ALTER TABLE users ADD address VARCHAR(60) NOT NULL FIRST;  // 在第一个字段前添加新的字段
ALTER TABLE users ADD address VARCHAR(60) NOT NULL;  // 在最后一个字段后添加新的字段
ALTER TABLE users ADD address VARCHAR(60) NOT NULL AFTER psw; // 在 psw 字段后添加新的字段
```

> 注意，MySQL 中没有 BEFORE 的用法，第一列用 FIRST，非第一列用 AFTER



### 7.2 修改字段

修改字段数据类型、属性

```
ALTER TABLE 表名 MODIFY [COLUMN] 字段名 新数据类型 [新属性] [新的位置];
ALTER TABLE users MODIFY COLUMN name VARCHAR(40) NOT NULL;
```



修改字段名

```
ALTER TABLE 表名 CHANGE [COLUMN] 原字段名 新字段名 新字段名的数据类型 [新字段名的属性] [新字段名的位置];
ALTER TABLE t10 CHANGE COLUMN address13 address99 varchar(50) NOT NULL AFTER pass;
```

> - 改名不能只添加新字段名，还需要添加新字段名的数据类型
> - MODIFY 和 CHANGE 都可以修字段的数据类型、位置



### 7.3 删除字段

```
ALTER TABLE 表名 DROP [COLUMN] 字段名[, DROP 字段名2, DROP 字段名3];
ALTER TABLE users DROP address;
```



### 7.4 查询字段

```
DESC 表名;
```



## 8. 数据的操作

### 8.1 插入记录

#### 8.1.1 插入单条记录

```
INSERT INTO 表名(字段1 [, 字段2, 字段3, 字段4...]) VALUES(对应数值1 [, 对应数值2, 对应数值3...]);
INSERT users(id, username, password) VALUES(10,'power',123456);
```



也可以不用指定字段名，但 VALUES 应该与定义字段排序一致，如：

```
INSERT INTO 表名 VALUES(对应数值1 [, 对应数值2, 对应数值3...]);
INSERT users VALUES(1,'power',123456);
```

> 插入表数据的时候，注意字符串需要用单引号或双引号，数字类型可以有引号也可以没有。



不可以忽略字段，如果是自增主键字段，可以使用 null 占位，如：

```
INSERT INTO users VALUES(NULL, 'user1', '77889'); 
```



#### 8.1.2 插入多条记录

```
INSERT users(id, username, password) VALUES
(1,'user1',123456),
(2,'user1',123456)
(3,'user1',123456)
(4,'user1',123456);
```



如果字段名和 MySQL 关键字冲突，可以使用 `` 反引号包括字段名，如：

```
INSERT INTO users(`username`) VALUES('jojo');
```



#### 8.1.3 查看警告

当给表中插入部分字段时，如果非空数据，会提示警告没有设置默认值，查看警告命令如下：

```
SHOW WARNINGS;
```





### 8.2 查询记录

##### 8.2.1 查询所有记录

```
SELECT * FROM 表名;
SELECT * FROM users;
```

> `*` 代表所有记录



##### 8.2.2 查询字段记录

```
SELECT 字段名1 [, 字段名2...] FROM 表名;
SELECT id, age FROM t1;
```

> 查询显示出来的字段顺序，是根据 SELECT 后边输入的字段顺序来显示的。



##### 8.2.3 条件查询 WHERE

利用 WHERE 做条件查询，通过 MySQL 中的运算符加以条件，如：

```
SELECT * FROM users WHERE id=7;
```



##### 8.2.4 MySQL 运算符

算数运算符

```
+
-
*
/ 或 DIV
% 或 MOD
```



比较运算符：

```
=
!= 或 <>
<=> // 判断是否为 null，如 null <=> null， 返回 1
<
>
<=
>=
BETWEEN  // BETWEEN 10 AND 20 (存在于指定范围，包含10和20)
IN  // 存在于指定集合, 如：IN(1,3,4,5,6)
IS NULL  // 空
IS NOT NULL  // 非空
LIKE  // 通配符匹配
REGEXP  // 正则匹配
```

> 其中 = 在 WHERE 中使用，不是赋值运算符，多个条件之间可以使用 OR AND 等逻辑运算符。

```
SELECT * FROM t1 WHERE id>5;
SELECT * FROM t1 WHERE id IN (1,3,4,5,6);
SELECT * FROM t1 WHERE id NOT IN(2,4,6,8,10);
SELECT * FROM t1 WHERE id BETWEEN 10 AND 20;
SELECT * FROM t1 WHERE useranme REGEXP '^g$';  // 正则匹配 usersname 字段中以g结尾的字段记录
SELECT * FROM t1 WHERE username like '%hei';  // %代表通配符，可匹配任意字符串
SELECT * FROM t1 WHERE username like '_e%';  // 可匹配第二个字母为e的字符串，其中_匹配任意单一字符。
```



逻辑运算符

```
! 或 NOT
&& 或 AND
|| 或 OR
XOR
```

```
SELECT * FROM t1 where id=1 OR id=3;
```



位运算符

```
&
|
^
~
<<
>>
```



##### 8.2.5 统计查询

利用 COUNT 关键字可以查询表中有多少条记录，如：

```
SELECT COUNT(id) FROM t1;
SELECT COUNT(*) FROM t1;
```

> 如果查询的是主键，可以用 * 来代替



##### 8.2.6 去重查询

利用 DISTINCT 查询不重复的记录，在字段中去除有重复 VALUE 的结果病返回查询结果，一般只选择一个字段进行查询。 

```
SELECT DISTINCT 字段1[, 字段2] FROM 表名;
```

> 多字段查询，字段1值相同，字段2值不同，不会被认为是重复的记录。



##### 8.2.7 排序和限制

利用 ORDER BY 做排序查询

```
SELECT * FROM 表名[WHERE 条件] ORDER BY 字段1 [DESC|ASC];
SELECT * FROM t1 ORDER BY salary DESC;
```



多个字段条件排序

```
SELECT * FROM 表名[WHERE 条件] ORDER BY 字段1 [DESC|ASC] [,字段2 [DESC|ASC]...];
```

> 如果 字段1 排序中遇到 VALUE 值相同的元素，会根据 字段2中的排序进行排序。



##### 8.2.8 LIMIT 限制

用 LIMIT 限制显示查询结果的数量

```
SELECT * FROM t1 ORDER BY salary DESC LIMIT 1;
```

> 只显示1条查询结果



LIMIT(从第几行开始, 取几条记录)

```
LIMIT(0, 1)  // 从第0条开始，取1条记录
LIMIT(5, 10)  // 从第5条开始，取20条记录
```



### 8.3 更新记录

```
UPDATE 表名 SET 字段1 = 值1 [, 字段2 = 值2, 字段3 = 值3 ...] [WHERE 条件];
UPDATE t1 SET age = 60 WHERE id=6;
```

> 如果不加 WHERE 条件，会修改所有表内字段1数据的值



更新多个表的记录

```
UPDATE 表1[,表2, 表3...] SET 表1.字段1=值 [表2.字段1=值] [WHERE 条件];
```



### 8.4 删除记录

```
DELETE FROM 表名 [WHERE 条件];
DELETE FROM t1 WHERE id=1;
```



删除多个表单

```
DELETE 表1 [, 表2, 表3...] FROM 表1 [, 表2, 表3...] [WHERE 条件];
```



### 8.5 查询进阶（多表查询）

#### 8.5.1 别名

可以给字段起别名，当有的字段太长，可以给字段起别名，可以用 as 关键字，也可以省略。

```
SELECT employee.id id1 from t1;
SELECT * FROM employee.id, employee.username, employee.password as psw FROM user WHERE id>6;
```



给表起别名

```
SELECT * FROM employee e WHERE e.id=6;
SELECT a.id, a.username, a.password FROM users as a;
```



#### 8.5.2 聚合查询

```
SELECT [字段1, 字段2, 字段3...] 聚合函数 FROM 表名 [WHERE 条件] [GROUP BY 字段1, 字段2, 字段3...[ WITH ROLLUP]] [HAVING 条件];
```



##### 1. 求和 SUM

```
SLEECT SUM(salary) FROM t1;
```



##### 2. MAX, MIN

```
SELECT MAX(salary) FROM t1;
SELECT MIN(salary) FROM t1;
```



##### 3. 分组查询

一般分组都是用来做统计用的

```
SELECT department, SUM(salary) FROM t1 GROUP BY department;
```

> 按部门统计，相同部门的员工工资总和



##### 4. 对分组查询结果再求和

```
SELECT department SUM(salary) FROM t1 GROUP BY department with ROLLUP;
```

> 最后总计不知道属于哪个 department，显示 null。如要总计，不建议填写字段名



##### 5. 对分类结果再进行过滤

```
SELECT department， SUM(salary) FROM t1 GROUP BY department HAVING SUM(salary)>600;
```

> 过滤出部门工资总数超过600的部门



**HAVING 和 WHERE 的区别：**

- HAVING 是对聚合后的结果进行过滤
- WHERE 是对聚合前的结果进行过滤

> 应尽量使用 WHERE 先过滤



##### 6. 对字段进行多种查询

```
SELECT SUM(salary)， MAX(salary), MIN(salary), COUNT(*) FROM t1;
```



### 8.6 表连接

将多个表中的字段连接起来形成一个新表进行输出，但不对数据库进行实际操作，只是根据结果运算出来的一个新的表。表连接有内连接和外连接：

- 内连接： 选取两张表相互匹配的记录
- 外连接：选取两张表相互匹配的记录并选出不匹配的记录



#### 8.6.1 内连接

```
SELECT * FROM employee, record WHERE employee.id = record.id;
```

> 其中 `*` 可以写具体字段名，如 employee.name, record.record
>
> 一定要有一个匹配条件，比如两个表的 id 相匹配



#### 8.6.2 外连接

- 左连接
- 右连接

```
SELECT * FROM employee LEFT JOIN ON record ON employee.id = record.id;
```

左表信息都列出来，右表在右侧，仅显示匹配部分，后显示没有匹配的部分，右连接与左连接相反



### 8.7 子查询

一个查询需要另一个查询结果参与的时候



关键字：

```
IN
NOT IN  // 不在结果当中
=  // 如果查询结果唯一，可以用 = 代替 IN
!=
EXISTS  // 查询结果是否存在，返回 TRUE 或 FALSE
NOT EXISTS
```



```
SELECT * FROM employee WHERE id in (SELECT eid FROM employee_late)
```

> 在 employee 表单中，子段 id 存在于 employee_late 表中 eid 字段的查询结果



综合用法

```
SELECT * FROM employee WHERE id IN(SELECT eid FROM employee_late GROUP BY eid HAVING COUNT(*)>1);
SELECT * FROM employee WHERE EXISTS(SELECT * FROM employee_late WHERE employee_late.id = employee.eid);
```



### 8.8 记录联合

将两个或多个表按照一定条件查询的结果合并到一起显示

- UNION
- UNION ALL



```
SELECT * FROM employee UNION SELECT * FROM employee_late;
```

> 需要列数相同（字段数量）



UNION 具有去重作用，UNION ALL 会显示所有结果。



## 9. 数据库编码

如果数据库中有中文，则需要使用中文编码，如 GBK, UTF8（汉字占3字节）, UTF8MB4（汉字占4字节）



创建 UTF8MB4 编码的表单

```
CREATE TABLE t1(name CHAR(10)) DEFAULT CHARSET=UTF8MB4;
```



### 9.1 MYSQL 字符集和校对规则

**MySQL 支持字符集**

可以用下边任意一条语句查看当前版本的 MySQL 所支持的字符集：

```
SHOW CHARACTER SET;  
SELECT * FROM information_schema.character_sets;
```



**MySQL 校对规则**

字符集用来定义 MySQL 存储字符串的方式，校对规则用于定义字符串比较方式。如：

```
utf8mb4_general_ci
gbk_chinese_ci
```



- GBK - 字符集
- chinese - 语言
- ci - 规则



规则中，ci 代表忽略大小写。 cs 大小写敏感。 bin 二进制比较（比如 'a' 与 'A'）的二进制就不同。



字符集可以选择多个校对规则，可以使用下边的命令查看字符集校对规则：

```
SHOW COLLATION LIKE 'gb2312%';
```



### 9.2 字符集和校对规则优先级

字符集和校对规则有4个级别默认设置：

- 服务器级
- 数据库级
- 表
- 字段



优先级：

字段 > 表 > 数据级 > 服务器级

> 当创建时指定了字符集和校对规则时，则用指定的，如果没有则默认为上一级的字符集和校对规则。



#### 9.2.1 服务器级别

设置字符集和校对规则在 MySQL 配置文件 my.ini 文件当中：

```
[mysqld]
character-set-server=utf8  // 下划线或横线
```



或者在启动项中指定（Linux 命令）

```
mysqld --character-set-server=utf8
```



#### 9.2.2 数据库级别

数据库级别字符集和校对规则可以在创建数据库时指定，也可以用 ALTER DATABASE 命令修改（但是数据库中不能有内容）如果已经有数据，则需要导出数据库，修改字符集后再导入。



创建数据库指定默认字符集和校对规则

```
CREATE DATABASE db_name DEFAULT CHARACTER SET charset_name DEFAULT COLLATE collation_name;
ALTER DATABASE db_name DEFAULT CHARACTER SET charset_name DEFAULT COLLATE collation_name;  // 修改默认字符集和校对规则（无内容数据库）
```



默认规则：

- 指定了字符集和校对规则 - 使用指定的字符集和校对规则
- 指定了字符集没有指定校对规则 - 使用字符集的默认校对规则
- 指定了校对规则没有指定字符集 - 使用校对规则对应字符集
- 都咩有指定 - 使用上一级别默认字符集和校对规则



查看当前数据库使用的字符集和校对规则：

```
SHOW VARIABLES LIKE 'character-set-database';
SHOW VARIABLES LIKE 'collation_database';
```



#### 9.2.3 表级别

```
CREATE TABLE tbl_name (column_list) [DEFAULT CHARACTER SET charset_name] [ COLLATE collation_name];
```



查看表信息

```
SHOW CREATE TABLE tbl_name\G;
```



#### 9.2.4 字段级别

一般不会给字段单独设置字符集和校对规则，字段级别一般都是默认为表的字符集和校对规则



## 11. 常用函数

```
CONCAT(S1, S2, ...)  // 连接字符串
INSERT(str, x, y, instr) // 将 str 字符串从 x 位，y个长度替换位 instr
LOW(str) / UPPER(str)  // 转换大小写
LEFT(str, x) / RIGHT(str, x)  // 返回左，右 x 个字符
LPAD(str, n, pad) / RPAD(str, n, pad)  // 填充
TRIM(str) / LTRIM(str) / RTRIM(str)  // 去空格
REPEAT(str, x)  // 返回 str 重复 x 次的结果
REPLACE(str, a, b)  // 用 b 替换 a
STRCMP(s1, s2)   // 比较
SUBSTRING(sgr, x, y)  // 截取 x 位置， y 个长度
LENGTH(str)  // 返回字符串长度
```



数值函数

```
ABS(x)  // x 的绝对值
CELL(x)  // 向上取整
FLOOR(x)  // 向下取整
MOD(x, y)  // x/y 的余数
RAND()  // 0~1 随机数
ROUND(x, y)  // 将 x 四舍五入，保留 y 位小数
TRUNCATE(x, y)  // 返回数字 x 截断为 y 位小数（不四舍五入，直接去掉小数位）
```



日期函数

```
CURDATE()
CURTIME()
NOW()
UNIX_TIMESTAMP(date)
WEEK(date)
YEAR(date)
HOUR(time)
MINUTE(time)
MONTHNAME(date)
DATE_FORMAT(date, fmt)
DATE_ADD(add, INTERVAL, expr type)
DATEDIFF(expr1, expr2)
```



流程函数

```
IF(value, t, f)
IFNULL(value1, value2)
CASE WHEN [value1] THEN [result1] .. ELSE [DEFAULT] END;
CASE [EXPR] WHEN [VALUE1] THEN [RESULT] ... ELSE [DEFAULT] END;
```



其他函数

```
DATABASE()  // 当前数据库名
VERSION()  // 当前数据库版本
USER()  // 当前用户
INET_ATON(IP)  // 返回 IP 代表的数字
INET_NTOA(NUM)  // 返回 NUM 代表的 IP
PASSWORD(STR)  // 加密
MD5(STR)  // MD5 加密
```



## 12. phpmyadmin 的使用

- 存储引擎
- 用户权限
- 导出导入



# PHP 扩展 MySQLi

## 1. 安装 MySQLi

```
phpinfo(); // 查看是否安装 MySQLi 扩展
```



如果没有 mysqli 扩展，需要到 php.ini 中查看是否开启了扩展：

```
extension=mysqli
```



如果还没有 mysqli 扩展，则需要下载 php_mysqli.dll 文件到 php/php7.4.0/ext/ 文件夹中，然后在 php.ini 中添加支持扩展语句。重启服务器即可。



## 2. 利用 PHP 与 MySQL 交互

- 连接数据库
- 选择数据库
- 设置字符集
- 准备操作的 SQL 语句
- 发送 SQL 语句
- 判断并且处理结果
- 关闭数据库



## 3. 连接数据库

### 3.1 mysqli_connect()

```
$link = mysqli_connect(host:'localhost', user:'root', password:'', database:'ewcms', port:'3306');
```

> 返回一个连接数据库的对象，之后可以对这个对象进行 MySQL 的操作



也可以不用加对象键名，如：

```
$link = mysqli_connect('localhost', 'root', '', 'ewcms', '3306');
```

> 端口默认 3306，如果没有改端口，可以不用写



如果连接数据库失败，会返回一个 false，为了避免报错，需要 @ 符屏蔽错误，并且对失败结果进行判断

```
$link = mysqli_connect(host:'localhost', user:'root', password:'', database:'ew_cms', port:'3306') or die('连接或选择数据库失败');
```



### 3.2 mysqli_select_db()

如果在 mysqli_connect 中没有使用选择数据库参数 database 的话，可以使用：

```
 mysqli_select_db($link, $db_name);
```

> 或者使用该函数用来切换数据库



### 3.3 mysql_connect_errno()

当数据库连接失败的时候，可以使用 mysql_connect_errno() 来查看错误代码。正常连接代码为0，该函数会返回一个 INT 类型的变量。

```
vardump(mysqli_connect_errno());
```



### 3.4 mysql_connect_error()

如果想知道是什么具体错误的话，可以使用 mysql_connect_error() 来显示具体错误信息，该函数当数据库连接失败的时候，会返回一个字符串。

```
if(mysqli_connect_errno()){
	exit(mysqli_connect_error());
}
```



## 4. 设置字符集

```
$r = mysqli_set_charset($link, charset:'utf8mb4');
```

> 如果成功返回true，失败返回 null



## 5. 准备操作的SQL

```
$sql = "SELECT * FROM ew_user";
```



## 6. 发送 SQL 语句到 MySQL

```
$result = mysqli_query($link, $sql);  // 将返回的结果赋值给$result
```

> 当 SQL 语句是查询语句时，成功返回则一个OBJ对象，如果失败返回 false，在返回对象中有个属性叫做 num_rows => xxx ，代表着有几条数据执行成功。



```
mysqli_real_query($link, $sql); // 不会返回结果集，会返回布尔值代表命令是否执行成功。
```

> 执行 Query 后，服务器会产生结果集，虽然 mysqli_real_query() 没有拿到返回的结果集，但是 $result 还是存在于 MySQL 服务器上，可以用 mysqli_store_result($link) 取回结果集。



## 7. 判断并处理结果

```
mysqli_num_rows($result)  // 取得结果集中行的数目。仅对 SELECT 有效。其他操作用 mysqli_afftected_rows()
mysqli_affected_rows($result)  // 返回前一次 MySQL 操作所影响的记录行数。
mysqli_insert_id($link)  // 返回最后一次操作自动生成并使用的id（添加数据时）
mysqli_fetch_row($result)  // 以索引数组的方式获取一条记录，并将指针移动到下一条数据，直到最后一条数据输出完毕，返回 null
mysqli_fetch_assoc($result)  // 以关联数组的方式获取一条数据，并将指针移动到下一条数据，直到最后一条数据输出完毕，返回 null
mysqli_fetch_array($result, [$array_type]);  // 以索引或关联方式获取一条数据，MYSQL_ASSOC, MYSQL_NUM, MYSQL_BOTH(默认)
mysqli_fetech_all($result, [$array_type]);  // 根据array_type参数决定索引或关联方式获取所有数据
mysql_fetch_field(data,field_offset) // 函数从结果集中取得列信息并作为对象返回。
mysqli_free_result($result)  // 释放结果集内存
mysqli_errno($link)  // 查看 SQL 错误代码
mysqli_error($link)  // 查看 SQL 错误信息
```



```
mysqli_multi_query($link, $query1; $query2);  // 一次性执行多条 SQL 语句，SQL 命令用 ; 隔开
```

> 返回布尔型，但需要注意，结果只对第一条命令负责，后边命令没有执行成功的话，还是会返回 True



如果想进行判断，则需要进行遍历，搭配函数

```
mysqli_more_result()
mysqli_next_result()
```



### 7.1 查询数据

```
if($result && mysqli_num_rows($result) > 0 {
	while($row=mysqli_fetch_assoc($result)){
	echo '<tr>';
	echo '<td>'.$row['id'].'</td>';
	echo '<td>'.$row['username'].'</td>';
	echo '<td>'.$row['name'].'</td>';
	echo '<td>'.$row['sec'].'</td>';
	echo '<td>'.$row['age'].'</td>';
	echo '<td>'.$row['email'].'</td>';
	echo '<td><a href="">删除</a><a href="">修改</a></td>';
	echo '</tr>';
	}
})
```



### 7.2 添加数据

```
$username = '虎子';
$pwd = '123';
$name = '张三';
$sex = 0;
$age = 23;
$email = '333555@qq.com';

$sql = "INSERT INTO ew_user(username, pwd, name, sex, age, email) VALUES('{$username}', '{$pwd}', '{$name}', {$sex}, {age}, '{$email}' )"
```

> 字符串 VALUES 中需要加引号，由于是变量，所以使用 {} ，只有双引号才可以解析字符串中的 {} 变量。其中 $sex 和 $age 属于整型，不用加引号。



发送 sql 语句

```
$result = mysqli_query($link, $sql);
```

> 如果是 INSERT INTO 语句，返回值为 true 或 false，



判断并处理结果

如果想知道有几条记录被插入，需要用到函数 mysqli_affected_rows($link)，如：

```
$affected = mysqli_affected_rows($link);
```



还可以用 mysqli_insert_id($link) 获取新插入数据的 id，如：

```
$id = mysqli_insert_id($link);
```



当 SQL 语句有数据被添加时，返回新数据的 id

```
if($result && mysqli_affected_rows($link)>0){
	echo mysqli_insert_id($link);
}
```



### 7.3 修改数据

```
$username = '虎子';
$pwd = '123';
$name = '张三';
$email = '333555@qq.com';
$sql = "UPDATE ew_user SET username='{$username}', password='{$pwd}', name='{$name}', email='{$email}' WHERE id=4";
```



发送 sql 语句

```
$result = mysqli_query($link, $sql);
```

> 返回值为 true 或 false



判断结果

```
if($result && mysqli_affected_rows($link)>0){
	echo '修改成功';
}else
	echo '修改失败';
}
```



### 7.4 删除数据

```
$sql = "DELETE FROM ew_user WHERE id=10";
```

> 返回 ture 或 false



```
$result = mysqli_query($link, $sql);
if($result && mysqli_afftect_rows($link)>0){
	echo '<script>alert(\'删除成功\');location="./mysqli_func.php"</script>';
}else{
	echo '删除失败';
}
```



## 8. 关闭数据库

```
mysqli_close($link);
```



## 9. 用 `$_GET` 或 `$_POST` 传参

```
// HTML $_GET 传参
echo '<td><a href="./delete.php?id='.$row['id'].'">删除</a></td>';
```



```
// PHP $_GET 接受参数
$sql = "DELETE FROM ew_user WHERE id={$_GET['id']}";
```



## 封装 MySQL 函数

因为每次做处理都要执行连接数据库、设置字符集、发送 SQL 语句，关闭数据库等类似的操作，所以我们可以将这一系列操作封装成一个函数。





## 安全处理 MySQL

### 实体

转义 SQL 语句中的特殊符号

```
$str = mysqli_real_escape_string($link, $escapestr);
```



### 预处理

预处理语句对于防止 MySQL 注入是非常有用的。预处理语句用于执行多个相同的 SQL 语句，并且执行效率更高。预处理语句的工作原理如下：

- 预处理：创建 SQL 语句模板并发送到数据库。预留的值使用参数 "?" 标记 。
- 数据库解析，编译，对SQL语句模板执行查询优化，并存储结果不输出。
- 执行：最后，将应用绑定的值传递给参数（"?" 标记），数据库执行语句。应用可以多次执行语句，如果参数的值不一样。



相比于直接执行SQL语句，预处理语句有两个主要优点：

- 预处理语句大大减少了分析时间，只做了一次查询（虽然语句多次执行）。
- 绑定参数减少了服务器带宽，你只需要发送查询的参数，而不是整个语句。
- 预处理语句针对SQL注入是非常有用的，因为参数值发送后使用不同的协议，保证了数据的合法性。



#### 1 设计SQL语句模板

```
$query = 'INSERT INTO t1(id, username) VALUES(?,?)';  // ? 是占位符，用来传递变量
```



#### 2 创建预处理对象

```
$obj = mysqli_prepare($link, $query);
```



#### 3 绑定参数

```
mysqli_stmt_bind_param($stmt, types:'ii', &var1:$user1, &var2:$password);
```



```
$val1 = 18;
$val2 = 'zhangsan'
mysqli_stmt_bind_param($obj, 'is', $val1, $val2);
```

- $obj 为预处理对象
- is 代表着变量类型，由变量首字母表示，如 INT, STRING 等等
- $val1, $val2 代表着需要传递的变量



#### 4 执行预处理SQL语句

```
mysqli_stmt_execute($obj);
```

- 当 Query 是 SELECT 语句时，返回结果集



#### 5 查看报错信息

```
mysqli_stmt_errno()
mysqli_stmt_error()
```



#### 6 获得字段相关信息

```
mysqli_stmt_insesrt_id($stmt); // 返回新插入数据的id（针对 INSERT INTO 使用）
mysqli_stmt_affected_rows($stmt)  // 返回影响行（对 DELETE, MODIFY 使用）
```



```
$resutl = mysqli_stmt_get_result()  // 获取 SELECT 查询信息结果集

$result = mysqli_stmt_result_metadata($stmt);
mysqli_fetch_field($result);
mysqli_fetech_fields($result);  // 获取所有
```



7 取回结果集行数

```
mysqli_stmt_store_result($stmt);
var_dump(mysqli_stmt_num_rows($stmt));
```



#### 8. 关闭预处理语句

```
mysqli_stmt_free_result($stmt);  // 释放结果集所占内存
mysqli_stmt_close($stmt);  // 关闭预处理对象
```



