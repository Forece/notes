# 微信小程序介绍

微信小程序，简称小程序，英文名 Mini Program，是一种不需要下载安装即可使用的应用。



微信小程序优势：

1. 微信有海量用户，而且粘性很高，在微信里开发产品更容易触达用户
2. 推广app或公众号的成本太高
3. 开发适配成本低
4. 容易小规模试错，然后快速迭代
5. 跨平台



## 1. 微信小程序历史

- 2016年1月11日，微信之父张小龙时隔多年的公开亮相，解读了微信的四大价值观。张小龙指出，越来越多产品通过公众号来做，因为这里开发、获取用户和传播成本更低。拆分出来的服务号并没有提供更好的服务，所以微信内部正在研究新的形态，叫「微信小程序」需要注意的是，之前是叫做应用号
- 2016年9月21日，微信小程序正式开启内测。在微信生态下，触手可及、用完即走的微信小程序引起广泛关注。腾讯云正式上线微信小程序解决方案，提供小程序在云端服务器的技术方案。
- 2017年1月9日，微信推出的“小程序"正式上线。"小程序"是一种无需安装，即可使用的手机“应用”。不需要像往常一样下载App,用户在微信中"用完即走“。



## 2. 其他应用小程序平台

1. 支付宝小程序
2. 百度小程序
3. QQ小程序
4. 今日头条+抖音小程序



# 环境准备

开发微信小程序之前，必须要准备好相应的环境



## 1. 注册账号

注册页面：https://mp.weixin.qq.com/

> 建议使用全新的邮箱，没有注册过其他小程序或者公众号的。

注意：个人账号是没有微信支付功能的，需要企业主体才可以开通完整权限



![image-20220413232503597](images/mini_program/image-20220413232503597.png)



## 2. 获取 APPID

由于后期调用微信小程序的接口等功能，需要索取开发者的小程序中的APPID,所以在注册成功后，可登录，然后获取 APPID。



登录，成功后在侧边栏中选择开发，在开发设置中可以看到 APPID

![image-20220413232941435](images/mini_program/image-20220413232941435.png)





## 3. 开发工具

VS CODE + 官方微信小程序编辑工具



侧边栏选择开发工具，然后选择开发者工具，就可以下载微信开发者工具了

> 一般下载稳定版就可以



![image-20220413233139356](images/mini_program/image-20220413233139356.png)



# 第一个微信小程序

## 1. 打开微信开发者工具

第一次登录，需要扫码登录

![image-20220413233514766](images/mini_program/image-20220413233514766.png)



## 2. 新建小程序项目

![image-20220413233617464](images/mini_program/image-20220413233617464.png)



# 小程序框架结构

新项目初始化文件结构

![image-20220414215715698](images/mini_program/image-20220414215715698.png)



## 1. 微信小程序中的四种文件类型

- js ---------- JavaScrip文件
- json -------- 项目配置文件，负责窗口颜色等等
- wxml ------- 类似HTML文件
- wxss ------- 类似CSS文件



### wxml 与 html 区别

WXML （Weixin Markup Language） 是小程序框架设计的一套标签语言，用来构建小程序页面结构，其作用类似于网页开发中的 HTML。



标签名称不同

- HTML (div, span, img, a)
- WXML (view, text, image, navigator)



属性节点不同

- `<a href="#">超链接</a>`
- `<navigator url="/pages/home/home"></navigator>`



提供类似于 Vue 中的模板语法

- 数据绑定
- 列表渲染
- 条件渲染



### wxss 与 css 的区别

新增了 rpx 尺寸单位

- CSS 中需要手动进行像素单位换算，例如 rem
- WXSS 在底层支持新的尺寸单位 rPx, 在不同大小的屏幕上小程序会自动进行换算



提供了全局的样式和局部样式

- 项目根目录中的app,wxss会作用于所有小程序页面
- 局部页面的.WXss样式仅对当前页面生效



WXSS仅支持部分CSS选择器

- class 和 id
- element
- 并集选择器、后代选择器
- ::after 和 ::before 等伪类选择器



### js 文件

小程序中的S文件分为三大类，分别是：



- app.js

是整个小程序项目的入口文件，通过调用 APP() 函数来启动整个小程序



- 页面的 js 文件

是页面的入口文件，通过调用 Page() 函数来创建并运行页面



- 普通的 js 文件

是普通的功能模块文件，用来封装公共的函数或属性供页面使用





## 2. 文件说明

通过以下几个最基本文件，构建最简单的小程序

~~~
app.js 					// 项目入口文件
app.json 				// 项目配置文件
app.wxss				// 全局 CSS 文件
protect.config.json		// 项目配置文件
sitemap.json			// 索引配置
~~~



### 2.1 protect.config.json

protect.config.json 是项目配置文件，用来记录我们对小程序开发工具所做的个性化配置，例如：可以修改 appid，项目名称等。如：

- setting 中保存了**编译相关配置**
- projectname 中保存的是**项目名称**
- appid 中保存的是**小程序账号 ID**



~~~
"appid": "wx97d11568dfe2dda0",
"projectname": "mini-demo",
~~~

> - 拿到其他小程序需要先修改 appid
> - projectname 并不等于小程序名称



Setting 中一般不会手动修改，而是通过小程序开发工具，进行配置，如：

![image-20220414213639463](images/mini_program/image-20220414213639463.png)



### 2.2 sitemap.json

小程序根目录下的 `sitemap.json` 文件用来配置小程序及其页面是否允许被微信索引。

配置说明：https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/sitemap.html



默认配置：

~~~json
{
    "desc": "关于本文件的更多信息，请参考文档 https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html",
    "rules": [{
        "action": "allow",
        "page": "*"
    }]
}
~~~

> 允许索引所有页面

**注：没有 sitemap.json 则默认所有页面都能被索引**



![image-20220503150430530](images/mini_program/image-20220503150430530.png)

> sitemap 的索引提示是默认开启的，如果需要关闭 sitemap 的索引提示，可在小程序项目配置文件 project.config.json 的 setting 中配置字段 checkSiteMap 为 false



### 2.3 app.json

app.json 是小程序全局配置文件，运行小程序时会先加载该配置文件，包括了小程序的所有页面路径、窗口外观、界面表现、底部 Tab 等。

~~~json
{
    "pages":[
        "pages/index/index",
        "pages/logs/logs"
    ],
    "window":{
        "backgroundTextStyle":"light",
        "navigationBarBackgroundColor": "#fff",
        "navigationBarTitleText": "Weixin",
        "navigationBarTextStyle":"black"
    },
    "style": "v2",
    "sitemapLocation": "sitemap.json"
}

~~~

> 定义页面、主窗口属性以及样式版本等等



- pages: 用来记录当前小程序所有页面的路径
- window: 全局定义小程序所有页面的背景色、文字颜色
- style: 全局定义小程序组件所使用的样式版本
- sitemapLocation: 用来指明 sitemap.json 位置



**注**：当创建页面时，项目 pages 中会自动添加页面索引



### 2.4 app.js

小程序入口文件，每个小程序都需要在 `app.js` 中调用 `App` 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。

~~~js
// app.js
App({
  onLaunch (options) {
    // Do something initial when launch.
  },
  onShow (options) {
    // Do something when show.
  },
  onHide () {
    // Do something when hide.
  },
  onError (msg) {
    console.log(msg)
  },
  globalData: 'I am global data'
})
~~~



### 2.5 app.wxss

全局样式文件，在此定义的样式会应用到每个页面

~~~css
/**app.wxss**/
.container {
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
  padding: 200rpx 0;
  box-sizing: border-box;
} 
~~~



### 2.6 pages

该文件夹包含每个独立页面文件夹，其中包含基础的四个文件，即：js, json, wxml, wxss，如 index 子页面

~~~
index.js			// 子页面入口文件
index.json
index.wxml
index.wxss
~~~



### 2.7 utils

该文件夹中可以放一些全局自定义 js 方法



## 3. 创建页面

创建页面方法有两种，

- 手动创建
- 自动创建



### 3.1 手动创建

我们可以自己在 pages 路径下创建文件夹，并创建四个基本文件

- js
- json
- wxml
- wxss



我们还可以借助开发者工具直接创建页面，在开发工具中的资源管理器中，右键点击 pages 然后选择创建 page 即可，填入名称后，会自动创建一个文件夹并包含所需文件。

![image-20220415215918582](images/mini_program/image-20220415215918582.png)



### 3.2 app.json 自动创建

利用 app.json 创建的话，只需要在 app.json 中添加一条记录即可，如：

~~~json
"pages":[
    "pages/index/index",
    "pages/logs/logs",
    "pages/news/news"
],
~~~



### 3.3 项目入口页面

如果想要让新创建的页面当做入口页面，我们只需要调整 app.json 中的顺序即可，如：

~~~json
"pages":[
    "pages/news/news",
    "pages/index/index",
    "pages/logs/logs"
],
~~~



### 3.4 页面配置文件

在 app.json 是小程序的全局配置文件，而 pages 中每个文件夹中的 json 文件则是页面的配置文件，页面中的 json 文件用来对本页面的窗口外观进行配置，页面中的配置会覆盖 app.json 的 window 中相同的配置项。



~~~json
  "window":{
    "backgroundTextStyle":"light",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "Weixin",
    "navigationBarTextStyle":"black"
  },
~~~

> 可以看做是一些界面样式的属性和功能



比如是否开启页面下拉刷新功能

~~~json
  "window":{
    "backgroundTextStyle":"dark",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "Weixin",
    "navigationBarTextStyle":"black",
    "enablePullDownRefresh":true,
  },
~~~

> - enablePullDownRefresh 开启下拉刷新功能
> - backgroundTextStyle 需要切换成 dark 才可以在白色背景中看到刷新图标





# 小程序的宿主环境

## 1. 什么是宿主环境

宿主环境(host environment)指的是程序运行所必须的依赖环境。例如：

Android系统和iOS系统是两个不同的宿主环境。安卓版的微信App是不能在iOS环境下运行的，所以，Android是安卓软件的宿主环境，脱离了宿主环境的软件是没有任何意义的！



![image-20220503153147405](images/mini_program/image-20220503153147405.png)



## 2. 小程序的宿主环境

手机微信是小程序的宿主环境，如图：

![image-20220503153231565](images/mini_program/image-20220503153231565.png)



小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能，例如：

微信扫码、微信支付、微信登录、地理定位、etc.…



## 3. 小程序宿主环境包含的内容

- 通信模型
- 运行机制
- 组件
- API



### 3.1 通信模型

小程序中通信的主体是渲染层和逻辑层，其中：

- WXML 模板和 WXSS 样式工作在渲染层

- JS 脚本工作在逻辑层



![image-20220503153501462](images/mini_program/image-20220503153501462.png)



小程序中的通信模型分为两部分：

- 渲染层和逻辑层之间的通信由微信客户端进行转发

- 逻辑层和第三方服务器之间的通信由微信客户端进行转发



![image-20220503154106653](images/mini_program/image-20220503154106653.png)



### 3.2 小程序运行机制

小程序启动的过程

- 把小程序的代码包下载到本地
- 解析app.json全局配置文件
- 执行app,js小程序入口文件，调用App()创建小程序实例
- 渲染小程序首页
- 小程序启动完成



页面渲染过程

- 加载解析页面的 .json 配置文件
- 加载页面的 .Wxml 模板和 .WXss 样式
- 执行页面的 js 文件，调用 Page() 创建页面实例
- 页面渲染完成



# 组件

小程序中组件的分类

小程序中的组件也是由宿主环境提供的，开发者可以基于组件快速搭建出漂亮的页面结构。官方把小程序的组件分为了9大类，分别是：

- 视图容器
- 基础内容
- 表单组件
- 导航组件
- 媒体组件
- map 地图组件
- canvas 画布组件
- 开放能力
- 无障碍访问



## 1. 视图组件

常用的视图容器类组件有 view， scroll-view, swiper, swiper-item



### 1.1 view

- 普通试图区域
- 类似于HTML中的 div ,是一个块级元素
- 常用来实现页面的布局效果



实现 Flex 横向布局

![image-20220503155044107](images/mini_program/image-20220503155044107.png)





### 1.2 scroll-view

- 可滚动的视图区域
- 常用来实现滚动列表效果



![image-20220503155618704](images/mini_program/image-20220503155618704.png)





### 1.3 swiper 和 swiper-item

- 轮播图容器组件和轮播图 item 组件



![image-20220503155844875](images/mini_program/image-20220503155844875.png)



swiper 组件常用属性

| 属性                   | 类型    | 默认值         | 说明                 |
| ---------------------- | ------- | -------------- | -------------------- |
| indicator-dots         | boolean | false          | 是否显示面板指示点   |
| indicator-color        | color   | rgba(0,0,0,.3) | 指示点颜色           |
| indicator-active-color | color   | #000000        | 当前选中的指示点颜色 |
| autoplay               | boolean | false          | 是否自动切换         |
| interval               | number  | 5000           | 自动切换时间间隔     |
| circular               | boolean | false          | 是否采用衔接滑动     |



## 2. 内容组件

常用的基础内容组件有 text 和 rich-text



### 2.1 text

- 文本组件
- 类似于 HTML 中的 span 标签，是一个行内元素



通过 text 组件的 selectable 属性，实现长按选中文本内容的效果：

![image-20220503160919795](images/mini_program/image-20220503160919795.png)

> 需要真机测试，小程序开发者工具模拟界面无法实现该效果



### 2.2 rich-text

- 富文本组件
- 支持把 HTML 字符串渲染为 wxml 结构
- 

通过 rich-text 组件的 nodes 属性节点，把 HTML 字符串渲染为对应的 Ul 结构：

![image-20220503161144275](images/mini_program/image-20220503161144275.png)





## 3. 其他常用组件

### 3.1 button

按钮组件

- 功能比 HTML 中的 button 按钮丰富
- 通过 open-type 属性可以调用微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等）



![image-20220503162058353](images/mini_program/image-20220503162058353.png)



### 3.2 image

图片组件

- image组件默认宽度约300px、高度约240px



![image-20220503162316879](images/mini_program/image-20220503162316879.png)



image 组件的 mode 属性

~~~html
<image src="/images/1.png" mode="scaleToFill"></image>
~~~



| 合法值       | 说明                                                         |
| :----------- | :----------------------------------------------------------- |
| scaleToFill  | 缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素 |
| aspectFit    | 缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。 |
| aspectFill   | 缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。 |
| widthFix     | 缩放模式，宽度不变，高度自动变化，保持原图宽高比不变         |
| heightFix    | 缩放模式，高度不变，宽度自动变化，保持原图宽高比不变         |
| top          | 裁剪模式，不缩放图片，只显示图片的顶部区域                   |
| bottom       | 裁剪模式，不缩放图片，只显示图片的底部区域                   |
| center       | 裁剪模式，不缩放图片，只显示图片的中间区域                   |
| left         | 裁剪模式，不缩放图片，只显示图片的左边区域                   |
| right        | 裁剪模式，不缩放图片，只显示图片的右边区域                   |
| top left     | 裁剪模式，不缩放图片，只显示图片的左上边区域                 |
| top right    | 裁剪模式，不缩放图片，只显示图片的右上边区域                 |
| bottom left  | 裁剪模式，不缩放图片，只显示图片的左下边区域                 |
| bottom right | 裁剪模式，不缩放图片，只显示图片的右下边区域                 |



### 3.3 navigator

页面导航组件

- 类似于HTML中的a链接



# API 

小程序中的AP是由宿主环境提供的，通过这些丰富的小程序API,开发者可以方便的调用微信提供的能力，例如：获取用户信息、本地存储、支付功能等。



API 分类：

- 事件监听类 API
  - 特点：以 on 开头，用来监听某些事件的触发
  - 举例：wx.onWindowResize(function callback)监听窗口尺寸变化的事件
- 同步 API
  - 以Sync结尾的API都是同步API
  - 同步API的执行结果，可以通过函数返回值直接获取，如果执行出错会抛出异常
  - wx.setStorageSync('key,'value')向本地存储中写入内容
- 异步 API
  - 类似于jQuery中的$.ajax(options))函数，需要通过success、fil、complete接收调用的结果
  - wx.request()发起网络数据请求，通过success回调函数接收数据



# 协同工作和发布

## 1. 了解权限管理需求

在中大型的公司里，人员的分工非常仔细：同一个小程序项目，一般会有不同岗位、不同角色的员工同时参与设计与开发。



此时出于管理需要，我们迫切需要对不同岗位、不同角色的员工的权限进行边界的划分，使他们能够高效的进行协同工作。



## 2. 项目组织结构

![image-20220503165154261](images/mini_program/image-20220503165154261.png)



## 3. 小程序开发流程

![image-20220503165241336](images/mini_program/image-20220503165241336.png)



## 4. 成员管理

小程序成员管理体现在管理员对小程序项目成员及体验成员的管理：

- 项目成员：
  - 表示参与小程序开发、运营的成员
  - 可登录小程序管理后台
  - 管理员可以添加、删除项目成员，并设置项目成员的角色

- 体验成员：

  - 表示参与小程序内测体验的成员
  - 可使用体验版小程序，但不属于项目成员
  - 管理员及项目成员均可添加、删除体验成员

  

![image-20220503165453408](images/mini_program/image-20220503165453408.png)



不同项目成员对应的权限

![image-20220503165629690](images/mini_program/image-20220503165629690.png)



开发者权限说明

- 开发者权限：可使用小程序开发者工具及对小程序的功能进行代码开发
- 体验者权限：可使用体验版小程序
- 登录权限：可登录小程序管理后台，无需管理员确认
- 开发设置：设置小程序服务器域名、消息推送及扫描普通链接二维码打开小程序
- 腾讯云管理：云开发相关设置



## 5. 添加项目成员和体验成员

![image-20220503165834501](images/mini_program/image-20220503165834501.png)



## 6. 小程序版本

软件开发过程中的不同版本

在软件开发过程中，根据时间节点的不同，会产出不同的软件版本，例如：

- 开发者编写代码的同时，对项目代码进行自测（开发版本）
- 直到程序达到一个稳定可体验的状态时，开发者把体验版本给到产品经理和测试人员进行体验测试
- 最后修复完程序的BUg后，发布正式版供外部用户使用



小程序版本

![image-20220503170137972](images/mini_program/image-20220503170137972.png)



## 7. 发布上线

小程序发布上线步骤：

一个小程序的发布上线，一般要经过上传代码->提交审核->发布这三个步骤。



- 上传代码
  - 点击开发者工具顶部工具栏中的“上传”按钮
  - 填写版本号以及项目备注



![image-20220503170313586](images/mini_program/image-20220503170313586.png)



- 版本查看

登录小程序管理后台->管理->版本管理->开发版本，即可查看刚才提交上传的版本了：

![image-20220503170426972](images/mini_program/image-20220503170426972.png)



- 提交审核

为什么需要提交审核：为了保证小程序的质量，以及符合相关的规范，小程序的发布是需要经过腾讯官方审核的。

提交审核的方式：在开发版本的列表中，点击“提交审核”按钮之后，按照页面提示填写相关的信息，就能把小程序提交到腾讯官方进行审核。



![image-20220503170556427](images/mini_program/image-20220503170556427.png)



- 发布上线

审核通过之后，管理员的微信中会收到小程序通过审核的通知，此时在审核版本的列表中，点击“发布”按钮之后，即可把“审核通过”的版本发布为“线上版本”，供所有小程序用户访问和使用。



![image-20220503170640608](images/mini_program/image-20220503170640608.png)



## 8. 小程序推广

![image-20220503170835343](images/mini_program/image-20220503170835343.png)



相对于普通二维码来说，小程序码的优势如下：

- 在样式上更具辨识度和视觉冲击力
- 能够更加清晰地树立小程序的品牌形象
- 可以帮助开发者更好地推广小程序



获取小程序码的5个步骤：

登录小程序管理后台->设置->基本设置->基本信息->小程序码及线下物料下载



![image-20220503171139674](images/mini_program/image-20220503171139674.png)





## 9. 运营数据

- 在“小程序后台”查看
  - 登录小程序管理后台
  - 点击侧边栏的“统计”
  - 点击相应的tab可以看到相关的数据



 ![image-20220503171315938](images/mini_program/image-20220503171315938.png)



- 使用“小程序数据助手”查看
  - 打开微信
  - 搜索“小程序数据助手”
  - 查看已发布的小程序相关的数据



后者在后台 - 统计页面中查看小程序数据助手二维码

![image-20220503171515919](images/mini_program/image-20220503171515919.png)



# WXML 模板语法

## 1. 数据绑定

### 1. 数据绑定的基本原则

- 在 data 中定义数据
- 在 wxml 中使用数据



在页面对应的 js 文件中，把数据定义到 data 对象即可：

~~~js
Page({
    data:{
        // 字符串类型数据
        info:'init data',
        // 数组类型数据
        msgList:[{msg:'hello'},{msg:'world'}]
    }
})
~~~



渲染数据

把 data 中的数据绑定到页面中进行渲染，使用Mustache 语法（双大括号），也称作插值语法，将变量包裹起来即可，语法格式为：

~~~html
<view>{{ 要绑定的数据名称 }}</view>
~~~



### 2. 插值语法的主要应用场景

- 绑定内容
- 绑定属性
- 运算（三元运算、算术运算）



#### 2.1 绑定内容

页面数据如下：

~~~js
Page({
    data:{
        info:'init data'
    }
})
~~~



页面结构

~~~html
<view>{{ info }}</view>
~~~



#### 2.2 绑定属性

~~~js
Page({
    data:{
        imgSrc:'http://www.itheima.com/images/logo.png'
    }
})
~~~



~~~html
<image src="{{imgSrc}}"></image>
~~~



#### 2.3  运算

三元运算

~~~js
Page({
    data:{
        randomNum: Math.random()*10 // 生成 10 以内的随机数
    }
})
~~~



~~~html
<view>{{ randomNumber >= 5 ? '随机数大于或等于5' : '随机数小于5' }}</view>
~~~



普通运算



~~~js
Page({
    data:{
        randomNum: Math.random().toFixed(2) // 生成一个两位小数随机数
    }
})
~~~



~~~html
<view>生成100以内的随机数：{{ randomNumber * 100 }}</view>
~~~



## 2. 事件绑定

事件是渲染层到逻辑层的通讯方式。通过事件可以将用户在渲染层产生的行为，反馈到逻辑层进行业务的处理。



![image-20220504215015133](images/mini_program/image-20220504215015133.png)



### 1. 小程序中常用事件

![image-20220504215039013](images/mini_program/image-20220504215039013.png)



### 2. 事件对象属性列表

当事件回调触发的时候，会收到一个事件对象event,它的详细属性如下表所示：

![image-20220504215144605](images/mini_program/image-20220504215144605.png)



#### 2.1 target 与 currentTarget

target是触发该事件的源头组件，而currentTarget则是当前事件所绑定的组件。举例如下：

![image-20220504215231197](images/mini_program/image-20220504215231197.png)



点击内部的按钮时，点击事件以冒泡的方式向外扩散，也会触发外层view的tap事件处理函数。此时，对于外层的view来说：

- e.target 指向的是触发事件的源头组件，因此，e.target 是内部的按钮组件
- e.currentTarget 指向的是当前正在触发事件的那个组件，因此，e.currentTarget 是当前的 view 组件



#### 2.2 bindTap

在小程序中，不存在HTML中的onclick鼠标点击事件，而是通过tap事件来响应用户的触摸行为。



在页面的 wxml 文件中，通过 bindtap, 可以为组件绑定tap触摸事件，语法如下：

~~~js
<button type="primary" bindtap="btnTapHandler">按钮</button>
~~~



在页面的 js 文件中定义对应的事件处理函数，事件参数通过形参 event (一般简写成e) 来接收：

~~~js
Page({    
    data: {
    },
    // 与 Data 平级，注意写完 fn 后，加逗号
    btnTapHandler(e){
        console.log(e);
    },
})
~~~



event 对象属性

![image-20220504220511712](images/mini_program/image-20220504220511712.png)



#### 2.3 事件传参

在事件处理函数中为 data 中的数据赋值

通过调用 this.setData(dataObject) 方法，可以给页面 data 中的数据重新赋值，示例如下：

~~~html
<button type="primary" bindtap="changeCount">按钮</button>
<text>{{count}}</text>
~~~



~~~js
Page({
    data: {
        count: 0
    },

    changeCount(){
        this.setData({
            count: this.data.count + 1
        })
    },
})
~~~



小程序中的事件传参比较特殊，不能在绑定事件的同时为事件处理函数传递参数。例如，下面的代码将不能正常工作：

~~~html
<button type="primary" bindtap="btnHandler(123)">按钮</button>
~~~

> 因为小程序会把bindtap的属性值，统一当作事件名称来处理，相当于要调用一个名称为btnHandler(123)的事件处理函数。



可以为组件提供 `data-*` 自定义属性传参，其中*代表的是参数的名字，示例代码如下：

~~~html
<button type="primary" bindtap="btnHandler" data-info="{{2}}">按钮</button>
~~~

- info 会被解析为参数的名字
- 数值 2 会被解析为参数的值



在事件处理函数中，通过 `event.target.dataset.参数名` 即可获取到具体参数的值，示例代码如下：

~~~js
btnHandler(event){
    // dtaset 是一个对象，包含了所有通过 data-* 传递过来的参数
    console.log(event.target.dataset)
    // 通过 dataset 可以访问到具体参数的值
    console.log(event.target.dataset.info)
}
~~~



#### 2.4 bindInput

在小程序中，通过iput事件来响应文本框的输入事件，语法格式如下：

通过 bindinput, 可以为文本框绑定输入事件：

~~~html
<input bindinput="inputHandler"></input>
~~~



在页面中的 js 文件中定义事件处理函数：

~~~js
inputHandler(e){
    // e.target.value 是变化过后，文本框最新的值
    console.log(e.detail.value)
}
~~~



![image-20220504223908691](images/mini_program/image-20220504223908691.png)





#### 2.5 文本框与 data 之间的数据同步

实现步骤：

- 定义数据
- 渲染结构
- 美化样式
- 绑定 input 事件处理函数



定义数据

~~~js
Page({
    data: {
        msg: '你好'
    },
})
~~~



渲染结构

~~~html
<input value="{{msg}}" bindinput="iptHandler"></input>
~~~



美化样式

~~~css
input {
    border:1px solid #000;
    padding:5px;
    margin:5px;
    border-radius:3px;
}
~~~



绑定 input 事件处理函数

~~~js
// 文本框内容改变事件
iptHandler(e){
    this.setData({
        // 通过 e.detail.value 获取到文本框最新的值
        msg: e.detail.value
    })
},
~~~



## 3. 条件渲染

### 1. if, elif, else

在小程序中，使用 `wx:if="{{condition}}"` 来判断是否需要渲染该代码块：

~~~html
<view wx:if="{{condition}}">True </view>
~~~



也可以用 `wx:elif` 和 `wx:else` 来添加else判断：

~~~html
<view wx:if="{{type === 1}}"> 男 </view>
<view wx:elif="{{type === 2}}"> 女 </view>
<view wx:else> 保密 </view>

~~~

> type 值在 js 中的 data 中定义



### 2. `<block>`

如果要一次性控制多个组件的展示与隐藏，可以使用一个`<block></block>`标签将多个组件包装起来，并在`<block>`:标签上使用 wx:if 控制属性，示例如下：

~~~html
<block wx:if="{{true}}">
    <view> view1 </view>
    <view> view2 </view>
</block>
~~~

> 注意： `<block>` 并不是一个组件，它只是一个包裹性质的容器，不会在页面中做任何渲染



与下边代码不同的是，block 标签不会在页面中渲染，页面中只会显示两个 view 标签

~~~html
<view wx:if="{{true}}">
    <view> view1 </view>
    <view> view2 </view>
</view>
~~~





### 3. hidden

在小程序中，可以使用 `hidden = {{condition}}` 也能控制元素的显示和隐藏，如：

~~~html
<view hidden="{{flag}}">条件为 true 隐藏，条件为 false 显示</view>
~~~



### 4. if 与 hidden 对比

- 运行方式不同
  - wx:if 以动态创建和移除元素的方式，控制元素的展示与隐藏
  - hidden 以切换样式的方式 (display:none/block;), 控制元素的显示与隐藏

- 使用建议
  - 频繁切换时，建议使用 hidden
  - 控制条件复杂时，建议使用 wx:if 搭配 wx:elif、wx:else 进行展示与隐藏的切换



## 4. 列表渲染

### 1. for

通过 wx:for可以根据指定的数组，循环渲染重复的组件结构，语法示例如下：

~~~html
<view wx:for="{{array}}">
	索引是{{index}}, 当前项是{{item}}
</view>
~~~

> 默认情况下，当前循环项的索引用 index 表示；当前循环项用 item 表示。



### 2. 手动指定索引和当前项的变量名*

- 使用 wx:for-index 可以指定当前循环项的索引的变量名
- 使用 wx:for-item 可以指定当前项的变量名



示例代码如下：

~~~html
<view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">
	索引是：{{idx}} 当前项是：{{itemName}}
</view>
~~~



### 3. key

类似于 Vue 列表渲染中的 :key, 小程序在实现列表渲染时，也建议为渲染出来的列表项指定唯一的key值，从而提高渲染的效率，示例代码如下：



js 中获取数据

~~~js
data:{
	userList:[
        {id:1, name:'小红'},
        {id:2, name:'小黄'},
        {id:3, name:'小蓝'},        
    ]
},
~~~



wxml 渲染数据

~~~html
<view wx:for="{{userList}}" wx:key="id">{{item.name}}</view>
~~~

> 设定 key 时不用加 {{ }}



# WXSS

- WXSS (WeiXin Style Sheets) 是一套样式语言，用于美化 WXML 的组件样式，类似于网页开发中的CSS。



## 1. wxss 与 css

WXSS具有CSS大部分特性，同时，WXSS还对CSS进行了扩充以及修改，以适应微信小程序的开发。

与 CSS 相比， WXSS 扩展的特性有：

- rpx 尺寸单位
- @import 样式导入



![image-20220505111107179](images/mini_program/image-20220505111107179.png)



## 2. rpx 尺寸单位

rpx（responsive pixel) 是微信小程序独有的，用来解决屏适配的尺寸单位。



rpx 的实现原理非常简单：鉴于不同设备屏幕的大小不同，为了实现屏幕的自动适配，rpx 把所有设备的屏幕，在宽度上等分为750份（即：当前屏幕的总宽度为750rpx)。

- 在较小的设备上，1rpx所代表的宽度较小
- 在较大的设备上，1rpx所代表的宽度较大



小程序在不同设备上运行的时候，会自动把x的样式单位换算成对应的像素单位来渲染，从而实现屏幕适配。



rpx 与 px 之间换算*

在 iPhone6上，屏幕宽度为375px,共有750个物理像素，等分为750rpX。则：

- 750rpx = 375px = 750 物理像素
- 1rpx = 0.5px = 1 物理像素



![image-20220505111848778](images/mini_program/image-20220505111848778.png)



> 官方建议：开发微信小程序时，设计师可以用iPhone6作为视觉稿的标准。
>
> 开发举例：在iPhone6上如果要绘制宽100px,高20px的盒子，换算成rpx单位，宽高分别为200rpx和40rpx。



设置小程序开发者工具显示机型

![image-20220507135206517](images/mini_program/image-20220507135206517.png)





## 3. 样式导入

使用 wxss 提供的 `@import` 语法，可以导入外联的样式表



@import 后跟需要导入的外联样式表的路径，用 `;` 表示语句结束。示例如下：

~~~css
/** common.wxss **/
.small-p {
    padding:5px;
}
~~~



~~~css
/** app.wxss **/
@import "common.wxss";
.middle-p {
    padding:15px;
}
~~~



不同页面的需要使用绝对路径

![image-20220505113323403](images/mini_program/image-20220505113323403.png)



## 4. 全局样式与局部样式

- 全局样式
  - 定义在 app.wxss 中的样式为全局样式，作用于每一个页面。

- 局部样式
  - 在页面的 wxss 文件中定义的样式为局部样式，只作用于当前页面。



注意：

- 当局部样式和全局样式冲突时，根据就近原则，局部样式会覆盖全局样式
- 当局部样式的权重大于或等于全局样式的权重时，才会覆盖全局的样式



# app.json 全局配置

小程序根目录下的 app.json 文件是小程序的全局配置文件。常用的配置项如下：



- pages
  - 记录当前小程序所有页面的存放路径
- window
  - 全局设置小程序窗口外观
- tabBar
  - 设置小程序底部的 tabBar 效果
- style
  - 是否启用新版的组件样式



## 1. 全局配置 window 



### 1. 小程序窗口组成部分

![image-20220505115947657](images/mini_program/image-20220505115947657.png)



### 2. window 节点常用配置项

![image-20220505120100370](images/mini_program/image-20220505120100370.png)

> 注意导航栏颜色只支持 16位 颜色格式，而标题颜色仅支持 black / white



#### 1. 设置导航栏背景色

设置步骤：app.json->window->navigationBarBackgroundColor

需求：把导航栏标题的背景色，从默认的 #fff 修改为 #2b4b6b, 效果如图所示：

![image-20220505120718273](images/mini_program/image-20220505120718273.png)

> 注意：navigationBarBackgroundColor 只允许使用 16位 颜色格式



#### 2. 设置导航栏标题颜色

设置步骤：app.json->window->navigationBarTextStyle

需求：把导航条上的标题，从默认的black修改为white,效果如图所示：

![image-20220505120548938](images/mini_program/image-20220505120548938.png)



> 注意：navigationBarTextStyle的可选值只有black和white



### 3. 下拉刷新

#### 1. 开启下拉刷新

概念：下拉刷新是移动端的专有名词，指的是通过手指在屏幕上的下拉滑动操作，从而重新加载页面数据的行为。

设置步骡：app.json->window->把 enablePullDownRefresh 的值设置为true

> 注意：在 app.json 中启用下拉刷新功能，会作用于每个小程序页面！



下拉刷新效果模拟器会自动闭合，但是真机测试会出现 Bug，所以**小程序最好在真机上测试**



#### 2. 设置下拉刷新背景色

当全局开启下拉刷新功能之后，默认的窗口背景为白色。如果自定义下拉刷新窗口背景色，

设置步骤为：app.json -> window -> 为 backgroundColor 指定16进制的颜色值 #efefef。效果如下：

![image-20220505121349424](images/mini_program/image-20220505121349424.png)

#### 3. 设置下拉刷新 loading 样式

当全局开启下拉刷新功能之后，默认窗口的 loading 样式为白色，如果要更改 loading 样式的效果，设置步骤为 app.json -> window -> 为 backgroundTextStyle 指定 dark 值。效果如下：

![image-20220505121556519](images/mini_program/image-20220505121556519.png)

> 注意：backgroundTextStyle 的可选值只有 light 和 dark



### 4. 上拉触底

概念：上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为。

设置步骤：app.json -> window -> 为 onReachBottomDistance 设置新的数值



注意：默认距离为50X,如果没有特殊需求，建议使用默认值即可。



### 5. tabBar

tabBar 是移动端应用常见的页面导航效果，用于实现多页面的快速切换。小程序中通常将其分为：

- 底部 tabBar
- 顶部 tabBar



![image-20220505122001303](images/mini_program/image-20220505122001303.png)



注意：

- tabBar 中只能配置最少2个、最多5个tab页签
- 当渲染顶部 tabBar 时，不显示 icon, 只显示文本



#### 1. tabBar 组成

- backgroundColor: tabBar 的背景色
- selectedIconPath: 选中时的图片路径
- borderStyle: tabBar上边框的颜色
- iconPath: 未选中时的图片路径
- selectedColor: tab上的文字选中时的颜色
- color: tab上文字的默认（未选中）颜色

![image-20220505122136776](images/mini_program/image-20220505122136776.png)





#### 2. tabBar 节点配置项

![image-20220505122343458](images/mini_program/image-20220505122343458.png)



其中 list 是每个 tab 的配置选项， list 接受一个数组，**只能配置最少 2 个、最多 5 个 tab**。tab 按数组的顺序排序，每个项都是一个对象，其属性值如下：

![image-20220505122429854](images/mini_program/image-20220505122429854.png)



#### 3. 配置 tabBar

打开 app.json 配置文件，和 pages、window 平级，新增 tabBar 节点

~~~json
"tabBar": {
    "position": "bottom",
    "color":"#000",
    "selectedColor":"ff0000",
    "list": [{
        "pagePath": "pages/index/index",
        "text": "首页",
        "iconPath": "static/icon/news_o.png",
        "selectedIconPath": "static/icon/news.png"
    },{
        "pagePath": "pages/news/news",
        "text": "新闻",
        "iconPath": "static/icon/home_o.png",
        "selectedIconPath": "static/icon/home.png"
    } ]
},
~~~



- position 可以是 top 或 bottom（top会没有图标）
- color 和 selectedColor 代表默认颜色和被选中颜色
- list 是一个数组，其中包括各个 Tab 的配置



## 2. 页面 json 配置

小程序中，每个页面都有自己的 json 配置文件，用来对当前页面的窗口外观、页面效果等进行配置。



小程序中，app.json 中的 window 节点，可以全局配置小程序中每个页面的窗口表现。

如果某些小程序页面想要拥有特殊的窗口表现，此时，“页面级别的 json 配置文件” 就可以实现这种需求。

> 注意：当页面配置与全局配置冲突时，根据就近原则，最终的效果以页面配置为准。



页面配置与全局配置项一致

![image-20220505134549984](image-20220505134549984.png)



# 网络数据请求

出于安全性方面的考虑，小程序官方对数据接口的请求做出了如下两个限制：

- 只能请求HTTPS类型的接口
- 必须将接口的域名添加到信任列表中



![image-20220505135349400](images/mini_program/image-20220505135349400.png)



## 1. 配置 request 合法域名

- 需求描述：假设在自己的微信小程序中，希望请求 https:/www.escook.cn/ 域名下的接口
- 配置步骤：登录微信小程序管理后台->开发->开发设置->服务器域名->修改request合法域名



![image-20220505135819767](images/mini_program/image-20220505135819767.png)



注意事项：

- 域名只支持 https 协议
- 域名不能使用 IP 地址或 localhost
- 域名必须经过 ICP 备案
- 服务器域名一个月内最多可申请5次修改



## 2. 发送 get 请求

调用微信小程序提供的 wx.request() 方法，可以发起GET数据请求，示例代码如下：

~~~js
wx.request({
    url: 'https://www.escook.cn/api/get',	// 请求接口，必须是 https 协议，且域名已添加到合法域名白名单
    method: 'GET',
    data:{
        name:'zs',
        age:22
    },
    success:(res)=>{		// 请求成功后的回调函数
        console.log(res)
    }
})
~~~



例：

wxml 添加事件

~~~html
<button type="primary" bindtap="getInfo">按钮</button>
~~~



js 中添加网络请求

~~~js
getInfo(){
    wx.request({
        url: 'https://www.escook.cn/api/get',	// 请求接口，必须是 https 协议，且域名已添加到合法域名白名单
        method: 'GET',
        data:{
            name:'zs',
            age:22
        },
        success:(res)=>{		// 请求成功后的回调函数
            console.log(res)
        }
    })
},
~~~



实际上需要的数据是 res.data

![image-20220505140705225](images/mini_program/image-20220505140705225.png)



## 3. 发起 post 请求

post 请求与 get 请求类似，method 改为 post 即可

~~~js
wx.request({
    url: 'https://www.escook.cn/api/post',	// 请求接口，必须是 https 协议，且域名已添加到合法域名白名单
    method: 'POST',
    data:{
        name:'zs',
        age:22
    },
    success:(res)=>{		// 请求成功后的回调函数
        console.log(res)
    }
})
~~~



## 4. 页面加载时请求数据

在很多情况下，我们需要在页面刚加载的时候，自动请求一些初始化的数据。此时需要在页面的 onLoad 事件中调用获取数据的函数，示例代码如下：

~~~js
    /**
     * 生命周期函数--监听页面加载
     */
    onLoad(options) {
        this.getInfo()
        this.postInfo()
    },
~~~



## 5. 开发跳过 request 合法域名校验

如果后端程序员仅仅提供了 http 协议的接口、暂时没有提供 https 协议的接口，或者说没有配置合法域名，此时为了不耽误开发的进度，

我们可以在微信开发者工具中，临时开启「开发环境不校验请求域名、TLS版本及HTTPS证书」选项，跳过request合法域名的校验。

![image-20220505141153222](images/mini_program/image-20220505141153222.png)



## 6. 跨域

跨域问题只存在于基于浏览器的 Web 开发中。由于小程序的宿主环境不是浏览器，而是微信客户端，所以小程序中不存在跨域的问题。





# 页面导航

页面导航指的是页面之间的相互跳转。例如，浏览器中实现页面导航的方式有如下两种：

- `<a>`链接
- location.href



小程序中实现页面导航的两种方式：

- 声明式导航

  - 在页面上声明一个`<navigator>`导航组件
  - 通过点击`<navigato>`组件实现页面跳转

- 编程式导航

  - 调用小程序的导航API, 实现页面的跳转

  

## 1. 声明式导航

### 1. 导航到 tabBar 页面

tabBar 页面指的是被配置为 tabBar 的页面。

在使用 `<navigator>`组件跳转到指定的 tabBar 页面时，需要指定 url 属性和 open-type 属性，其中：

- url 表示要跳转的页面的地址，必须以 / 开头
- open-type 表示跳转的方式，必须为 switchTab 



示例代码如下：

~~~html
<navigator url="/pages/message/message" open-type="switchTab">导航到消息页面</navigator>
~~~



### 2. 导航到非 tabBar 页面

非 tabBar 页面指的是没有被配置为 tabBar 的页面

在使用 `<navigator>` 组件跳转到普通的非 tabBar 页面时，则需要指定 url 属性和 open-type 属性，其中：

- url 表示要跳转的页面的地址，必须以 / 开头
- open-type 表示跳转的方式，必须为 navigate



示例代码如下：

~~~html
<navigator url="/pages/info/info" open-type="navigate">导航到info页面</navigator>
~~~



注意：为了简便，在导航到非 tabBar 页面时，`open-type="navigate"` 属性可以省略。



### 3. 后退导航

如果要后退到上一页面或多级页面，则需要指定 open-type 属性和 delta 属性，其中：

- open-type 的值必须是 navigateBack ,表示要进行后退导航
- delta 的值必须是数字，表示要后退的层级



示例代码如下：

~~~html
<navigator open-type='navigateBack' delta='1'>返回上一页</navigator>
~~~



注意：为了简便，如果只是后退到上一页面，则可以省略 delta 属性，因为其默认值就是1。



## 2. 编程式导航

编程式导航有些类似于浏览器中的事件跳转，当点击按钮或链接时，调用方法来进行跳转。



### 1. 导航到 tabBar 页面

调用 wx.switchTab(Object object) 方法，可以跳转到 tabBar 页面。其中 Object 参数对象的属性列表如下：

![image-20220506213146108](images/mini_program/image-20220506213146108.png)



示例代码如下：

~~~html
<!--页面结构-->
<button bindtap="gotoMessage">跳转到消息页面</button>
~~~



~~~js
// 通过编程式导航，跳转到 message 页面
gotoMessage(){
    wx.switchTab({
        url: '/pages/index/message',
    })
},
~~~



### 2. 导航到非 tabBar 页面

调用 wx.navigateTo(Object object) 方法，可以跳转到非 tabBar 的页面。其中 Object 参数对象的属性列表如下：

![image-20220506213911642](images/mini_program/image-20220506213911642.png)



示例代码如下：

~~~html
<!--页面结构-->
<button bindtap="gotoMessage">跳转到消息页面</button>
~~~



~~~js
gotoMessage(){
    wx.navigateTo({
        url: '/pages/index/message',
    })
},
~~~



### 3. 后退导航

调用 wx.navigateBack(Object object) 方法，可以跳转到非 tabBar 的页面。其中 Object 参数对象的属性列表如下：

![image-20220506214114954](images/mini_program/image-20220506214114954.png)



示例代码如下：

~~~html
<!--页面结构-->
<button bindtap="gotoBack">跳转到消息页面</button>
~~~



~~~js
gotoBack(){
    wx.navigateBack()
},
~~~



## 3. 导航传参

### 1. 声明式导航传参

navigator 组件的 url 属性用来指定将要跳转到的页面的路径。同时，路径的后面还可以携带参数：

- 参数与路径之间使用 `?` 分隔
- 参数键与参数值用 `=` 相连
- 不同参数用 `&` 分隔



代码示例如下：

~~~html
<navigator url="/pages/info/info?name=zs&age=20">跳转到info页面</navigator>
~~~



### 2. 编程式导航传参

调用 wx.navigateTo(Object object) 方法跳转页面时，也可以携带参数，代码示例如下：



~~~html
<!--页面结构-->
<button bindtap="gotoInfo">跳转到 info 页面</button>
~~~



~~~js
gotoInfo(){
    wx.navigateTo({
        url: '/pages/info/info?name=zs&age=20',
    })
},
~~~



注意：wx.switchTab 不支持传参



### 3. 小程序查看传参

小程序开发者工具中，左下角可以设置显示页面参数

![image-20220506214610058](images/mini_program/image-20220506214610058.png)



### 4. 在 onLoad 中接收导航参数

通过声明式导航传参或编程式导航传参所携带的参数，可以直接在 onLoad 事件中直接获取到



示例代码如下：

~~~js
    /**
     * 生命周期函数--监听页面加载
     */
    onLoad(options) {
        console.log(options);
    },
~~~



由于生命周期函数之间数据不通用，我们需要把参数存储在 data 中，以便其他函数调用，示例代码如下：

~~~js
	/**
     * 页面的初始数据
     */
    data: {
        query:{}
    },
     /**
     * 生命周期函数--监听页面加载
     */
    onLoad(options) {
        this.setData({
            query: options
        })
    },
~~~



# 页面事件

## 1. 下拉刷新事件

下拉刷新是移动端的专有名词，指的是通过手指在屏幕上的下拉滑动操作，从而重新加载页面数据的行为。



### 1. 启用下拉刷新有两种方式

- 全局开启下拉刷新
  - 在 app.json 的 window 节点中，将 enablePullDownRefresh 设置为 true
- 局部开启下拉刷新
  - 在页面的 .json 配置文件中，将 enablePullDownRefresh 设置为 true



在实际开发中，推荐使用第2种方式，为需要的页面单独开启下拉刷新的效果。



### 2. 配置下拉刷新窗口样式

在全局或页面的 json 配置文件中，通过 backgroundColor 和 backgroundTextStyle 来配置下拉刷新窗口的样式，其中：

- backgroundColor 用来配置下拉刷新窗口的背景颜色，仅支持16进制的颜色值
- backgroundTextStyle 用来配置下拉刷新loading的样式，仅支持dark和light



### 3. 监听下拉刷新事件

在页面的 js 文件中，通过 onPullDownRefresh() 函数即可监听当前页面的下拉刷新事件。



例如，在页面的 wxml 中有如下的 UI 结构，点击按钮可以让 count 值自增+1：

~~~html
<!-- 页面结构 -->
<view>Count值为:{{count}}</view>
<button bindtap="countAdd">+1</button>
~~~



~~~js
// js 
Page({
    // 初始化 count 值
    data: {
        count: 0,
    },

    // countAdd 事件，触发后 count 自增 1
    countAdd(){
        this.setData({
            count: this.data.count + 1
        })
    },
    
    // 监听用户下拉动作，将 count 重置为 0
    onPullDownRefresh() {
        this.setData({
            count:0
        })
    },
})
~~~



### 4. 停止下拉刷新效果

当处理完下拉刷新后，下拉刷新的 loading 效果会一直显示，不会主动消失，所以需要手动隐藏 loading 效果。

此时，调用 wx.stopPullDownRefresh() 可以停止当前页面的下拉刷新。示例：

~~~js
// 监听用户下拉动作，将 count 重置为 0
onPullDownRefresh() {
    this.setData({
        count:0
    })
    // 当数据重置成功后，调用此函数，关闭下拉刷新效果
    wx.stopPullDownRefresh()
},

~~~



## 2. 上拉触底事件

上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为



### 1. 监听页面上拉触底事件

在页面的，js 文件中，通过 onReachBottom() 函数即可监听当前页面的上拉触底事件。示例代码如下：

~~~js
    /**
     * 页面上拉触底事件的处理函数
     */
    onReachBottom() {
        console.log('触发了触底事件');
    },
~~~



### 2. 配置上拉触底距离

上拉触底距离指的是触发上拉触底事件时，滚动条距离页面底部的距离

可以在全局或页面的，json 配置文件中，通过 onReachBottomDistance 属性来配置上拉触底的距离。

小程序默认的触底距离是 50px, 在实际开发中，可以根据自己的需求修改这个默认值。



### 3. 上拉触底案例

案例实现步骤：

- 定义获取随机颜色的方法
- 在页面加载时获取初始数据
- 渲染 UI 结构并美化页面效果
- 在上拉触底时调用获取随机颜色的方法
- 添加 loading 提示效果
- 对上拉触底进行节流处理



#### **定义获取随机颜色方法**

~~~js
    data: {
        colorList:[]
    },

    getColors(){
        wx.request({
          url: 'https://www.escook.cn/api/color',
          method: 'GET',
          success:(res)=>{
              console.log(res.data);
          }
        })
    },
~~~



> 可以使用解构，直接拿到 res.data 中的值

~~~js
success:({data:res})=>{
    console.log(res);
}
~~~



#### 在页面加载时获取初始数据

~~~js
    onLoad(options) {
        this.getColors()
    },
~~~



加载页面获得数据

![image-20220506231017932](images/mini_program/image-20220506231017932.png)



当然，我们的目的是每请求一次，就将当前的 colorList 中添加新的数据，所以最终代码是

~~~js
    getColors(){
        wx.request({
          url: 'https://www.escook.cn/api/color',
          method: 'GET',
          success:({data:res})=>{
              this.setData({
                  colorList: [...this.data.colorList, ...res.data]
              })
          }
        })
    },
~~~



当页面加载时，colorList 从空数组，追加数据变成了

![image-20220506231451864](images/mini_program/image-20220506231451864.png)



#### 渲染 UI 结构并美化页面效果

~~~html
<!-- 页面结构 -->
<view wx:for="{{colorList}}" wx:key="index" class="colorItem" style="background-color: rgba({{item}});">
    <view>{{item}}</view>
</view>
~~~



~~~css
/* CSS */
.colorItem{
    border:1px solid #eee;
    border-radius: 8rpx;
    line-height: 200rpx;
    margin:8rpx;
    text-align: center;
    text-shadow: 0rpx 0rpx 5rpx #fff;
    box-shadow: 1rpx 1rpx 6rpx #aaa;
}
~~~



#### 在上拉触底时调用方法

~~~js
    onReachBottom() {
        this.getColors()
    },
~~~



#### 添加 Loading 效果

Loading 效果可以使用微信小程序提供的 API， `wx.showLoading(Object)` ，用来显示 loading 提示框。

| 属性     | 类型     | 默认值 | 必填 | 说明                                             |
| :------- | :------- | :----- | :--- | :----------------------------------------------- |
| title    | string   |        | 是   | 提示的内容                                       |
| mask     | boolean  | false  | 否   | 是否显示透明蒙层，防止触摸穿透                   |
| success  | function |        | 否   | 接口调用成功的回调函数                           |
| fail     | function |        | 否   | 接口调用失败的回调函数                           |
| complete | function |        | 否   | 接口调用结束的回调函数（调用成功、失败都会执行） |

> 显示 loading 提示框。需主动调用 wx.hideLoading 才能关闭提示框



当调用 getColors() 方法获取数据前，可以先使用小程序 API，显示 Loading 提示框，并在获取数据后，将提示框隐藏，示例代码如下：

~~~js
    getColors(){
        wx.showLoading({
            title: '正在读取数据...',
            mask: true,
          })
        wx.request({
          url: 'https://www.escook.cn/api/color',
          method: 'GET',
          success:({data:res})=>{
              console.log(res);
              this.setData({
                  colorList: [...this.data.colorList, ...res.data]
              })
          },
          complete:()=>{
              wx.hideLoading()
          }
        })
    },
~~~



#### 设置节流阀

为了防止在读取数据中，用户再次触发下拉触底事件，我们需要设置一个节流阀，当读取数据中，不再重新读取事件。

- 在 data 中定义 isloading 节流阀（布尔状态值）
  - false 表示当前没有进行任何数据请求
  - true 表示当前正在进行数据请求
- 在 getColors() 方法中修改 isloading 节流阀的值
  - 在刚调用 getColors 时将节流阀设置为 true
  - 在网络请求的 complete 回调函数中，将节流阀重置为 false
- 在 onReachBottom 中判断节流阀的值，从而对数据请求进行节流控制
  - 如果节流阀的值为 true，则组织当前请求
  - 如果节流阀的值为 false，则发起数据请求



示例代码如下：

~~~js
Page({
    data: {
        colorList:[],
        isLoading: false,
    },

    // 读取数据方法
    getColors(){
        this.setData({
            isLoading: true
        })
        wx.showLoading({
            title: '正在读取数据...',
            mask: true,
          })
        wx.request({
            url: 'https://www.escook.cn/api/color',
            method: 'GET',
            success:({data:res})=>{
                console.log(res);
                this.setData({
                    colorList: [...this.data.colorList, ...res.data]
                })
            },
            complete:()=>{
                wx.hideLoading()
                this.setData({
                    isLoading: false
                })              
            }
        })
    },

    // 页面初始化加载事件
    onLoad(options) {
        this.getColors()
    },

    // 上拉触底触发事件
    onReachBottom() {
        if(this.data.isLoading) return
        this.getColors()
    },
})
~~~



## 3. 自定义编译模式

如果正在调试的页面不是首页时，那么每次保存都会返回首页，如果想查看页面效果的话，还需要进行点击跳转到之前页面进行查看，可以使用以下两种方法来快速查看保存后的页面效果。



- 编辑 app.json ，修改 pages 的顺序，将需要查看的页面放在第一行即可
- 使用自定义编译模式

![image-20220507122011617](images/mini_program/image-20220507122011617.png)



# 生命周期

生命周期 (Life Cycle) 是指一个对象从创建->运行->销毁的整个阶段，强调的是一个时间段。例如：

- 张三出生，表示这个人生命周期的开始
- 张三离世，表示这个人生命周期的结束
- 中间张三的一生，就是张三的生命周期



我们可以把每个小程序运行的过程，也概括为生命周期：

- 小程序的启动，表示生命周期的开始
- 小程序的关闭，表示生命周期的结束
- 中间小程序运行的过程，就是小程序的生命周期



## 1. 小程序生命周期

在小程序中，生命周期分为两类，分别是：

- 应用生命周期
  - 特指小程序从启动->运行->销毁的过程
- 页面生命周期
  - 特指小程序中，每个页面的加载->渲染->销毁的过程



![image-20220507122548491](images/mini_program/image-20220507122548491.png)



## 2. 生命周期函数

生命周期函数：是由小程序框架提供的内置函数，会伴随着生命周期，自动按次序执行。

生命周期函数的作用：允许程序员在特定的时间点，执行某些特定的操作。例如，页面刚加载的时候，可以在 onLoad 生命周期函数中初始化页面的数据。

> 注意：生命周期强调的是时间段，生命周期函数强调的是时间点。



小程序中的生命周期函数分为两类，分别是：

- 应用的生命周期函数
  - 特指小程序从启动->运行->销毁期间依次调用的那些函数
- 页面的生命周期函数
  - 特指小程序中，每个页面从加载->渲染->销毁期间依次调用的那些函数



## 3. 应用声明周期函数

小程序的应用生命周期函数需要在pp,js中进行声明，示例代码如下：

~~~js
// app.js文件
App({
    // 小程序始化完成时，执行此函数，全局只触发一次。可以做一些初始化的工作。
    onLaunch:function(options){},

    // 小程序启动，或从后台进入前台显示时触发。
    onShow function(options){},

    // 小程序从前台进入后台时触发。
    onHide function(){}
})

~~~



工具 -> 工具栏管理 -> 切后台

![image-20220507123307287](images/mini_program/image-20220507123307287.png)



## 4. 页面的生命周期函数

小程序的页面生命周期函数需要在页面的 js 文件中进行声明，示例代码如下：

~~~js
// 页面的.js文件
Page({
    onLoad:function(options){},		// 监听页面加载，一个页面只调用1次
    onShow: function(){},			// 监听页面显示
    onReady: function(){},			// 监听页面初次渲染完成，一个页面只调用1次
    onHide: function(){},			// 监听页面隐藏
    onUnload:function(){}			// 监听页面加载，一个页面只调用1次
})

~~~



> - onLoad 常用于初始化数据
> - onReady 常用于页面渲染完成，我们修改页面中的一些数据，如调用 wx.setNavigationBarTitle 设置导航栏标题等等





# WXS 脚本

WXS (WeiXin Script) 是小程序独有的一套脚本语言，结合 WXML , 可以构建出页面的结构。



## 1. 应用场景

wxml 中无法调用在页面的 js 中定义的函数，但是，wxml 中可以调用 wxs 中定义的函数。因此，小程序中 wxs 的典型应用场景就是“过滤器”。

> 简单来说就是需要对获取的数据需要进行二次加工，如将字符串转换为大写



## 2. wxs 与 js

为了降低 wxs （WeiXin Script） 的学习成本， wxs 语言在设计时借鉴大量的 Javascript 语法。虽然 wxs 的语法类似于 JavaScript , 但是 wxs 和 JavaScript 是完全不同的两种语言：



- wxs 有自己的数据类型
  - number 数值类型、string 字符串类型、boolean 布尔类型
  - object 对象类型、function 函数类型、array 数组类型、date 日期类型、regexp 正则
- wxs 不支持类似于 ES6 及以上的语法形式
  - 不支持：let、const、解构赋值、展开运算符、箭头函数、对象属性简写、etc.
  - 支持：var 定义变量、普通 function 函数等类似于 ES5 的语法
- wxs 遵循 CommonJS 规范
  - module 对象
  - require() 函数
  - module.exports 对象



## 3. 内嵌 wxs 脚本

wxs 代码可以编写在 wxml 文件中的 `<wxs>` 标签内，就像 Javascript 代码可以编写在 html 文件中的 `<script> ` 标签内一样。



wxml 文件中的每个 `<wxs></wxs>`，必须提供 module 属性，用来指定当前 wxs 的模块名称，方便在 wxml 中访问模块中的成员：

~~~html
<view>{{m1.toUpper(username)}}</view>

<wxs module="m1">
	// 将文本转换为大写
    module.exports.toUpper = function(str) {
	    return str.toUpperCase()
    }
</wxs>
~~~



## 4. 外联 wxs 脚本

wxs 代码还可以编写在以 .wxs 为后缀名的文件内，就像 javascript 代码可以编写在以 js 为后缀名的文件中一样。示例代码如下：

~~~js
// utils/tools.wxs 文件
function toLower(str){
    return str.toLowerCase()
}

module.exports = {
    toLower: toLower
}
~~~



在wxml 中引入外联的 wxs 脚本时，必须为`<wxs>`标签添加 module 和 src 属性，其中：module 用来指定模块的名称，src 用来指定要引入的脚本的路径，且必须是相对路径。



示例代码如下：

~~~html
<!-- 调用 m2 模块中的方法 -->
<view>{{m2.toLower(country)}}</view>

<!-- 引用外联的 tools.wxs 脚本, 并命名为 m2 -->
<wxs src="../../utilstools.wxs" module="m2"></wxs>
~~~



## 5. wxs 特点

- 与 js 是不同的语言
- 不能作为组件的事件回调
- 隔离性
  - wxs 不能调用 js 文件中定义的函数
  - wxs 不能调用小程序 API
- 性能好
  - iOS 中小程序内的 wxs 比 js 快 2-20倍
  - Android 无太大速度差异



# 自定义组件

## 1. 创建自定义组件

在项目的根目录中，鼠标右键，创建components->test文件夹

在新建的 components -> test 文件夹上，鼠标右键，点击“新建 Component

键入组件的名称之后回车，会自动生成组件对应的4个文件，后缀名分别为 js, json, wxml 和 .wxss



注意：为了保证目录结构的清晰，建议把不同的组件，存放到单独的目录中，例如：

![image-20220507165603428](images/mini_program/image-20220507165603428.png)



## 2. 引用组件

组件的引用方式分为“局部引用”和“全局引用”，顾名思义：

- 局部引用：组件只能在当前被引用的页面内使用
- 全局引用：组件可以在每个小程序页面中使用



### 1. 局部引用

在页面的 json 配置文件中引用组件的方式，叫做 “局部引用” 。示例代码如下：

~~~json
// 在页面的 json 文件中引入组件
{
    "usingComponents": {
        "my-test1":"/components/test/test"
    }
}
~~~



在页面的 wxml 中使用自定义组件

~~~html
<!-- 页面结构 -->
<my-test1></my-test1>
~~~



### 2. 全局引用

在 app.json 全局配置文件中引用组件的方式，叫做 “全局引用” 。示例代码如下：

~~~json
// 在 app.json 文件中，引入组件
{
    "pages": [ /* 省略不必要的代码 */ ],
    "window": { /* 省略不必要的代码 */ },
    "usingComponents": {
        "my-test2": "/components/test2/test2"
    }
}
~~~



在任何页面中的 .wxml 文件中，都可以使用组件

~~~html
<my-test2></my-test2>
~~~



## 3. 全局组件 vs 局部组件

根据组件的使用频率和范围，来选择合适的引用方式：

- 如果某组件在多个页面中经常被用到，建议进行“全局引用"
- 如果某组件只在特定的页面中被用到，建议进行“局部引用'”



## 4. 组件和页面的区别

从表面来看，组件和页面都是由 js、json、.wxml 和 .wxss 这四个文件组成的。但是，组件和页面的 js 与 json 文件有明显的不同：

- 组件的 .json 文件中需要声明 `"component": true` 属性
- 组件的 js 文件中调用的是 Component() 函数
- 组件的事件处理函数需要定义到 methods 节点中



## 5. 组件样式隔离

默认情况下，自定义组件的样式只对当前组件生效，不会影响到组件之外的 UI 结构，如图所示：

- 组件A的样式不会影响组件C的样式
- 组件A的样式不会影响小程序页面的样式
- 小程序页面的样式不会影响组件A和C的样式



![image-20220507170924892](images/mini_program/image-20220507170924892.png)



好处：

- 防止外界的样式影响组件内部的样式
- 防止组件的样式破坏外界的样式



注意：

- app.wxss 中的全局样式对组件无效
- 只有 class 选择器会有样式隔离效果，id选择器、属性选择器、标签选择器不受样式隔离的影响

> 建议：在组件和引用组件的页面中建议使用 class 选择器，不要使用 id、属性、标签选择器



默认情况下，自定义组件的样式隔离特性能够防止组件内外样式互相干扰的问题。但有时，我们希望在外界能够控制组件内部的样式，此时，可以通过stylelsolation 修改组件的样式隔离选项，用法如下：

~~~js
// 在组件的 .js 文件中新增如下配置

Component({
    options:{
        styleIsolation:'isolated'
    }
})

// 或在组件的.json文件中新增如下配置
{
    "styleIsolation":"isolated"
}
~~~



styleIsolation 可选值

![image-20220507171725473](images/mini_program/image-20220507171725473.png)



## 6. 数据 data

在小程序组件中， 用于组件模板渲染的私有数据，需要定义到 data 节点中，示例如下：

~~~js
Component({
    data: {
        count: 0
    }
})
~~~



## 7. 方法 method

在小程序组件中，事件处理函数和自定义方法需要定义到 methods 节点中，示例代码如下：

~~~js
Component({
    // 组件的方法列表（包含事件处理函数和自定义方法）
    methods: {
        addCount() {		// 事件处理函数
            this.setData({ count: this.data.count + 1})
            this._showCount()		// 通过 this 直接调用自定义方法
        },    
        _showCount(){		// 自定义方法建议以 _ 开头
            wx.showToast({
                title: 'count值为:' + this.data.count,
                icon: 'none'
            })
        }
    }
})
~~~

> 自定义方法即没有被任何组件绑定事件的函数



## 8. 属性 properties

### 1. 定义组件 propertites

在小程序组件中，properties 是组件的对外属性，用来接受外界传递到组件中的数据，示例代码如下：

~~~js
Component({
    // 完整属性定义
    properties:{
        max: {
            type: Number,		// 属性值的数据类型
            value: 10			// 属性值的默认值
        }
    }
})
~~~



在 wxml 中，使用组件时，可以对组件进行传值

~~~html
<my-test1 max="5"></my-test1>
~~~

> 如果没有对组件进行传值，则 max 使用默认值 10



另外 properties 也有简化写法，简化写法没有默认值，只能定义数据类型，在 wxml 使用组件的时候，必须对组件进行传值

~~~js
Component({
    // 简化属性定义
    properties:{
        max: Number
    }
})
~~~



### 2. 页面对组件进行传值

在 info 页面，将 data 中的 max 值传递到组件中

- 在组件中定义 properties

~~~js
    properties: {
        max:{
            type: Number,
            value: 10
        }
    },
~~~



- 在组件中渲染该组件

~~~html
<view>{{max}}</view>
~~~



- 在 info.js 中，定义 data 中的 max 值

~~~js
    data: {
        colorList:[],
        isLoading: false,
        max: 99
    },
~~~



- 在 info.wxml 中，使用组件，并将 data 值传递给组件

~~~html
<my-test1 max="{{max}}"></my-test1>
~~~



### 3. data 与 properties 的区别：

在小程序的组件中， properties 属性和 data 数据的用法相同，他们都是可读可写的，只不过：

- data 更倾向于存储组件的私有数据
- propertites 更倾向于存储外界传递到组件中的数据

> 小程序中组件中的 this.data 和 this.properties 引用的是同一个对象



### 4. 使用 setData 修改 properties 值

由于 data 数据和 properties 属性在本质上没有任何区别，因此 properties 属性的值也可以用于页面渲染，或使用 setData 为 properties 中的属性重新赋值，



示例代码如下：

~~~html
<!-- 组件的 .wxml 文件中使用 properties 属性的值 -->
<view> count 属性的值为：{{count}}</view>
<button bindTap="addCount">+1</button>
~~~



~~~js
Component({
	properties: {count: Number},
    methods: {
        addCount(){
            this.setData({count: this.properties.count + 1})	// 使用 setData 修改属性的值
        }
    }
})
~~~



## 9. 数据监听器

数据监听器用于监听和响应任何属性和数据字段的变化，从而执行特定的操作。它的作用类似于 Vue 中的 watch 侦听器。在小程序组件中，数据监听器的基本语法格式如下：

~~~js
Component({
    observers: {
        '字段A， 字段B': function(字段A的新值，字段B的新值){
            // do something
        }
    }
})
~~~



### 1. 定义监听器

组件 UI 结构：

~~~html
<view>{{n1}} + {{n2}} = {{sum}}</view>
<button size="mini" bindtap="addN1">n1自增</button>
<button size="mini" bindtap="addN2">n2自增</button>
~~~



组件的 js 代码

~~~js
Component({
    // 数据节点
    data: {n1: 0, n2:0, sum:0 }   
    methods:{
    addN1(){ this.setData({n1: this.data.n1 + 1})},
    addN2(){ this.setData({n2: this.data.n2 + 1})}    
},
    // 数据监听节点
    observers: {
        'n1, n2': function(n1, n2){			// 监听 n1 和 n2 的数据变化
            this.setData({ sum: n1+ n2})	// 通过监听器，自动计算 sum 值
        }
    }
})
~~~



### 2. 监听对象属性

数据监听器支持监听对象中单个或多个属性的变化，示例语法如下：

~~~js
Component({
    observers: {
        '对象.属性A， 对象.属性B': function(属性A的新值，属性B的新值){
            // 触发此监听器的 3种情况：
            // 【为属性A赋值】 使用 setData 设置 this.data.对象.属性A 时触发
            // 【为属性B赋值】 使用 setData 设置 this.data.对象.属性B 时触发
            // 【直接为对象赋值】 使用 setData 设置 this.data.对象 时触发           
            // do something
        }
    }
})
~~~

> 注意：如果监听的是对象，而 setData 改变值的是对象的属性，则不会触发监听器



### 3. 使用通配符

如果需要监听所有子数据字段的变化，可以使用通配符 `**` ，仅使用通配符 `**` 可以监听全部 setData 。



通配符相当于在 Vue 中开启了 deep ，如： `rgb.**` 就是监听 rgb 对象中所有字段的改变

~~~js
observers:{
    'some.field.**': function(field) {
        // 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发
        // 除此以外，使用 setData 设置 this.data.some 也会触发
        field === this.data.some.field
    },
    '**': function() {
        // 每次 setData 都触发
    },
}
~~~



### 4. 案例

创建组件，动态监听 rgb 对象中的属性值，属性值变化，fullColor 随之改变



- 创建 test1 组件，全局引用

~~~js
  "usingComponents": {
      "my-test1":"/components/test1/test1"
  }
~~~



在 message 中页面中使用组件

~~~html
<my-test1></my-test1>
~~~



在 test1.js 组件中定义数据

~~~js
    data: {
        // 颜色对象
        rgb: {
            r:0,
            g:0,
            b:0
        },
        fullColor: '0, 0, 0'    // 根据 rgb 对象的三个属性的变化，动态计算 fullColor 的值
    },
~~~



定义组件 UI 结构

~~~html
<view style="background-color: rgb({{fullColor}});" class="colorBox">颜色值：({{fullColor}})</view>
<button size="mini" bindtap="changeR" type="default">R</button>
<button size="mini" bindtap="changeG" type="primary">G</button>
<button size="mini" bindtap="changeb" type="warn">B</button>
~~~



定义组件 CSS 

~~~css
.colorBox {
    line-height: 200rpx;
    color: white;
    text-shadow: 1px 1px 5px #000;
    text-align: center;
}
~~~



在组件 js 中添加方法，每点击一次按钮，颜色自增 +5

~~~js
    methods: {
        changeR(){
            this.setData({
                "rgb.r": this.data.rgb.r + 5 > 255 ? 255 : this.data.rgb.r + 5
            })
        },
        changeG(){
            this.setData({
                "rgb.g": this.data.rgb.g + 5 > 255 ? 255 : this.data.rgb.g + 5
            })
        },
        changeB(){
            this.setData({
                "rgb.b": this.data.rgb.b + 5 > 255 ? 255 : this.data.rgb.b + 5
            })
        },
    }
~~~



由于无法在调试器中查看组件内部 data 值，可以在组件上直接渲染出 rgb 对象中属性的值：

~~~html
<view>rgb:{{rgb.r}},{{rgb.g}},{{rgb.b}}</view>
~~~



监听对象中属性的变化，当 rgb 对象中属性产生变化时，那么 fullColor 也重新生成新值

~~~js
    observers:{
        'rgb.r, rgb.g, rgb.b':function(r,g,b){
            this.setData({
                fullColor: `${r}, ${g}, ${b}`
            })
        }
    }
~~~



可以使用通配符直接监听 rgb 对象中所有属性变化，但是此时拿到的值则是一个对象，而不是单独的值

~~~js
    observers:{
        'rgb.**':function(obj){
            this.setData({
                fullColor: `${obj.r}, ${obj.g}, ${obj.b}`
            })
        }
    }
~~~



## 10. 组件中纯数据字段

纯数据字段指的是那些不用于界面渲染的 data 字段

应用场景：例如有些情况下，某些data中的字段既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。带有这种特性的 data 字段适合被设置为纯数据字段。



比如之前案例中的 rgb 对象，我们只需要用它来进行计算，而在页面中渲染的是 fullColor，所以 rgb 对象可有看做一个纯数据字段



好处：纯数据字段有助于提升页面更新的性能



使用规则：

在 Component 构造器的 options 节点中，指定 pureDataPattern 为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段，示例代码如下：

~~~js
Component({
    options:{
        // 指定所有 _ 开头的数据字段为纯数据字段
        pureataPattern: /^_/
    },
    data: {
        a: true, 	// 普通数据字段
        _b: true	// 纯数据字段
    }
})
~~~



更改之前的案例：

~~~js
Component({
    // 添加纯数据字段正则匹配
    options:{
        pureDataPattern: /^_/
    },
        data: {
        // 纯数据字段
        _rgb: {
            r:0,
            g:0,
            b:0
        },
        fullColor: '0, 0, 0'    // 普通字段
    },
})
~~~



更改 methods 与 observers 中的字段

~~~js
 methods: {
        changeR(){
            this.setData({
                "_rgb.r": this.data._rgb.r + 5 > 255 ? 255 : this.data._rgb.r + 5
            })
        },
        changeG(){
            this.setData({
                "_rgb.g": this.data._rgb.g + 5 > 255 ? 255 : this.data._rgb.g + 5
            })
        },
        changeB(){
            this.setData({
                "_rgb.b": this.data._rgb.b + 5 > 255 ? 255 : this.data._rgb.b + 5
            })
        },
    },
    observers:{
        '_rgb.**':function(obj){
            this.setData({
                fullColor: `${obj.r}, ${obj.g}, ${obj.b}`
            })
        }
    }
~~~



最后注意：纯数据字段无法在组件中进行渲染，即，下边这行的数据则不会渲染在页面上。

~~~html
<view>rgb:{{rgb.r}},{{rgb.g}},{{rgb.b}}</view>
~~~



## 11. 组件的生命周期

### 1. 组件的生命周期

小程序可用的全部生命周期如下表所示：

![image-20220508212800917](images/mini_program/image-20220508212800917.png)



在小程序组件中，最重要的生命周期函数有3个，分别是 created、attached、detached。它们各自的特点如下：

- 组件实例刚被创建好的时候，created 生命周期函数会被触发
  - 此时还不能调用 setData
  - 通常在这个生命周期函数中，只应该用于给组件的 this 添加一些自定义的属性字段
- 在组件完全初始化完毕、进入页面节点树后，attached 生命周期函数会被触发
  - 此时，this.data 已被初始化完毕
  - 这个生命周期很有用，绝大多数初始化的工作可以在这个时机进行（例如发请求获取初始数据）
- 在组件离开页面节点树后，detached 生命周期函数会被触发
  - 退出一个页面时，会触发页面内每个自定义组件的 detached 生命周期函数
  - 此时适合做一些清理性质的工作



#### lifetime 节点

在小程序组件中，

- 声明周期函数可以直接定义在 Component 构造器的第一级参数中，
- 也可以在 lifetimes 字段内进行声明（推荐，优先级最高）



~~~js
Component({
    // 推荐用法
    lifetimes:{
        attached(){},	
        detached(){},
    }
})
~~~



~~~js
Component({
    // 旧版定义方式
    attached(){},	
    detached(){},
})
~~~



### 2. 组件所在页面的生命周期

有时，自定义组件的行为依赖于页面状态的变化，此时就需要用到组件所在页面的生命周期。

在自定义组件中，组件所在页面的生命周期函数有如下3个，分别是：

![image-20220508215049104](images/mini_program/image-20220508215049104.png)



#### pageLifetimes 节点

~~~js
Component({
    pageLifetimes: {
        show: function(){},			// 页面被展示
        hide: function(){},			// 页面被隐藏
        resize: function(size){}	// 页面尺寸变化
    }
})
~~~



例如：每当触发页面的 show 生命周期函数的时候，我们希望能够重新生成一个随机的 RGB 颜色值。

- 在 methods 中定义新的方法

~~~js
methods:{
    _randomColor(){
        this.setData({
            _rgb:{
                r: Math.floor(Math.random()*256),
                g: Math.floor(Math.random()*256),
                b: Math.floor(Math.random()*256),
            }
        })
    }        
~~~



- 在 pageLifetimes 节点中的 show 生命周期函数里调用 _randomColor()

~~~js
    pageLifetimes:{
        show(){
            this._randomColor()
        }
    }
~~~



## 12. 插槽

在自定义组件的 wxml 结构中，可以提供一个`<slot>`节点（插槽)，用于承载组件使用者提供的 wxml 结构。

![image-20220508215932341](images/mini_program/image-20220508215932341.png)



### 1. 单个插槽

在小程序中，默认每个自定义组件中只允许使用一个 `<slot>` 进行占位，这种个数上的限制叫做单个插槽。



- 在 my-test2 组件中使用 slot 标签占位

~~~html
<view>
    <view>这里是组件的内部节点</view>
    <!-- 对于不确定的内容，可以使用 <slot> 进行占位，具体的内容由组件的使用者决定 -->
    <slot></slot>
</view>
~~~



- 在页面中调用组件，并给 slot 传值

~~~html
<my-test2>
    <!-- 以下节点内容将被放到 slot 插槽中 -->
    <view>这里是页面中对 slot 插槽填充的内容</view>
</my-test2>
~~~



### 2. 多个插槽

在小程序的自定义组件中，需要使用多`<slot>` 插槽时，可以在组件的 js 文件中，需要在组件中的 options 节点中，添加 multipleSlots 属性

示例代码如下：

~~~js
options:{
    multipleSlots: true
}
~~~



在组件中的 wxml 中，使用多个 slot 标签，以不同的 name 来区分不同的插槽，示例代码如下：

~~~html
<view>
    <slot name="before"></slot>
    <view>这里是组件的内部节点</view>
    <slot name="after"></slot>
</view>
~~~



页面使用组件，给插槽传入自定义内容

~~~html
<my-test2>    
    <view slot="before">这里是 before 插槽内容</view>
    <view slot="after">这里是 after 插槽内容</view>
</my-test2>
~~~



## 13. 组件之间通信

父子组件之间通信的 3种方式：

- 属性绑定
  - 用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容的数据
- 事件绑定
  - 用于子组件向父组件传递数据，可以传递任意数据
- 获取组件实例
  - 父组件还可以通过 this.selectComponent() 获取子组件的实例对象
  - 这样就可以直接访问子组件的任意数据和方法



### 1. 属性绑定（父向子传值）

属性绑定用于实现父向子传值，而且只能传递普通类型的数据，无法将方法传递给子组件。父组件的示例代码如下：



- 父组件 js 中定义 data

~~~js
data: {
    count: 0,
},
~~~



- 子组件中定义 properties

~~~js
properties: {
    count: Number
},
~~~



- 子组件 UI 结构

~~~html
<view>子组件中 Count 值: {{count}}</view>
~~~



- 父组件 UI 结构

~~~html
<my-test3 count="{{count}}"></my-test3>
<view>父组件中，count 值：{{count}}</view>
~~~



### 2. 事件绑定（子向父传值）

事件绑定用于实现子向父传值，可以传递任何类型的数据。使用步骤如下：

- 在父组件的中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件
- 在父组件的 wxml 中，通过自定义事件的形式，将步骤 1 中定义的函数引用，传递给子组件
- 在子组件的 js 中，通过调用 `this.triggerEvent(自定义事件名称',{/*参数对象*/})`，将数据发送到父组件
- 在父组件的 js 中，通过 e.detail 获取到子组件传递过来的数据



在子组件中创建一个按钮，绑定 addCount 事件，通过点击按钮，让子组件中的 count 值自增

~~~html
<view>子组件中 Count 值: {{count}}</view>
<button type="primary" bindtap="addCount"> +1 </button>
~~~



子组件中 js 文件中定义事件函数

~~~js
methods: {
    addCount(){
        this.setData({
            count: this.properties.count + 1
        })
    }
}
~~~



我们点击按钮，发现子组件中的 count 值自增，但是父组件中的 count 没有变化，我们需要让子组件向父组件进行传值

- 步骤一： 父组件中 js 中定义一个函数

~~~js
    // 在父组件中定义 syncCount 方法
    // 之后，这个方法会被传递给子组件，供子组件进行调用
    syncCount(){
        console.log('syncCount');
    }
~~~



- 步骤二：在父组件的 wxml 中，通过自定义事件的形式，将步骤1中定义的函数引用，使用 bind 属性传递给子组件，方法有两种：

~~~html
<!-- 使用 bind: 自定义事件名称（推荐：结构清晰） -->
<my-test3 count="{{count}}" bind:sync="syncCount"></my-test3>
<!-- 或在 bind 后边直接写上自定义事件名称 -->
<my-test3 count="{{count}}" bindsync="syncCount"></my-test3>
~~~

> 即传递过去的函数是我们刚才在页面中定义的函数 syncCount，绑定的事件名称为 sync



- 步骤三：在子组件 js 中，通过调用 `this.triggerEvent('自定义事件名称',{/* 参数对象 */ })`， 将数据发送到父组件

~~~js
addCount(){
    this.setData({
        count: this.properties.count + 1
    })
    // 在子组件 count 值改变后，触发父组件传递过来的 sync 事件
    // 并将子组件的数据当做参数传递到这个事件函数中
    this.triggerEvent('sync', {value: this.properties.count})
}
~~~

> 相当于执行了父组件中的 `syncCount({value:this.properties.count})` 这个函数，只不过这个函数是通过 triggerEvent 来调用的。



- 步骤四：在父组件的 js 中，通过 e.detail 获取到子组件传递过来的数据

~~~js
    syncCount(e){
        console.log('e');
    }
~~~



由于传递过来的参数是一个对象，所以在 detail 中是以键值对形式保存的

![image-20220509130635374](images/mini_program/image-20220509130635374.png)



如果传递过来的参数只是一个数值，如： `syncCount(this.properties.count)`，那么 e.detail 的值也是一个数值，如：

![image-20220509130907558](images/mini_program/image-20220509130907558.png)



- 步骤五：我们只需要在 syncCount 函数中，重新用 setData 对父组件中的 Count 赋值即可完成子组件对父组件数据的传递工作

~~~js
    syncCount(e){
        this.setData({
            count: e.detail.value
        })
    },
~~~



### 3. 获取组件实例（双向传值）

可以在父组件中调用 this.selectComponent("id或class选择器")，获取子组件的实例对象，从而直接访问子组件的任意数据和方法。调用时需要传入一个选择器，例如： this.selectComponent(".my-component")



在父组件中定义 UI 结构，在渲染子组件时，给该组件绑定 class 或  id

~~~html
<my-test3 count="{{count}}" bind:sync="syncCount" class="customA" id="CA"></my-test3>
~~~



在父组件中定义一个按钮，绑定 getChild 事件

~~~html
<button bindtap="getChild">获取子组件实例</button>
~~~



在父组件 js 中，定义 getChild 函数，获取子组件实例

~~~js
    getChild(){
        const child = this.selectComponent('.customA')  // 也可以传递 id 选择器 CA
        console.log(child);
    },
~~~

> 注意不要写错了 selectAllComponent 返回的是数组



通过获取组件实例

- 父组件可以获取子组件的数据（子向父传值）

~~~js
this.setData({count: child.properties.count})
~~~

> 父组件使用的 this.setData ，指向的是父组件中 setData 方法，改变的也是父组件中的数据，传递的数据是子组件中的 count 值



- 对子组件进行传值

~~~js
child.setData({count: this.data.count})
~~~

> 将父组件中 count 值传递给子组件



同时父组件还可以调用子组件中的自定义方法

~~~js
child.addCount()    // 调用子组件中的 addCount 方法
~~~



### 4. behavior

behavior 是小程序，用于实现组件间代码共享的特性，类似于 Vue.js 中的 mixins

![image-20220509141422289](images/mini_program/image-20220509141422289.png)



每个 behavior 可以包含一组属性、数据、生命周期函数和方法。组件引用它时，它的属性、数据和方法会被合并到组件中。

每个组件可以引用多个 behavior, behavior 也可以引用其它 behavior。.



#### 1. 创建 Behavior

项目根目录创建一个 behaviors 文件夹，然后创建 .js 文件

调用 Behavior(obj) 方法即可创建一个共享的 behavior 实例对象，供所有的组件使用：

~~~js
// 调用 Behavior() 方法， 创建实例对象
// 并使用 module.exports 将 behavior 实例对象共享出去
module.exports = Behavior({
    // behavior 可以包含共享的属性、数据、方法等
    properties:{},
    data:{
        username: 'zs'
    },
    methods:{}
})
~~~



#### 2. 导入 behavior

在自定义 Component 组件中，使用 require() 方法导入需要的 behavior， 挂载后即可访问 behavior 中的数据或方法，实例代码

~~~js
// 使用 require() 导入需要的自定义 behavior 模块
const myBehavior = require("../../behaviors/my-behavior")

Component({
    // 将导入的 behavior 实例对象，挂载到 behaviors 数组节点中，即可生效
    behaviors:[myBehavior]
})
~~~



#### 3. 使用 behavior 中的数据和方法

引入 behavior 后，里边的数据会直接与组件中的数据和方法合并，可以直接调用，如在 wxml 直接渲染 behavior 中的 username 

~~~html
<view>{{username}}</view>
~~~



#### 4. behavior 中可用的节点

![image-20220509143419397](images/mini_program/image-20220509143419397.png)



#### 5. 同名字段的覆盖和组合规则

组件和它用的behavior中可以包含同名的字段，此时可以参考如下3种同名时的处理规则：

- 同名的数据字段(data)
- 同名的属性(properties)或方法(methods),
- 同名的生命周期函数



组件和它引用的 `behavior` 中可以包含同名的字段，对这些字段的处理方法如下：

- 如果有同名的属性 (properties) 或方法 (methods)：
  1. 若组件本身有这个属性或方法，则组件的属性或方法会覆盖 `behavior` 中的同名属性或方法；
  2. 若组件本身无这个属性或方法，则在组件的 `behaviors` 字段中定义靠后的 `behavior` 的属性或方法会覆盖靠前的同名属性或方法；
  3. 在 2 的基础上，若存在嵌套引用 `behavior` 的情况，则规则为：`引用者 behavior` 覆盖 `被引用的 behavior` 中的同名属性或方法。
- 如果有同名的数据字段 (data)：
  - 若同名的数据字段都是对象类型，会进行对象合并；
  - 其余情况会进行数据覆盖，覆盖规则为： `引用者 behavior` > `被引用的 behavior` 、 `靠后的 behavior` > `靠前的 behavior`。（优先级高的覆盖优先级低的，最大的为优先级最高）
- 生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用：
  - 对于不同的生命周期函数之间，遵循组件生命周期函数的执行顺序；
  - 对于同种生命周期函数，遵循如下规则：
    - `behavior` 优先于组件执行；
    - `被引用的 behavior` 优先于 `引用者 behavior` 执行；
    - `靠前的 behavior` 优先于 `靠后的 behavior` 执行；
  - 如果同一个 `behavior` 被一个组件多次引用，它定义的生命周期函数只会被执行一次。



# npm 包

目前，小程序中已经支持使用 npm 安装第三方包，从而来提高小程序的开发效率。但是，在小程序中使用 npm 包有如下3个限制：

- 不支持依赖于Node.js内置库的包
- 不支持依赖于浏览器内置对象的包
- 不支持依赖于C++插件的包



## 1. Vant-Weapp

Vant Weapp 是有赞前端团队开源的一套小程序 UI 组件库，助力开发者快速搭建小程序应用。它所使用的是 MIT 开源许可协议，对商业使用比较友好。

官方文档地址：https://youzan.github.io/vant-weapp



### 1. 安装 Vant 组件库步骤：

- 通过 npm 安装

初始化 npm 包文件管理配置文件 package.json

~~~shell
npm init -y
~~~



- 安装 vant-weapp

~~~shell
# 通过 npm 安装
npm i @vant/weapp@1.3.3 -S --production
~~~



- 修改 app.json

将 app.json 中的 `"style": "v2"` 去除，小程序的新版基础组件强行加上了许多样式，难以覆盖，不关闭将造成部分组件样式混乱。



- 构建 npm 包

打开微信开发者工具，点击 **工具 -> 构建 npm**，并勾选 **使用 npm 模块** 选项，构建完成后，即可引入组件。

![img](images/mini_program/fa0549210055976cb63798503611ce3d.png)

> 新版本小程序开发工具已经不用勾选 使用 npm 模块了，内置自动选中。



### 2. 使用 Vant 组件

安装完 Vant 组件库之后，可以在 app,json 的 usingComponents 节点中引入需要的组件，即可在 wxml 中直接使用组件。示例代码如下：

~~~js
  "usingComponents": {
      "vant-button":"@vant/weapp/button/index"
  }
~~~



在页面中调用组件

~~~html
<van-button type="primary">Vant 按钮</van-button>
~~~



可以在 Vant 文档中查看引用组件路径，以及组件的引用方法

![image-20220509164412743](images/mini_program/image-20220509164412743.png)



### 3. 定制全局主题样式

Vant Weapp 使用 CSS 变量来实现定制主题



关于 CSS 变量，可以通过在根节点定义 CSS 变量，然后使用 var() 来调用定义 CSS 变量，示例代码如下：

~~~html
<style>
    // 根节点定义 CSS 变量
  html {
    --box-color: #efefef;
  }

  .box {
    width: 200px;
    height: 200px;
  }  

  .box {
      // 使用 CSS 变量
    background-color: var(--box-color)
  }

</style>  

  <div class="box"></div>
~~~



更改 Vant 组件样式

在 app.wxss 中，写入 CSS 变量，即可对全局 vant 组件样式生效，如：

~~~js
page{
    /* 定制警告按钮的背景颜色与边框颜色 */
    --button-danger-background-color: #C00000;
    --button-danger-border-color: #C00000;
}
~~~

> page 节点与 html 节点一样，是小程序的顶级节点



定制使用的 CSS 变量 与 Less 变量 同名，下面是一些基本的样式变量，所有可用的颜色变量请参考 [配置文件](https://github.com/youzan/vant-weapp/blob/dev/packages/common/style/var.less)。例：

~~~less
// Component Colors
@text-color: #323233;
@border-color: #ebedf0;
@active-color: #f2f3f5;
@background-color: #f8f8f8;
@background-color-light: #fafafa;
~~~



## 2. 小程序 Promise

### 1. 小程序中的回调地狱

默认情况下，小程序官方提供的异步AP都是基于回调函数实现的，例如，网络请求的AP需要按照如下的方式调用：

~~~js
wx.request({
    method:'',
    url:'',
    data:{},
    success:()=>{},		// 请求成功的回调函数
    fail:()=>{},		// 请求失败的回调函数
    complete:()=>{}		// 请求完成的回调函数
})
~~~



缺点：容易造成回调地狱问题，代码的可读性、维护性差。比如我们需要对网络请求的结果再次进行请求，就需要在 success 的回调中再次发送请求。

~~~js
wx.request({
    method:'',
    url:'',
    data:{},
    success:(res)=>{
        // 在回调中又再次请求
        wx.request(){
            // 省略各种代码
            success:()=>{},
        }
    },		
    fail:()=>{},		
    complete:()=>{}
})
~~~



### 2. API Promise

API Promise 化，指的是通过额外的配置，将官方提供的、基于回调函数的异步API,升级改造为基于 Promise 的异步 API, 从而提高代码的可读性、维护性，避免回调地狱的问题。



在小程序中，实现 API Promise 化主要依赖于 miniprogram-api-promise 这个第三方的 npm 包，它的安装和使用步骤如下：

- 安装 npm 包

~~~shell
npm install -S miniprogram-api-promise
~~~



- 工具->构建 npm 包

> 如果失败，则删除项目根目录下的 miniprogram_npm ，然后再重新构建



- 使用方法

~~~js
// 在小程序入口文件中（app.js），只需调用一次 PromisifyAll() 方法，
// 即可实现异步 API 的 Promise 化
import { promisifyAll } from 'miniprogram-api-promise'

const wxp = wx.p = {}
// promisify all wx's api
promisifyAll(wx, wxp)
~~~

> 调用 promisifyAll 方法，会让 wx 顶级对象下的所有异步 API 转移到 wxp 这个对象中，而 wxp 这个对象又和 wx.p 这个对象指向同一个对象，所以我们在页面或组件中可以使用 wx.p.API 使用 promise 化的 API



示例：定义一个按钮，绑定 getInfo 事件

~~~html
<van-button type="danger" bindtap="getInfo">vant按钮</van-button>
~~~



在页面的 .js 文件中， 定义对应的 tap 事件处理函数

~~~js
// 使用 async 接受
  async getInfo() {
      // 使用 await 
    const { data: res } = await wx.p.request({
      method: 'GET',
      url: 'https://www.escook.cn/api/get',
      data: {name: 'zs', age: 20}
    })
    // 直接拿到回调数据 res
    console.log(res);
  },
~~~



# 全局数据共享

全局数据共享（又叫做：状态管理）是为了解决组件之间数据共享的问题。

开发中常用的全局数据共享方案有：Vuex、Redux、MobX 等。

![image-20220509200734309](images/mini_program/image-20220509200734309.png)



在小程序中，可使用 mobx-miniprogram 配合 mobx-miniprogram-bindings 实现全局数据共享。其中：

mobx-miniprogram用来创建 Store 实例对象 mobx-miniprogram-bindings 用来把 Store 中的共享数据或方法，绑定到组件或页面中使用


## 1. 安装包

在项目中运行如下的命令，安装 MobX 相关的包：

~~~shell
npm install --save mobx-miniprogram@4.13.2 mobx-miniprogram-bindings@1.2.1
~~~



注意：MobX 相关的包安装完毕之后，需要重新构建 npm



## 2. 创建 MobX 的 Store 实例

在页面中 跟 pages 文件夹平级，新建 store 文件夹， 新建 store.js 文件，在其中创建实例

~~~js
import { observable, action } from 'mobx-miniprogram'

// 通过 observable 创建 store 实例并导出
export const store = observable({
  // 数据字段
  numA: 1,
  numB: 2,
  message: 'Store Message'
  // 计算属性
  get sum() {
    return this.numA + this.numB
  },
  // actions 方法，用来修改 store 中的数据
  showMsg: action(function(){
    console.log(this.message)
  }),
  updateNum1: action(function(step) {
    this.numA += step
  }),
  updateNum2: action(function(step) {
    this.numB +=step
  })
})
~~~

> 计算属性是只读的，无法修改该值，因为计算属性的值是通过计算得出的，不需要被重新赋值，



## 3. 将 Store 中的成员绑定到页面中

目前我们只是用了 mobx-miniprogram 创建了 store 实例，我们可以使用 mobx-miniprogram-bindings 将这个实例引入到组件或页面中

~~~js
// pages/home/home.js   页面 .js 文件中
import { createStoreBindings } from 'mobx-miniprogram-bindings'
import { store } from '../../store/store'

Page({
   /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
      // 在页面实例上添加 storeBindings 节点，挂载 store 实例
    this.storeBindings = createStoreBindings(this, {
      store,
      fields: ['numA', 'mumB' , 'sum'],		// 需要将 store 中的哪些数据字段绑定到当前页面
      actions: ['updateNum1', 'showMsg']	// 需要将 store 中的哪些方法绑定到当前页面
    })
  },
    /**
   * 生命周期函数--监听页面卸载
   */
  onUnload: function () {
      // 当页面被卸载时，销毁 storeBindings 节点
    this.storeBindings.destroyStoreBindings()
  },
})
~~~

> 引入 store 后，该页面就可以访问 store 中的 numA，numB，sum，以及 updateNum1 方法



## 4. 在页面上使用 Store 中的成员

在 wxml 中，可以像调用本页面的数据及方法一样调用 store 中的数据和方法

~~~html
<view>{{numA}} + {{numB}} = {{sum}}</view>
<van-button type="danger" bindtap="showMsg">showMsg</van-button>
<van-button type="primary" bindtap="btnHandler1" data-step="{{1}}">numA + 1</van-button>
<van-button type="danger" bindtap="btnHandler1" data-step="{{-1}}">numA - 1</van-button>
~~~

> 传值需要使用 data-* 的形式给 store 里方法中的函数传值



data-* 中的传递参数可以在页面中绑定的事件参数 e.target.dataset.* 中获取

~~~js
// 按钮 tap 事件的处理函数
btnHandler1(e) {
  console.log(e)
}
~~~



![image-20220509213652290](images/mini_program/image-20220509213652290.png)



我们将拿到传递的参数传递给 store 中的方法

~~~js
// 按钮 tap 事件的处理函数
btnHandler1(e) {
  this.updateNum1(e.target.dataset.step)
}
~~~



## 5. 将 Store 中的成员绑定到组件中

~~~js
import { storeBindingsBehavior} from 'mobx-miniprogram-bindings'
import { store } from '../../store/store'

Component({
  behaviors: [storeBindingsBehavior], // 通过 storeBindingsBehavior 来实现自动绑定

  storeBindings: {
	store,                 // 指定要绑定的 Store
	fields: {              // 指定要绑定的字段数据
		numA: () => store.numA,        // 绑定字段的 第一种方式
		numB: (store) => store.numB,   // 绑定字段的 第二种方式
		sum: 'sum'                     // 绑定字段的 第三种方式
	},
	actions: {   // 指定要绑定的方法
		updateNum2: 'updateNum2'
	}
  }
})
~~~

> fields 和 actions 还可以使用对象方式绑定到当前组件，比数组方式好的就是可以自己重新命名



## 6. 在组件中使用 Store 中的成员

~~~html
<view>{{numA}} + {{numB}} = {{sum}}</view>
<van-button type="primary" bindtap="btnHandler2" data-step="{{1}}">
  numA + 1
</van-button>
<van-button type="danger" bindtap="btnHandler2" data-step="{{-1}}">
  numA - 1
</van-button>
~~~



~~~js
// 按钮 tap 事件的处理函数
methods: {
	btnHandler2(e) {
 		 this.updateNum2(e.target.dataset.step)
	}
}
~~~



# 分包

分包指的是把一个完整的小程序项目，按照需求划分为不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载



## 1. 分包的好处

对小程序进行分包的好处主要有以下两点：

- 可以优化小程序首次启动的下载时间
- 在多团队共同开发时可以更好的解耦协作



## 2. 组成部分

分包前，小程序项目中**所有的页面和资源**都被打包到了一起，导致整个**项目体积过大**，影响小程序**首次启动的下载时间**



![image-20220509221451619](images/mini_program/image-20220509221451619.png)



分包后，小程序项目由 `1 个主包` + `多个分包`组成：

- **主包**：一般只包含项目的`启动页面`或 `TabBar 页面`、以及所有分包都需要用到的一些`公共资源`
- **分包**：只包含和当前分包有关的页面和`私有资源`



![image-20220509221537132](images/mini_program/image-20220509221537132.png)

- 主包不能访问分包中的资源
- 分包可以访问到主包中的公共资源
- 分包中的私有资源不能被其他分包访问





## 3. 分包的加载规则

- 在小程序启动时，**默认会下载主包并启动主包内页面**
  - tabBar 页面需要放到主包中
- 当用户进入分包内某个页面时，**客户端会把对应分包下载下来**，下载完成后再进行展示
  - 非 tabBar 页面可以按照功能的不同，划分为不同的分包之后，进行按需下载



## 4. 分包的体积限制

目前，小程序分包的大小有以下两个限制：

1. 整个小程序所有分包大小不超过 **16M**（主包 + 所有分包）
2. 单个分包/主包大小不能超过 **2M**



## 5. 使用分包

1. 小程序目录结构

![image-20220509221920860](images/mini_program/image-20220509221920860.png)



在 `app.json` 的 **subpackages** 节点中 声明分包的结构

~~~json
{
  "pages": [  // 主包的所有页面
    "pages/home/home",
    "pages/message/message",
    "pages/contact/contact"
  ],
  "subpackages": [  // 通过 subpackages 节点， 声明分包结构
    {
      "root": "packageA/pages",  // 第一个分包的 根路径
      "pages": [           // 当前分包下，所有页面的相对存放路径
        "pages/cat/cat",
        "pages/dog/dog"
      ]
    },{
      "root": "packageB/pages",  // 第二个分包的根路径
      "name": "pack2",     // 分包的别名
      "pages": [           // 当前分包下， 所有页面的相对存放路径
        "pages/apple/apple",
        "pages/banana/banana"
      ]
    }
  ],
}
~~~



## 6. 打包原则

1. 小程序会按 **subpackages** 的配置进行分包，subpackages 之外的目录将被打包到主包中
2. 主包也可以有自己的 pages（即最外层的 pages 字段）
3. tabBar 页面必须在主包内
4. 分包之间不能互相嵌套



## 7. 引用原则

1. 主包**无法引用**分包内的私有资源
2. 分包之间**不能相互引用**私有资源
3. 分包**可以引用**主包内的公共资源



## 8. 分包 - 独立分包

独立分包 **本质上也是分包**，只不过它比较特殊，**可以独立于主包和其他分包而单独运行**。



独立分包和普通分包的最主要的区别：**是否依赖于主包才能运行**

1. 普通分包必须依赖于主包才能运行
2. 独立分包可以在不下载主包的情况下，独立运行



独立分包的应用场景

开发者可以按需，将某些具有一定功能独立性的页面配置到独立分包中。原因如下：

- 当小程序从普通的分包页面启动时，需要首先下载主包
- 而独立分包不依赖主包即可运行，可以很大程度上提升分包页面的启动速度

> 注意：一个小程序中可以有 多个 独立分包。



独立分包的配置方法

首先 目录结构是一样的，只需要在普通分包中， 添加 一个 “independent”: true，通过此节点， 声明当前 分包 为 独立分包

~~~json
{
  "pages": [  // 主包的所有页面
    "pages/home/home",
    "pages/message/message",
    "pages/contact/contact"
  ],
  "subPackages": [  // 通过 subpackages 节点， 声明分包结构
    {
      "root": "packageA/pages",  // 第一个分包的 根路径
      "pages": [           // 当前分包下，所有页面的相对存放路径
        "pages/cat/cat",
        "pages/dog/dog"
      ]
    },{
      "root": "packageB/pages",  // 第二个分包的根路径
      "name": "pack2",     // 分包的别名
      "pages": [           // 当前分包下， 所有页面的相对存放路径
        "pages/apple/apple",
        "pages/banana/banana"
      ]，
     "independent": true   // 通过此节点，声明当前 分包 为 独立分包
    }
  ],
}
~~~



引用原则

独立分包和普通分包以及主包之间，是**相互隔绝的，不能相互引用彼此的资源**！

例如：

1. 主包`无法引用`独立分包内的私有资源
2. 独立分包之间，`不能相互引用`私有资源
3. 独立分包和普通分包之间，`不能相互引用`私有资源
4. `特别注意`：独立分包中不能引用主包内的公共资源



## 9. 分包 - 分包预下载

分包预下载指的是：在进入小程序的某个页面时，**由框架自动预下载可能需要的分包**，从而提升进入后续分包页面时的启动速度。



配置分包的预下载

**预下载分包的行为，会在进入指定的页面时触发**。在 **app.json** 中，使用 **preloadRule** 节点定义分包的预下载规则，示例代码如下：

~~~json
// app.json
"preloadRule": { // 分包预下载的规则
	"pages/contact/contact": {  // 触发分包预下载的页面路径
		// network 表示 在指定的网络模式下 进行预下载
		// 可选值为：all（不限制网络）和 wifi （仅在 wifi 模式下下载）
		// 默认值 为  wifi
		"network": "all",
		// packages 表示进入页面后， 预下载哪些分包
		// 可以通过 root 或 name 指定预下载哪些分包
		"packages": ["pkgA"]
	}
}
~~~



分包预下载的限制

同一个分包中的页面享有 **共同的预下载大小限额 2M**，

1. 不允许，分包 A+B+C 体积大于 2M
2. 允许，分包 A+B+C 体积小于 2M



# 案例：自定义 tabBar

在此案例中，用到的主要知识点如下：

- 自定义组件
- Vant 组件库
- MobX 数据共享
- 组件样式隔离
- 组件数据监听器
- 组件的 behaviors
- Vant 样式覆盖



实现步骤

自定义 tabBar 分为 3 大步骤，分别是：

- 配置信息
- 添加 tabBar 代码文件
- 编写 tabBar 代码



详细步骤，可以参考小程序官方给出的文档：
https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html



## 1. 配置信息

- 在 `app.json` 中的 `tabBar` 项指定 `custom` 字段，同时其余 `tabBar` 相关配置也补充完整。
- 所有 tab 页的 json 里需声明 `usingComponents` 项，也可以在 `app.json` 全局开启。

~~~json
"tabBar": {
    "custom": true,
    "position": "bottom",
    "color": "#000000",
    "selectedColor": "#C00000",
    "list": [
        {
            "pagePath": "pages/index/index",
            "text": "首页",
            "iconPath": "/static/icon/home.png",
            "selectedIconPath": "/static/icon/home-active.png"
        },
        {
            "pagePath": "pages/message/message",
            "text": "消息",
            "iconPath": "/static/icon/message.png",
            "selectedIconPath": "/static/icon/message-active.png"
        },
        {
            "pagePath": "pages/contact/contact",
            "text": "消息",
            "iconPath": "/static/icon/contact.png",
            "selectedIconPath": "/static/icon/contact-active.png"
        }
    ]
},
~~~

> 即使使用自定义 tabBar，为了保证低版本兼容，list 节点也需要完整保存。



## 2. 添加 tabBar 代码文件

在代码根目录下添加入口文件:

- 创建 custom-tab-bar 文件夹，然后创建 index 组件即可自动生成以下文件

~~~
custom-tab-bar/index.js
custom-tab-bar/index.json
custom-tab-bar/index.wxml
custom-tab-bar/index.wxss
~~~



## 3. 编写 tabBar 代码

实际上这个 custom tabBar 就是一个组件，所以我们可以按照组件的形式来写。

在 Vant 中，提供了 tabBar 的组件效果，我们可以直接拿来使用，如：



### 1. 引入

在`app.json`或`index.json`中引入组件

~~~json
"usingComponents": {
  "van-tabbar": "@vant/weapp/tabbar/index",
  "van-tabbar-item": "@vant/weapp/tabbar-item/index"
}
~~~



### 2. 写入结构

然后在 custom-tab-bar 中的 wxml 文件中写入结构代码：

~~~html
<van-tabbar active="{{ active }}" bind:change="onChange">
  <van-tabbar-item icon="home-o">标签</van-tabbar-item>
  <van-tabbar-item icon="search">标签</van-tabbar-item>
  <van-tabbar-item icon="friends-o">标签</van-tabbar-item>
  <van-tabbar-item icon="setting-o">标签</van-tabbar-item>
</van-tabbar>
~~~



### 3. 绑定事件

js 文件中添加绑定数据，以及组件方法 

~~~json
data: {
    active: 0
},
methods: {
    onChange(event) {
        // event.detail 的值为当前选中项的索引
        this.setData({ active: event.detail });
    },
}
~~~

> 通过事件绑定，我们点击拿个标签栏，就会返回一个事件参数 event，event.detail 中保存着当前标签的索引值，将索引值赋值给绑定的数据 active



## 4. 自定义图标

可以通过 slot 自定义图标，其中 icon slot 代表未选中状态下的图标，icon-active slot 代表选中状态下的图标。

~~~html
<van-tabbar active="{{ active }}" bind:change="onChange">
  <van-tabbar-item>
    <image
      slot="icon"
      src="/static/icon/home.png"
      mode="aspectFit"
      style="width: 30px; height: 18px;"
    />
    <image
      slot="icon-active"
      src="/static/icon/home-active.png"
      mode="aspectFit"
      style="width: 30px; height: 18px;"
    />
    首页
  </van-tabbar-item>
  <van-tabbar-item icon="search">标签</van-tabbar-item>
  <van-tabbar-item icon="setting-o">标签</van-tabbar-item>
</van-tabbar>
~~~



我们可以通过循环方式，将 list 中的几个标签栏都渲染出来，先将 list 数据添加到 data 中

~~~html
<van-tabbar active="{{ active }}" bind:change="onChange">
  <van-tabbar-item wx:for="{{list}}" wx:key="index">
    <image
      slot="icon"
      src="{{item.iconPath}}"
      mode="aspectFit"
      style="width: 25px; height: 25px;"
    />
    <image
      slot="icon-active"
      src="{{item.selectedIconPath}}"
      mode="aspectFit"
      style="width: 25px; height: 25px;"
    />
    {{item.text}}
  </van-tabbar-item>
</van-tabbar>
~~~



## 5. 添加徽标

只需要在 van-tabbar-item 中添加 info 属性就可以在自定义标签栏上添加消息徽标，如：

~~~html
  <van-tabbar-item wx:for="{{list}}" wx:key="index" info="5">
~~~



## 6. 修改徽标样式

目前标签栏 + 徽标有点超出底部容器区域，所以我们需要更改一下 vant 组件样式



我们可以看到在 van-tabbar-item__icon 这个类中有个 margin-bottom 样式

~~~css
margin-bottom: var(--tabbar-item-margin-bottom,5px);
~~~

> 可以看到样式是使用 css 变量来赋值的，如果有值则使用 --tabbar-item-margin-bottom 的值，如果没有则使用默认 5px



我们可以直接在组件的 css 中，使用 css 变量给 --tabbar-item-margin-bottom 一个值即可，使用 var 至少要在元素的高一级的节点（或顶级节点）

~~~css
.van-tabbar-item {
    --tabbar-item-margin-bottom: 0;
}
~~~



然后我们还需要在组件中开启样式覆盖

~~~js
Component({
    options:{
        styleIsolation: 'shared'        
    },
})
~~~



## 7. 指定栏目徽标

目前的徽标在所有标签栏中都显示，如果我们需要给指定标签栏添加徽标，我们可以在 list 中添加属性 info，然后利用三元表达式判断来加载徽标

~~~js
  <van-tabbar-item wx:for="{{list}}" wx:key="index" info="{{item.info ? item.info : ''}}">
~~~

> 实际上直接写 {{item.info}} 也可以



## 8. mobX 传递数据改变徽标

创建一个 store/store.js 

~~~js
import { observable, action } from 'mobx-miniprogram'

export const store = observable({
  // 数据字段
  num: 0,
  // 更新数据方法
  updateNum: action(function(step) {
    this.num += step
  })
})
~~~



创建组件 UI 结构

~~~html
<view>消息数量：{{num}}</view>
<van-button type="primary" bindtap="btnHandler" data-step="{{1}}">+1</van-button>
<van-button type="primary" bindtap="btnHandler" data-step="{{-1}}">-1</van-button>
~~~



在自定义组件中导入 store 数据

~~~js
// components/test4/test4.js
import { storeBindingsBehavior} from 'mobx-miniprogram-bindings'
import { store } from '../../store/store'
Component({
    behaviors: [storeBindingsBehavior], // 通过 storeBindingsBehavior 来实现自动绑定

    storeBindings: {
	    store,                 // 指定要绑定的 Store
	    fields: ['num'],
	    actions: ['updateNum']
    },
    methods: {
        btnHandler(e) {
            this.updateNum(e.target.dataset.step)
      }

    }
})
~~~

> 当点击按钮时，会触发组件中的 btnHandler 事件，从而调用 store 中的方法 updateNum，并将参数以 event 形式传递给 store



在 message 中引用组件

~~~html
<my-test4></my-test4>
~~~



然后我们还需要在 tabBar 组件中同步 num 数据

~~~js
import { storeBindingsBehavior} from 'mobx-miniprogram-bindings'
import { store } from '../store/store'

Component({
    behaviors: [storeBindingsBehavior], // 通过 storeBindingsBehavior 来实现自动绑定

    storeBindings: {
        store,                 // 指定要绑定的 Store
        fields: ['num'],
    },
    // ... 其他配置项
    observers:{
        'num': function(val){
            this.setData({
                'list[1].info': val
            })
        }
    }
})

~~~

> 只需要监听 store 中的 num 然后执行更新 list 中消息标签栏中的 info 属性



![image-20220511192407238](images/mini_program/image-20220511192407238.png)



## 9. tabBar 切换效果

当点击 tabBar 图标时，会触发绑定在 tabBar 上的 onChange 事件，通过 onChange 事件，我们可以通过 event 拿到当前 tabBar 选项的索引值，通过索引值，我们可以拿到 list 中 tabBar 选项的 url 地址，通过调用 switchTab API 切换 tabBar 

~~~js
onChange(event) {
    // event.detail 的值为当前选中项的索引
    this.setData({ active: event.detail });
    wx.switchTab({
        url: this.data.list[event.detail].pagePath,
    })
},
~~~



目前切换 tabBar 会出现闪屏的情况，这是因为我们在 data 中固定了 active 索引值，当跳转选项卡的时候，active 会被自动归 0，我们只需要把 active 放到 store 这个公共字段中，就不会每次被默认清0了。



~~~js
import { observable, action } from 'mobx-miniprogram'

export const store = observable({
  // 数据字段
  num: 0,
  active: 0,        // 添加 active 字段
  updateNum: action(function(step) {
    this.num += step
  }),
  // 添加更新 active 索引方法
  updateActive:action(function(index){
      this.active = index
  })
})
~~~



在 tabBar 组件中引入字段和方法

~~~js
    storeBindings: {
	    store,                 
	    fields: ['num','active'],
	    actions: ['updateNum','updateActive']
    },
~~~



然后在触发 tabBar 标签事件 onChange 的时候使用 updateActive 更新索引值即可

~~~js
        onChange(event) {
            // event.detail 的值为当前选中项的索引
            this.updateActive(event.detail)
            wx.switchTab({
              url: this.data.list[event.detail].pagePath,
            })
          },
~~~





## 10. 修改 tabBar 选中项文本颜色

vant tabBar 还有很多其他属性，

https://youzan.github.io/vant-weapp/#/tabbar



通过给 van-tabBar 添加 active-color 可以改变选中标签的文本颜色，如：

~~~html
<van-tabbar active="{{ active }}" bind:change="onChange" active-color="#C60000">
~~~



## 11. 其他子页面使用 tabBar

目前只有首页、消息页、联系页有 tabBar，当我们创建商品页、详情页时，tabBar 无法显示，我们需要在页面或全局的 json 中引入自定义 tabBar 组件

~~~js
    "usingComponents": {
        "tabBar": "../../custom-tab-bar/index"
    },
~~~



然后在页面中使用组件即可

~~~html
<tabBar></tabBar>
~~~



# Uni-app 开发小程序

https://www.escook.cn/docs-uni-shop

**uni-app 是一个使用 Vue.js 开发所有前端应用的框架**。开发者编写一套代码，可发布到 iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。



![image-20220511222252658](images/mini_program/image-20220511222252658.png)

> 详细的 uni-app 官方文档，请翻阅 https://uniapp.dcloud.net.cn/



为了实现多端兼容，综合考虑编译速度、运行性能等因素，`uni-app` 约定了如下开发规范：

- 页面文件遵循 [Vue 单文件组件 (SFC) 规范](https://vue-loader.vuejs.org/zh/spec.html)
- 组件标签靠近小程序规范，详见[uni-app 组件规范](https://uniapp.dcloud.io/component/README)
- 接口能力（JS API）靠近微信小程序规范，但需将前缀 `wx` 替换为 `uni`，详见[uni-app接口规范](https://uniapp.dcloud.io/api/README)
- 数据绑定及事件处理同 `Vue.js` 规范，同时补充了App及页面的生命周期
- 为兼容多端运行，建议使用flex布局进行开发



## 1. 开发工具

uni-app 官方推荐使用 **HBuilderX** 来开发 uni-app 类型的项目。主要好处：

- 模板丰富
- 完善的智能提示
- 一键运行

> 当然，你依然可以根据自己的喜好，选择使用 VS Code、Sublime、~~记事本~~... 等自己喜欢的编辑器！



HBuilderX 下载地址： https://www.dcloud.io/hbuilderx.html

> HBuilderX 3.4.6 版本起，取消单独的App开发版安装包，统一为一个标准安装包。标准版也可以安装app相关插件。



安装 scss/sass 编译插件： https://ext.dcloud.net.cn/plugin?name=compile-node-sass



配置文档

工具 -> 设置 -> 源码视图

~~~json
{
  "editor.colorScheme": "Default",
  "editor.fontSize": 12,
  "editor.fontFamily": "Consolas",
  "editor.fontFmyCHS": "微软雅黑 Light",
  "editor.insertSpaces": true,
  "editor.lineHeight": "1.5",
  "editor.minimap.enabled": false,
  "editor.mouseWheelZoom": true,
  "editor.onlyHighlightWord": false,
  "editor.tabSize": 2,
  "editor.wordWrap": true,
  "explorer.iconTheme": "vs-seti",
  "editor.codeassist.px2rem.enabel": false,
  "editor.codeassist.px2upx.enabel": false
}
~~~

> 常用用编辑器配置



## 2. 创建项目

- 文件 -> 新建 -> 项目

![image-20220511223937459](images/mini_program/image-20220511223937459.png)



目录结构

~~~
┌─components            uni-app组件目录
│  └─comp-a.vue         可复用的a组件
├─pages                 业务页面文件存放的目录
│  ├─index
│  │  └─index.vue       index页面
│  └─list
│     └─list.vue        list页面
├─static                存放应用引用静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此
├─main.js               Vue初始化入口文件
├─App.vue               应用配置，用来配置小程序的全局样式、生命周期函数等
├─manifest.json         配置应用名称、appid、logo、版本等打包信息
└─pages.json            配置页面路径、页面窗口样式、tabBar、navigationBar 等页面类信息
~~~



## 3. 把项目运行到微信开发者工具

- 在 manifest.json 中添加小程序 appid

![image-20220512154345621](images/mini_program/image-20220512154345621.png)



## 4. 配置微信开发者工具

工具 - 设置 - 运行配置 - 配置微信开发者工具路径

![image-20220512154701455](images/mini_program/image-20220512154701455.png)



打开微信开发者工具 - 设置 - 安全设置 - 打开服务端口

![image-20220512154818828](images/mini_program/image-20220512154818828.png)



在 HBuilderX 中，点击菜单栏中的 `运行 -> 运行到小程序模拟器 -> 微信开发者工具`，将当前 uni-app 项目编译之后，自动运行到微信开发者工具中，从而方便查看项目效果与调试：

![image-20220512155117325](images/mini_program/image-20220512155117325.png)



## 5. 修改小程序配置

此时在微信开发者工具中运行的小程序的所有代码都是由 uni-app 自动生成的，即使我们改动 app.json 文件，当我们再次用 uni-app 运行小程序的化，所有配置会重置覆盖。



我们可以在 uni-app 中的 manifest.json 中找到 源码视图，然后找到 mp-weixin 节点，即可配置小程序相关配置

![image-20220512155728273](images/mini_program/image-20220512155728273.png)



## 6. tabBar

### 6.1 创建 home 页面

在 `pages` 目录中，创建首页(home)、分类(cate)、购物车(cart)、我的(my) 这 4 个 tabBar 页面。在 HBuilderX 中，可以通过如下的两个步骤，快速新建页面：

1. 在 `pages` 目录上鼠标右键，选择**新建页面**
2. 在弹出的窗口中，填写**页面的名称**、**勾选 scss 模板**之后，点击创建按钮。截图如下：



![image-20220513121853456](images/mini_program/image-20220513121853456.png)



在 home 目录下会自动创建 .vue 文件

```html
<template>
	<view>
		这是信息页面
	</view>
</template>

<script>
</script>

<style>
</style>
```



通过pages来配置页面

| 属性  | 类型   | 默认值 | 描述                                                         |
| ----- | ------ | ------ | ------------------------------------------------------------ |
| path  | String |        | 配置页面路径                                                 |
| style | Object |        | 配置页面窗口表现，配置项参考 [pageStyle](https://uniapp.dcloud.io/collocation/pages?id=style) |



pages数组数组中第一项表示应用启动页

```html
"pages": [ 、
		{
			"path":"pages/message/message"
		},
		{
			"path": "pages/index/index",
			"style": {
				"navigationBarTitleText": "uni-app"
			}
		}
	]
```



通过style修改页面的标题和导航栏背景色，并且设置h5下拉刷新的特有样式

```js
"pages": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages
		{
			"path":"pages/message/message",
			"style": {
				"navigationBarBackgroundColor": "#007AFF",
				"navigationBarTextStyle": "white",
				"enablePullDownRefresh": true,
				"disableScroll": true,
				"h5": {
					"pullToRefresh": {
						"color": "#007AFF"
					}
				}
			}
		}
	]
```



### 6.2 创建 tabBar

**配置tabbar**

如果应用是一个多 tab 应用，可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页。



**Tips**

- 当设置 position 为 top 时，将不会显示 icon
- tabBar 中的 list 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。



**属性说明：**

| 属性            | 类型     | 必填 | 默认值 | 描述                                                 | 平台差异说明              |
| --------------- | -------- | ---- | ------ | ---------------------------------------------------- | ------------------------- |
| color           | HexColor | 是   |        | tab 上的文字默认颜色                                 |                           |
| selectedColor   | HexColor | 是   |        | tab 上的文字选中时的颜色                             |                           |
| backgroundColor | HexColor | 是   |        | tab 的背景色                                         |                           |
| borderStyle     | String   | 否   | black  | tabbar 上边框的颜色，仅支持 black/white              | App 2.3.4+ 支持其他颜色值 |
| list            | Array    | 是   |        | tab 的列表，详见 list 属性说明，最少2个、最多5个 tab |                           |
| position        | String   | 否   | bottom | 可选值 bottom、top                                   | top 值仅微信小程序支持    |



其中 list 接收一个数组，数组中的每个项都是一个对象，其属性值如下：

| 属性             | 类型   | 必填 | 说明                                                         |
| ---------------- | ------ | ---- | ------------------------------------------------------------ |
| pagePath         | String | 是   | 页面路径，必须在 pages 中先定义                              |
| text             | String | 是   | tab 上按钮文字，在 5+APP 和 H5 平台为非必填。例如中间可放一个没有文字的+号图标 |
| iconPath         | String | 否   | 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效，不支持网络图片，不支持字体图标 |
| selectedIconPath | String | 否   | 选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效 |



1. 将 `资料` 目录下的 `static 文件夹` 拷贝一份，替换掉项目根目录中的 `static 文件夹`
2. 修改项目根目录中的 `pages.json` 配置文件，新增 `tabBar` 的配置节点如下：

~~~json
{
  "tabBar": {
    "selectedColor": "#C00000",
    "list": [
      {
        "pagePath": "pages/home/home",
        "text": "首页",
        "iconPath": "static/tab_icons/home.png",
        "selectedIconPath": "static/tab_icons/home-active.png"
      },
      {
        "pagePath": "pages/cate/cate",
        "text": "分类",
        "iconPath": "static/tab_icons/cate.png",
        "selectedIconPath": "static/tab_icons/cate-active.png"
      },
      {
        "pagePath": "pages/cart/cart",
        "text": "购物车",
        "iconPath": "static/tab_icons/cart.png",
        "selectedIconPath": "static/tab_icons/cart-active.png"
      },
      {
        "pagePath": "pages/my/my",
        "text": "我的",
        "iconPath": "static/tab_icons/my.png",
        "selectedIconPath": "static/tab_icons/my-active.png"
      }
    ]
  }
}
~~~



### 6.3 删除默认的 index 首页

1. 在 HBuilderX 中，把 `pages` 目录下的 `index首页文件夹` 删除掉
2. 同时，把 `page.json` 中记录的 `index 首页` 路径删除掉
3. 为了防止小程序运行失败，在微信开发者工具中，手动删除 `pages` 目录下的 `index 首页文件夹`
4. 同时，把 `components` 目录下的 `uni-link 组件文件夹` 删除掉



### 6.4 修改导航条的样式效果

1. 打开 `pages.json` 这个全局的配置文件
2.  globalStyle 进行全局配置



用于设置应用的状态栏、导航条、标题、窗口背景色等。[详细文档](https://uniapp.dcloud.io/collocation/pages?id=globalstyle)

| 属性                         | 类型     | 默认值  | 描述                                                         |
| ---------------------------- | -------- | ------- | ------------------------------------------------------------ |
| navigationBarBackgroundColor | HexColor | #F7F7F7 | 导航栏背景颜色（同状态栏背景色）                             |
| navigationBarTextStyle       | String   | white   | 导航栏标题颜色及状态栏前景颜色，仅支持 black/white           |
| navigationBarTitleText       | String   |         | 导航栏标题文字内容                                           |
| backgroundColor              | HexColor | #ffffff | 窗口的背景色                                                 |
| backgroundTextStyle          | String   | dark    | 下拉 loading 的样式，仅支持 dark / light                     |
| enablePullDownRefresh        | Boolean  | false   | 是否开启下拉刷新，详见[页面生命周期](https://uniapp.dcloud.io/use?id=%e9%a1%b5%e9%9d%a2%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f)。 |
| onReachBottomDistance        | Number   | 50      | 页面上拉触底事件触发时距页面底部距离，单位只支持px，详见[页面生命周期](https://uniapp.dcloud.io/use?id=%e9%a1%b5%e9%9d%a2%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f) |

##### 

修改 `globalStyle` 节点如下：

~~~json
	"globalStyle": {
		"navigationBarTextStyle": "white",
		"navigationBarTitleText": "黑马优购",
		"navigationBarBackgroundColor": "#C00000",
		"backgroundColor": "#C00000",
		"app-plus": {
			"background": "#efeff4"
		}
	},
~~~



此时可以看到页面的标题栏没有显示，这是因为在 pages 节点中，每个页面都有自己的导航栏标题设置，优先级要比全局的高，所以直接改动即可

~~~json
	"pages": [{
		"path": "pages/home/home",
		"style": {
			"navigationBarTitleText": "黑马优购",
			"enablePullDownRefresh": false
		}

	}, {
		"path": "pages/cate/cate",
		"style": {
			"navigationBarTitleText": "分类",
			"enablePullDownRefresh": false
		}

	}, {
		"path": "pages/cart/cart",
		"style": {
			"navigationBarTitleText": "购物车",
			"enablePullDownRefresh": false
		}

	}, {
		"path": "pages/my/my",
		"style": {
			"navigationBarTitleText": "我的",
			"enablePullDownRefresh": false
		}

	}],
~~~



## 7. 首页

### 1. 配置网络请求包

由于平台的限制，小程序项目中**不支持 axios**，而且原生的 `wx.request()` API 功能较为简单，**不支持拦截器**等全局定制的功能。因此，建议在 uni-app 项目中使用 `@escook/request-miniprogram` 第三方包发起网络数据请求。

> 请参考 **@escook/request-miniprogram** 的官方文档进行安装、配置、使用

> 官方文档：https://www.npmjs.com/package/@escook/request-miniprogram



在项目根目录下创建 npm 项目

~~~
npm init -y
~~~



安装包

~~~
npm install @escook/request-miniprogram
~~~



最终，在项目的 `main.js` 入口文件中，通过如下的方式进行配置：

~~~js
import { $http } from '@escook/request-miniprogram'

uni.$http = $http

// 请求开始之前做一些事情
$http.beforeRequest = function (options) {
  uni.showLoading({
    title: '数据加载中...',
  })
}

// 请求完成之后做一些事情
$http.afterRequest = function () {
  uni.hideLoading()
}
~~~



### 2. 配置请求域名

接口域名：

~~~
https://www.uinav.com
https://api-ugo-web.itheima.net
~~~



在小程序后台配置

开发管理 - 开发设置 - 服务器域名

![image-20220513140325529](images/mini_program/image-20220513140325529.png)





设置不校验域名合法性

![image-20220513140530361](images/mini_program/image-20220513140530361.png)



在 main.js 中设置请求根路径 

~~~
// 配置请求根路径
$http.baseUrl = 'https://www.uinav.com'
~~~



### 3. 轮播图

实现步骤：

1. 在 data 中定义轮播图的数组
2. 在 onLoad 生命周期函数中调用获取轮播图数据的方法
3. 在 methods 中定义获取轮播图数据的方法



示例代码：

~~~js
export default {
  data() {
    return {
      // 1. 轮播图的数据列表，默认为空数组
      swiperList: [],
    }
  },
  onLoad() {
    // 2. 在小程序页面刚加载的时候，调用获取轮播图数据的方法
    this.getSwiperList()
  },
  methods: {
    // 3. 获取轮播图数据的方法
    async getSwiperList() {
      // 3.1 发起请求
      const { data: res } = await uni.$http.get('/api/public/v1/home/swiperdata')
      // 3.2 请求失败
      if (res.meta.status !== 200) {
        return uni.showToast({
          title: '数据请求失败！',
          duration: 1500,
          icon: 'none',
        })
      }
      // 3.3 请求成功，为 data 中的数据赋值
      this.swiperList = res.message
    },
  },
}
~~~



渲染轮播图的 UI 结构

~~~vue
<template>
  <view>
    <!-- 轮播图区域 -->
    <swiper :indicator-dots="true" :autoplay="true" :interval="3000" :duration="1000" :circular="true">
      <!-- 循环渲染轮播图的 item 项 -->
      <swiper-item v-for="(item, i) in swiperList" :key="i">
        <view class="swiper-item">
          <!-- 动态绑定图片的 src 属性 -->
          <image :src="item.image_src"></image>
        </view>
      </swiper-item>
    </swiper>
  </view>
</template>
~~~



CSS

~~~vue
<style lang="scss">
swiper {
 height: 330rpx;

 .swiper-item,
 image {
   width: 100%;
   height: 100%;
 }
}
</style>
~~~



### 4. 配置小程序分包

> 分包可以减少小程序首次启动时的加载时间

为此，我们在项目中，把 tabBar 相关的 4 个页面放到主包中，其它页面（例如：商品详情页、商品列表页）放到分包中。在 uni-app 项目中，配置分包的步骤如下：



在manifest配置以下节点，可以在App端启动分包

~~~
"app-plus": {
  "optimization": {
    "subPackages": true
  },
  "runmode" : "liberate" // 开启分包优化后，必须配置资源释放模式
}
~~~

> 在manifest中启动分包后，需要在pages.json中配置具体的分包规则，与小程序的配置相同



1. 在项目根目录中，创建分包的根目录，命名为 `subpkg`

   ~~~
   # 创建页面文件
   subpkg/goods_detail/goods_detail.vue
   ~~~

   

2. 在 `pages.json` 中，和 `pages` 节点平级的位置声明 `subPackages` 节点，用来定义分包相关的结构：

~~~
  "subPackages": [
    {
      "root": "subpkg",
      "pages": []
    }
  ]
~~~



3. 在 `subpkg` 目录上鼠标右键，点击 `新建页面` 选项，并填写页面的相关信息：

![image-20220513153912595](images/mini_program/image-20220513153912595.png)



4. 创建完成应该是这样的

~~~
	"subPackages": [{
		"root": "subpkg",
		"pages": [{
			"path":"goods_detail/goods_detail"
		}]
	}],
~~~



### 5. 点击轮播图跳转到商品详情页面

将 `<swiper-item></swiper-item>` 节点内的 `view` 组件，改造为 `navigator` 导航组件，并动态绑定 `url 属性` 的值。

1. 改造之前的 UI 结构：

   ```xml
   <swiper-item v-for="(item, i) in swiperList" :key="i">
     <view class="swiper-item">
       <!-- 动态绑定图片的 src 属性 -->
       <image :src="item.image_src"></image>
     </view>
   </swiper-item>
   ```

   

2. 改造之后的 UI 结构：

   ```xml
   <swiper-item v-for="(item, i) in swiperList" :key="i">
       <navigator class="swiper-item" :url="'/subpkg/goods_detail/goods_detail?goods_id=' + item.goods_id">
         <!-- 动态绑定图片的 src 属性 -->
         <image :src="item.image_src"></image>
       </navigator>
   </swiper-item>
   ```



### 6. 封装 uni.$showMsg() 方法

数据请求失败之后，经常需要调用 `uni.showToast({ /* 配置对象 */ })` 方法来提示用户。如之前的轮播图网络请求：

~~~js
async getSwiperList() {
    const { data: res } = await uni.$http.get('/api/public/v1/home/swiperdata')
    // 判断验证码，如果失败则弹出提示框
    if (res.meta.status !== 200) {
        return uni.showToast({
            title: '数据请求失败！',
            duration: 1500,
            icon: 'none',
        })
    }
    // 请求成功，为 data 中的数据赋值
    this.swiperList = res.message
},
~~~



此时，可以在全局封装一个 `uni.$showMsg()` 方法，来简化 `uni.showToast()` 方法的调用。具体的改造步骤如下：

1. 在 `main.js` 中，为 `uni` 对象挂载自定义的 `$showMsg()` 方法：

```js
// 封装的展示消息提示的方法
uni.$showMsg = function (title = '数据加载失败！', duration = 1500) {
  uni.showToast({
    title,
    duration,
    icon: 'none',
  })
}
```



2. 今后，在需要提示消息的时候，直接调用 `uni.$showMsg()` 方法即可：

```js
async getSwiperList() {
   const { data: res } = await uni.$http.get('/api/public/v1/home/swiperdata')
   if (res.meta.status !== 200) return uni.$showMsg()
   this.swiperList = res.message
}
```



### 7. 分类导航区域

获取分类导航的数据

1. 定义 data 数据
2. 在 onLoad 中调用获取数据的方法
3. 在 methods 中定义获取数据的方法



示例代码如下：

~~~js
export default {
  data() {
    return {
      // 1. 分类导航的数据列表
      navList: [],
    }
  },
  onLoad() {
    // 2. 在 onLoad 中调用获取数据的方法
    this.getNavList()
  },
  methods: {
    // 3. 在 methods 中定义获取数据的方法
    async getNavList() {
      const { data: res } = await uni.$http.get('/api/public/v1/home/catitems')
      if (res.meta.status !== 200) return uni.$showMsg()
      this.navList = res.message
    },
  },
}
~~~



定义如下的 UI 结构

~~~vue
<!-- 分类导航区域 -->
<view class="nav-list">
   <view class="nav-item" v-for="(item, i) in navList" :key="i">
     <image :src="item.image_src" class="nav-img"></image>
   </view>
</view>
~~~



通过如下的样式美化页面结构

```scss
.nav-list {
  display: flex;
  justify-content: space-around;
  margin: 15px 0;

  .nav-img {
    width: 128rpx;
    height: 140rpx;
  }
}
```



点击第一项，切换到分类页面

`nav-item` 绑定点击事件处理函数：

```vue
<!-- 分类导航区域 -->
<view class="nav-list">
  <view class="nav-item" v-for="(item, i) in navList" :key="i" @click="navClickHandler(item)">
    <image :src="item.image_src" class="nav-img"></image>
  </view>
</view>
```



定义 `navClickHandler` 事件处理函数

```js
// nav-item 项被点击时候的事件处理函数
navClickHandler(item) {
  // 判断点击的是哪个 nav
  if (item.name === '分类') {
    uni.switchTab({
      url: '/pages/cate/cate'
    })
  }
}
```



### 8. 楼层区域

获取楼层数据

1. 定义 data 数据
2. 在 onLoad 中调用获取数据的方法
3. 在 methods 中定义获取数据的方法



实例代码如下：

~~~js
export default {
  data() {
    return {
      // 1. 楼层的数据列表
      floorList: [],
    }
  },
  onLoad() {
    // 2. 在 onLoad 中调用获取楼层数据的方法
    this.getFloorList()
  },
  methods: {
    // 3. 定义获取楼层列表数据的方法
    async getFloorList() {
      const { data: res } = await uni.$http.get('/api/public/v1/home/floordata')
      if (res.meta.status !== 200) return uni.$showMsg()
      this.floorList = res.message
    },
  },
}
~~~



渲染楼层标题

```xml
<!-- 楼层区域 -->
<view class="floor-list">
  <!-- 楼层 item 项 -->
  <view class="floor-item" v-for="(item, i) in floorList" :key="i">
    <!-- 楼层标题 -->
    <image :src="item.floor_title.image_src" class="floor-title"></image>
  </view>
</view>
```



美化楼层标题的样式：

```scss
.floor-title {
  height: 60rpx;
  width: 100%;
  display: flex;
}
```



定义楼层图片区域的 UI 结构：

```xml
<!-- 楼层图片区域 -->
<view class="floor-img-box">
  <!-- 左侧大图片的盒子 -->
  <view class="left-img-box">
    <image :src="item.product_list[0].image_src" :style="{width: item.product_list[0].image_width + 'rpx'}" mode="widthFix"></image>
  </view>
  <!-- 右侧 4 个小图片的盒子 -->
  <view class="right-img-box">
    <view class="right-img-item" v-for="(item2, i2) in item.product_list" :key="i2" v-if="i2 !== 0">
      <image :src="item2.image_src" mode="widthFix" :style="{width: item2.image_width + 'rpx'}"></image>
    </view>
  </view>
</view>
```



美化楼层图片区域的样式：

```scss
.right-img-box {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-around;
}

.floor-img-box {
  display: flex;
  padding-left: 10rpx;
}
```



点击楼层图片跳转到商品列表页

在 `subpkg` 分包中，新建 `goods_list` 页面

楼层数据请求成功之后，通过双层 `forEach` 循环，处理 URL 地址：

```js
// 获取楼层列表数据
async getFloorList() {
  const { data: res } = await uni.$http.get('/api/public/v1/home/floordata')
  if (res.meta.status !== 200) return uni.$showMsg()

  // 通过双层 forEach 循环，处理 URL 地址
  res.message.forEach(floor => {
    floor.product_list.forEach(prod => {
      prod.url = '/subpkg/goods_list/goods_list?' + prod.navigator_url.split('?')[1]
    })
  })

  this.floorList = res.message
}
```



把图片外层的 `view` 组件，改造为 `navigator` 组件，并动态绑定 `url 属性` 的值：

```xml
<!-- 楼层图片区域 -->
<view class="floor-img-box">
  <!-- 左侧大图片的盒子 -->
  <navigator class="left-img-box" :url="item.product_list[0].url">
    <image :src="item.product_list[0].image_src" :style="{width: item.product_list[0].image_width + 'rpx'}" mode="widthFix"></image>
  </navigator>
  <!-- 右侧 4 个小图片的盒子 -->
  <view class="right-img-box">
    <navigator class="right-img-item" v-for="(item2, i2) in item.product_list" :key="i2" v-if="i2 !== 0" :url="item2.url">
      <image :src="item2.image_src" mode="widthFix" :style="{width: item2.image_width + 'rpx'}"></image>
    </navigator>
  </view>
</view>
```



## 8. 分类页面

### 1. 渲染分类页面基本机构

需要使用 scroll-view 标签，并且使用 scroll-y 属性实现纵向滚动，并且需要给盒子增加一个高度

```xml
<template>
	<view>
		<view class="scroll-view-container">
			<scroll-view scroll-y="true" class="left-scroll-view" style="height:300px">
				<view class="left-scroll-view-item active">xxx</view>
                ...
				<view class="left-scroll-view-item">xxx</view>
				<view class="left-scroll-view-item">xxx</view>
			</scroll-view>
			<scroll-view scroll-y="true" class="right-scroll-view" style="height:300px">
				<view class="right-scroll-view-item active">xxx</view>
                ...
				<view class="right-scroll-view-item">xxx</view>
				<view class="right-scroll-view-item">xxx</view>
			</scroll-view>
		</view>
	</view>
</template>
```



给父盒子添加 flex 属性，让两个盒子平行

~~~css
<style lang="scss">
.scroll-view-container {
	display: flex;
}
</style>
~~~



通过使用 uni.getSystemInfoSync() API 拿到设备的高度

~~~js
onLoad(){
    const sysInfo = uni.getSystemInfoSync()
    this.wh = sysInfo.windowHeight
}
~~~

> 注意 .wh 需要在 data 中声明一下



其中

- screenHeight ：整个屏幕高度
- windowHeight ：整个屏幕高度 - navBar - tabBar 的高度



然后将 wh 值绑定在盒子样式上

~~~vue
<scroll-view scroll-y="true" class="left-scroll-view" :style="{height:wh + 'px'}">
<scroll-view scroll-y="true" class="right-scroll-view" :style="{height:wh + 'px'}">
~~~



美化页面结构

~~~scss
.scroll-view-container {
  display: flex;

  .left-scroll-view {
    width: 120px;

    .left-scroll-view-item {
      line-height: 60px;
      background-color: #f7f7f7;
      text-align: center;
      font-size: 12px;

      // 激活项的样式
      &.active {
        background-color: #ffffff;
        position: relative;

        // 渲染激活项左侧的红色指示边线
        &::before {
          content: ' ';
          display: block;
          width: 3px;
          height: 30px;
          background-color: #c00000;
          position: absolute;
          left: 0;
          top: 50%;
          transform: translateY(-50%);
        }
      }
    }
  }
}
~~~



### 2. 获取分类数据

在 data 中定义分类数据节点

```js
data() {
  return {
    // 分类数据列表
    cateList: []
  }
}
```



调用获取分类列表数据的方法：

```js
onLoad() {
  // 调用获取分类列表数据的方法
  this.getCateList()
}
```



定义获取分类列表数据的方法：

```js
methods: {
  async getCateList() {
    // 发起请求
    const { data: res } = await uni.$http.get('/api/public/v1/categories')
    // 判断是否获取失败
    if (res.meta.status !== 200) return uni.$showMsg()
    // 转存数据
    this.cateList = res.message
  }
}
```



### 3. 动态渲染左侧的一级分类列表

1. 循环渲染列表结构：

   ```xml
   <!-- 左侧的滚动视图区域 -->
   <scroll-view class="left-scroll-view" scroll-y :style="{height: wh + 'px'}">
     <block v-for="(item, i) in cateList" :key="i">
       <view class="left-scroll-view-item">{{item.cat_name}}</view>
     </block>
   </scroll-view>
   ```

   

2. 在 data 中定义默认选中项的索引：

   ```js
   data() {
     return {
       // 当前选中项的索引，默认让第一项被选中
       active: 0
     }
   }
   ```

   

3. 循环渲染结构时，为选中项动态添加 `.active` 类名：

   ```xml
   <block v-for="(item, i) in cateList" :key="i">
     <view :class="['left-scroll-view-item', i === active ? 'active' : '']">{{item.cat_name}}</view>
   </block>
   ```

   

4. 为一级分类的 Item 项绑定点击事件处理函数 `activeChanged`：

   ```xml
   <block v-for="(item, i) in cateList" :key="i">
     <view :class="['left-scroll-view-item', i === active ? 'active' : '']" @click="activeChanged(i)">{{item.cat_name}}</view>
   </block>
   ```

   

5. 定义 `activeChanged` 事件处理函数，动态修改选中项的索引：

   ```js
   methods: {
     // 选中项改变的事件处理函数
     activeChanged(i) {
       this.active = i
     }
   }
   ```



### 4. 动态渲染右侧的二级分类列表

1. 在 `data` 中定义二级分类列表的数据节点：

   ```js
   data() {
     return {
       // 二级分类列表
       cateLevel2: []
     }
   }
   ```

   

2. 修改 `getCateList` 方法，在请求到数据之后，为二级分类列表数据赋值：

   ```js
   async getCateList() {
     const { data: res } = await uni.$http.get('/api/public/v1/categories')
     if (res.meta.status !== 200) return uni.$showMsg()
     this.cateList = res.message
     // 为二级分类赋值
     this.cateLevel2 = res.message[0].children
   }
   ```

3. 修改 `activeChanged` 方法，在一级分类选中项改变之后，为二级分类列表数据重新赋值：

   ```js
   activeChanged(i) {
     this.active = i
     // 为二级分类列表重新赋值
     this.cateLevel2 = this.cateList[i].children
   }
   ```

4. 循环渲染右侧二级分类列表的 UI 结构：

   ```xml
   <!-- 右侧的滚动视图区域 -->
   <scroll-view class="right-scroll-view" scroll-y :style="{height: wh + 'px'}">
     <view class="cate-lv2" v-for="(item2, i2) in cateLevel2" :key="i2">
       <view class="cate-lv2-title">/ {{item2.cat_name}} /</view>
     </view>
   </scroll-view>
   ```

5. 美化二级分类的标题样式：

   ```scss
   .cate-lv2-title {
     font-size: 12px;
     font-weight: bold;
     text-align: center;
     padding: 15px 0;
   }
   ```

###  5. 动态渲染右侧的三级分类列表

1. 在二级分类的 `<view>` 组件中，循环渲染三级分类的列表结构：

   ```xml
   <!-- 右侧的滚动视图区域 -->
   <scroll-view class="right-scroll-view" scroll-y :style="{height: wh + 'px'}">
     <view class="cate-lv2" v-for="(item2, i2) in cateLevel2" :key="i2">
       <view class="cate-lv2-title">/ {{item2.cat_name}} /</view>
       <!-- 动态渲染三级分类的列表数据 -->
       <view class="cate-lv3-list">
         <!-- 三级分类 Item 项 -->
         <view class="cate-lv3-item" v-for="(item3, i3) in item2.children" :key="i3">
           <!-- 图片 -->
           <image :src="item3.cat_icon"></image>
           <!-- 文本 -->
           <text>{{item3.cat_name}}</text>
         </view>
       </view>
     </view>
   </scroll-view>
   ```

2. 美化三级分类的样式：

   ```scss
   .cate-lv3-list {
     display: flex;
     flex-wrap: wrap;
   
     .cate-lv3-item {
       width: 33.33%;
       margin-bottom: 10px;
       display: flex;
       flex-direction: column;
       align-items: center;
   
       image {
         width: 60px;
         height: 60px;
       }
   
       text {
         font-size: 12px;
       }
     }
   }
   ```

### 6. 切换一级分类后重置滚动条的位置

1. 在 data 中定义 `滚动条距离顶部的距离`：

   ```js
   data() {
     return {
       // 滚动条距离顶部的距离
       scrollTop: 0
     }
   }
   ```

2. 动态为右侧的 `<scroll-view>` 组件绑定 `scroll-top` 属性的值：

   ```xml
   <!-- 右侧的滚动视图区域 -->
   <scroll-view class="right-scroll-view" scroll-y :style="{height: wh + 'px'}" :scroll-top="scrollTop"></scroll-view>
   ```

3. 切换一级分类时，动态设置 `scrollTop` 的值：

   ```js
   // 选中项改变的事件处理函数
   activeChanged(i) {
     this.active = i
     this.cateLevel2 = this.cateList[i].children
   
     // 让 scrollTop 的值在 0 与 1 之间切换
     this.scrollTop = this.scrollTop === 0 ? 1 : 0
   
     // 可以简化为如下的代码：
     // this.scrollTop = this.scrollTop ? 0 : 1
   }
   ```

### 7. 点击三级分类跳转到商品列表页面

1. 为三级分类的 Item 项绑定点击事件处理函数如下：

   ```xml
   <view class="cate-lv3-item" v-for="(item3, i3) in item2.children" :key="i3" @click="gotoGoodsList(item3)">
     <image :src="item3.cat_icon"></image>
     <text>{{item3.cat_name}}</text>
   </view>
   ```

2. 定义事件处理函数如下：

   ```js
   // 点击三级分类项跳转到商品列表页面
   gotoGoodsList(item3) {
     uni.navigateTo({
       url: '/subpkg/goods_list/goods_list?cid=' + item3.cat_id
     })
   }
   ```



## 9. 搜索组件

### 1. 自定义 my-search 组件

1. 在项目根目录的 `components` 目录上，鼠标右键，选择 `新建组件`，填写组件信息后，最后点击 `创建` 按钮：

![image-20220515145028414](images/mini_program/image-20220515145028414.png)



1. 在分类页面的 UI 结构中，直接以标签的形式使用 `my-search` 自定义组件：

```xml
<!-- 使用自定义的搜索组件 -->
<my-search></my-search>
```



2. 定义 `my-search` 组件的 UI 结构如下：

```xml
<template>
  <view class="my-search-container">
    <!-- 使用 view 组件模拟 input 输入框的样式 -->
    <view class="my-search-box">
      <uni-icons type="search" size="17"></uni-icons>
      <text class="placeholder">搜索</text>
    </view>
  </view>
</template>	
```

> **注意：在当前组件中，我们使用 view 组件模拟 input 输入框的效果；并不会在页面上渲染真正的 input 输入框**



3. 美化自定义 search 组件的样式：

```scss
.my-search-container {
  background-color: #c00000;
  height: 50px;
  padding: 0 10px;
  display: flex;
  align-items: center;
}

.my-search-box {
  height: 36px;
  background-color: #ffffff;
  border-radius: 15px;
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;

  .placeholder {
    font-size: 15px;
    margin-left: 5px;
  }
}
```



4. 由于自定义的 `my-search` 组件高度为 `50px`，因此，需要重新计算分类页面窗口的可用高度：

```js
onLoad() {
  const sysInfo = uni.getSystemInfoSync()
  // 可用高度 = 屏幕高度 - navigationBar高度 - tabBar高度 - 自定义的search组件高度
  this.wh = sysInfo.windowHeight - 50
}
```



### 2. 通过自定义属性增强组件的通用性

为了增强组件的通用性，我们允许使用者自定义搜索组件的 `背景颜色` 和 `圆角尺寸`。

通过 `props` 定义 `bgcolor` 和 `radius` 两个属性，并指定值类型和属性默认值：

```js
props: {
  // 背景颜色
  bgcolor: {
    type: String,
    default: '#C00000'
  },
  // 圆角尺寸
  radius: {
    type: Number,
    // 单位是 px
    default: 15
  }
}
```



通过属性绑定的形式，为 `.my-search-container` 盒子和 `.my-search-box` 盒子动态绑定 `style` 属性：

```xml
<view class="my-search-container" :style="{'background-color': bgcolor}">
  <view class="my-search-box" :style="{'border-radius': radius + 'px'}">
    <uni-icons type="search" size="17"></uni-icons>
    <text class="placeholder">搜索</text>
  </view>
</view>
```



移除对应 `scss` 样式中的 `背景颜色` 和 `圆角尺寸`：

```scss
.my-search-container {
  // 移除背景颜色，改由 props 属性控制
  // background-color: #C00000;
  height: 50px;
  padding: 0 10px;
  display: flex;
  align-items: center;
}

.my-search-box {
  height: 36px;
  background-color: #ffffff;
  // 移除圆角尺寸，改由 props 属性控制
  // border-radius: 15px;
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;

  .placeholder {
    font-size: 15px;
    margin-left: 5px;
  }
}
```



之后就可以在使用 my-search 组件的页面中传入对应的 prop 即可

~~~vue
<my-search :bgColor="'#000000'" :radius="5"></my-search>
~~~

> 注意：bgColor 传入的是字符串，需要加引号，数字则不用。



### 3. 跳转到 search 页面

my-search 组件实际上相当于一个按钮，通过点击这个按钮，我们要跳转到真正的 search 页面



首先我们要创建一个 Search 分包页面

![image-20220515220533000](images/mini_program/image-20220515220533000.png)





在 `my-search` 自定义组件内部，给类名为 `.my-search-box` 的 `view` 绑定 `click` 事件处理函数：

```xml
<view class="my-search-box" :style="{'border-radius':radius + 'px'}" @click="gotoSearch">
```



在 `my-search` 自定义组件的 `methods` 节点中，声明事件处理函数如下：

```js
methods:{
    gotoSearch(){
        console.log(1)
        uni.navigateTo({					
            url:'/subpkg/search/search'
        })
    }
}
```



### 4. my-search 组件固定在顶部

在 home 首页定义如下的 UI 结构：

```xml
<!-- 使用自定义的搜索组件 -->
<view class="search-box">
  <my-search></my-search>
</view>
```



通过如下的样式实现吸顶的效果：

```scss
.search-box {
  // 设置定位效果为“吸顶”
  position: sticky;
  // 吸顶的“位置”
  top: 0;
  // 提高层级，防止被轮播图覆盖
  z-index: 999;
}
```



## 10. 搜索页面

### 1. 渲染搜索页面的基本结构

定义如下的 UI 结构：

```xml
<view class="search-box">
    <!-- 使用 uni-ui 提供的搜索组件 -->
    <uni-search-bar placeholder="请输入搜索内容" @input="input" :radius="100" cancelButton="none"></uni-search-bar>
</view>
```



uni-app 扩展组件 uni-ui 中的 uni-search-bar 使用文档：

https://uniapp.dcloud.io/component/uniui/uni-search-bar.html



### 2. 更改样式

在页面中覆盖样式

~~~css
.uni-searchbar {
    background-color: #c00000;
}
~~~



也可以在项目根目录中 `uni.scss` 直接覆盖样式

~~~css
@import '@/uni_modules/uni-scss/variables.scss';

.uni-searchbar {
  background-color: #c00000;
}
~~~



以下直接更改组件源码样式：(不建议)

修改 `uni_modules -> uni-search-bar -> uni-search-bar.vue` 组件，将默认的白色搜索背景改为 `#C00000` 的红色背景：

```css
.uni-searchbar {
  /* #ifndef APP-NVUE */
  display: flex;
  /* #endif */
  flex-direction: row;
  position: relative;
  padding: 16rpx;
  /* 将默认的 #FFFFFF 改为 #C00000 */
  background-color: #c00000;
}
```



实现搜索框的吸顶效果：

```scss
.search-box {
  position: sticky;
  top: 0;
  z-index: 999;
}
```



定义如下的 input 事件处理函数：

```js
methods:{
    // res 为 input 输入值
    input(res){
        console.log(res)
    }
}
```



### 3. 实现搜索框自动获取焦点

直接在组件上绑定 focus 属性，即可实现自动获取焦点的效果，如：

~~~vue
<uni-search-bar placeholder="请输入搜索内容" :focus="true" @input="input" :radius="100" cancelButton="none"></uni-search-bar>
~~~



如果使用的是老版本的 HBuilder 组件中需要修改源码：

修改 `components -> uni-search-bar -> uni-search-bar.vue` 组件，把 data 数据中的 `show` 和 `showSync` 的值，从默认的 `false` 改为 `true` 即可：

```js
data() {
  return {
    show: true,
    showSync: true,
    searchVal: ""
  }
}
```



**注意**：使用手机扫码预览，才可以在真机上查看获取焦点效果，模拟器无法实现。



### 4. 实现搜索框的防抖处理

在 data 中定义防抖的延时器 timerId 如下：

```js
data() {
  return {
    // 延时器的 timerId
    timer: null,
    // 搜索关键词
    kw: ''
  }
}
```



修改 `input` 事件处理函数如下：

- 先设定一个 500ms 定时器
- 500ms 后让 input 框内容值赋给 kw
- 然后在 input 事件触发后，先清除定时器（即 500ms 内重新触发定时器，则会不被赋值）

```js
input(res) {
  // 清除 timer 对应的延时器
  clearTimeout(this.timer)
  // 重新启动一个延时器，并把 timerId 赋值给 this.timer
  this.timer = setTimeout(() => {
    // 如果 500 毫秒内，没有触发新的输入事件，则为搜索关键词赋值
    this.kw = res
    console.log(this.kw)
  }, 500)
}
```



### 5. 根据关键词查询搜索建议列表

在 data 中定义如下的数据节点，用来存放搜索建议的列表数据：

```js
data() {
  return {
    // 搜索结果列表
    searchResults: []
  }
}
```



在防抖的 `setTimeout` 中，调用 `getSearchList` 方法获取搜索建议列表：

```js
this.timer = setTimeout(() => {
  this.kw = res
  // 根据关键词，查询搜索建议列表
  this.getSearchList()
}, 500)
```



在 `methods` 中定义 `getSearchList` 方法如下：

```js
// 根据搜索关键词，搜索商品建议列表
async getSearchList() {
  // 判断关键词是否为空
  if (this.kw === '') {
    this.searchResults = []
    return
  }
  // 发起请求，获取搜索建议列表
  const { data: res } = await uni.$http.get('/api/public/v1/goods/qsearch', { query: this.kw })
  if (res.meta.status !== 200) return uni.$showMsg()
  this.searchResults = res.message
}
```



### 6. 渲染搜索建议列表

定义如下的 UI 结构：

```xml
<!-- 搜索建议列表 -->
<view class="sugg-list">
  <view class="sugg-item" v-for="(item, i) in searchResults" :key="i" @click="gotoDetail(item.goods_id)">
    <view class="goods-name">{{item.goods_name}}</view>
    <uni-icons type="arrowright" size="16"></uni-icons>
  </view>
</view>
```



美化搜索建议列表：

```scss
.sugg-list {
  padding: 0 5px;

  .sugg-item {
    font-size: 12px;
    padding: 13px 0;
    border-bottom: 1px solid #efefef;
    display: flex;
    align-items: center;
    justify-content: space-between;

    .goods-name {
      // 文字不允许换行（单行文本）
      white-space: nowrap;
      // 溢出部分隐藏
      overflow: hidden;
      // 文本溢出后，使用 ... 代替
      text-overflow: ellipsis;
      margin-right: 3px;
    }
  }
}
```



点击搜索建议的 Item 项，跳转到商品详情页面：

```js
gotoDetail(goods_id) {
  uni.navigateTo({
    // 指定详情页面的 URL 地址，并传递 goods_id 参数
    url: '/subpkg/goods_detail/goods_detail?goods_id=' + goods_id
  })
}
```



### 7. 搜索历史

渲染搜索历史记录的基本结构，在 data 中定义搜索历史的`假数据`：

```js
data() {
  return {
    // 搜索关键词的历史记录
    historyList: ['a', 'app', 'apple']
  }
}
```



渲染搜索历史区域的 UI 结构：

```xml
<!-- 搜索历史 -->
<view class="history-box">
  <!-- 标题区域 -->
  <view class="history-title">
    <text>搜索历史</text>
    <uni-icons type="trash" size="17"></uni-icons>
  </view>
  <!-- 列表区域 -->
  <view class="history-list">
    <uni-tag :text="item" v-for="(item, i) in historyList" :key="i"></uni-tag>
  </view>
</view>
```



美化搜索历史区域的样式：

```scss
.history-box {
  padding: 0 5px;

  .history-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
    height: 40px;
    font-size: 13px;
    border-bottom: 1px solid #efefef;
  }

  .history-list {
    display: flex;
    flex-wrap: wrap;

    .uni-tag {
      margin-top: 5px;
      margin-right: 5px;
    }
  }
}
```



- 当搜索结果列表的长度`不为 0`的时候（`searchResults.length !== 0`），需要展示搜索建议区域，隐藏搜索历史区域

- 当搜索结果列表的长度`等于 0`的时候（`searchResults.length === 0`），需要隐藏搜索建议区域，展示搜索历史区域

使用 `v-if` 和 `v-else` 控制这两个区域的显示和隐藏，示例代码如下：

```xml
<!-- 搜索建议列表 -->
<view class="sugg-list" v-if="searchResults.length !== 0">
  <!-- 省略其它代码... -->
</view>

<!-- 搜索历史 -->
<view class="history-box" v-else>
  <!-- 省略其它代码... -->
</view>
```



### 8. 将搜索关键词存入 historyList

直接将搜索关键词 `push` 到 `historyList` 数组中即可

```js
methods: {
  // 根据搜索关键词，搜索商品建议列表
  async getSearchList() {
    // 省略其它不必要的代码...

    // 1. 查询到搜索建议之后，调用 saveSearchHistory() 方法保存搜索关键词
    this.saveSearchHistory()
  },
  // 2. 保存搜索关键词的方法
  saveSearchHistory() {
    // 2.1 直接把搜索关键词 push 到 historyList 数组中
    this.historyList.push(this.kw)
  }
}
```



上述实现思路存在的问题：

- 关键词**前后顺序**的问题（可以调用数组的 `reverse() 方法`对数组进行反转）
  - 方法一：最简单的解决办法（unshift 直接在数组前方插入数据）
  - 方法二：使用 reverse() 方法对数组进行反转
- 关键词**重复**的问题
  - 可以使用 [Set 对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)进行**去重操作**
  - includes
  - indexOf 查询索引，利用 splice 删除元素，通过 unshift 再次添加到数组



解决关键字前后顺序的问题

方法一：

~~~
this.historyList.unshift(this.kw)
~~~





1. data 中的 `historyList` 不做任何修改，依然使用 push 进行**末尾追加**
2. 定义一个计算属性 `historys`，将 `historyList` 数组 `reverse` 反转之后，就是此计算属性的值：

```js
computed: {
  histories() {
    // 注意：由于数组是引用类型，所以不要直接基于原数组调用 reverse 方法，以免修改原数组中元素的顺序
    // 而是应该新建一个内存无关的数组，再进行 reverse 反转
    return [...this.historyList].reverse()
  }
}
```



页面中渲染搜索关键词的时候，不再使用 data 中的 `historyList`，而是使用计算属性 `historys`

```xml
<view class="history-list">
  <uni-tag :text="item" v-for="(item, i) in histories" :key="i"></uni-tag>
</view>
```



解决关键词重复的问题

```js
// 保存搜索关键词为历史记录
saveSearchHistory() {
  // this.historyList.push(this.kw)

  // 1. 将 Array 数组转化为 Set 对象
  const set = new Set(this.historyList)
  // 2. 调用 Set 对象的 delete 方法，移除对应的元素
  set.delete(this.kw)
  // 3. 调用 Set 对象的 add 方法，向 Set 中添加元素
  set.add(this.kw)
  // 4. 将 Set 对象转化为 Array 数组
  this.historyList = Array.from(set)
}
```



### 9. 将搜索历史记录持久化存储到本地

修改 `saveSearchHistory` 方法如下：

```js
// 保存搜索关键词为历史记录
saveSearchHistory() {
  const set = new Set(this.historyList)
  // 删除搜索关键词
  set.delete(this.kw)
    // 添加搜索关键词（确保把关键词放在数组的最后一位）
  set.add(this.kw)
    // 转换为数组
  this.historyList = Array.from(set)
  // 调用 uni.setStorageSync(key, value) 将搜索历史记录持久化存储到本地
  uni.setStorageSync('kw', JSON.stringify(this.historyList))
}
```



在 `onLoad` 生命周期函数中，加载本地存储的搜索历史记录：

```js
onLoad() {
  this.historyList = JSON.parse(uni.getStorageSync('kw') || '[]')
}
```



### 10. 清空搜索历史记录

为清空的图标按钮绑定 `click` 事件：

```xml
<uni-icons type="trash" size="17" @click="cleanHistory"></uni-icons>
```



在 `methods` 中定义 `cleanHistory` 处理函数：

```js
// 清空搜索历史记录
cleanHistory() {
  // 清空 data 中保存的搜索历史
  this.historyList = []
  // 清空本地存储中记录的搜索历史
  uni.setStorageSync('kw', '[]')
}
```

> 对本地数据索引为 kw 的数据重新赋值，也可以直接调用 `uni.removeStorageSync('kw')`



### 11. 点击搜索历史跳转到商品列表页面

为搜索历史的 Item 项绑定 `click` 事件处理函数：

```xml
<uni-tag :text="item" v-for="(item, i) in historys" :key="i" @click="gotoGoodsList(item)"></uni-tag>
```



在 `methods` 中定义 `gotoGoodsList` 处理函数：

```js
// 点击跳转到商品列表页面
gotoGoodsList(kw) {
  uni.navigateTo({
    url: '/subpkg/goods_list/goods_list?query=' + kw
  })
}
```



## 11. 商品列表页面

小程序开发者工具添加自定义编译模式

![image-20220517190259738](images/mini_program/image-20220517190259738.png)



### 1. 定义请求参数对象

为了方便发起请求获取商品列表的数据，我们要根据接口的要求，事先定义一个**请求参数对象**：

```js
data() {
  return {
    // 请求参数对象
    queryObj: {
      // 查询关键词
      query: '',
      // 商品分类Id
      cid: '',
      // 页码值
      pagenum: 1,
      // 每页显示多少条数据
      pagesize: 10
    }
  }
}
```



将页面跳转时**携带的参数**，转存到 `queryObj` 对象中：

```js
onLoad(options) {
  // 将页面参数转存到 this.queryObj 对象中
  this.queryObj.query = options.query || ''
  this.queryObj.cid = options.cid || ''
}
```



### 2. 获取商品数据

在 data 中新增如下的数据节点：

```js
data() {
  return {
    // 商品列表的数据
    goodsList: [],
    // 总数量，用来实现分页
    total: 0
  }
}
```



在 `onLoad` 生命周期函数中，调用 `getGoodsList` 方法获取商品列表数据：

```js
onLoad(options) {
  // 调用获取商品列表数据的方法
  this.getGoodsList()
}
```



在 `methods` 节点中，声明 `getGoodsList` 方法如下：

```js
methods: {
  // 获取商品列表数据的方法
  async getGoodsList() {
    // 发起请求
    const { data: res } = await uni.$http.get('/api/public/v1/goods/search', this.queryObj)
    if (res.meta.status !== 200) return uni.$showMsg()
    // 为数据赋值
    this.goodsList = res.message.goods
    this.total = res.message.total
  }
}
```



### 3. 渲染商品列表结构

在页面中，通过 `v-for` 指令，循环渲染出商品的 UI 结构：

```xml
<template>
  <view>
    <view class="goods-list">
      <block v-for="(goods, i) in goodsList" :key="i">
        <view class="goods-item">
          <!-- 商品左侧图片区域 -->
          <view class="goods-item-left">
            <image :src="goods.goods_small_logo class="goods-pic"></image>
          </view>
          <!-- 商品右侧信息区域 -->
          <view class="goods-item-right">
            <!-- 商品标题 -->
            <view class="goods-name">{{goods.goods_name}}</view>
            <view class="goods-info-box">
              <!-- 商品价格 -->
              <view class="goods-price">￥{{goods.goods_price}}</view>
            </view>
          </view>
        </view>
      </block>
    </view>
  </view>
</template>
```



为了防止某些商品的图片不存在，需要在 data 中定义一个默认的图片：

```js
data() {
  return {
    // 默认的空图片
    defaultPic: 'https://img3.doubanio.com/f/movie/8dd0c794499fe925ae2ae89ee30cd225750457b4/pics/movie/celebrity-default-medium.png'
  }
}
```



并在页面渲染时按需使用：

```xml
<image :src="goods.goods_small_logo || defaultPic" class="goods-pic"></image>
```



美化商品列表的 UI 结构：

```scss
.goods-item {
  display: flex;
  padding: 10px 5px;
  border-bottom: 1px solid #f0f0f0;

  .goods-item-left {
    margin-right: 5px;

    .goods-pic {
      width: 100px;
      height: 100px;
      display: block;
    }
  }

  .goods-item-right {
    display: flex;
    flex-direction: column;
    justify-content: space-between;

    .goods-name {
      font-size: 13px;
    }

    .goods-price {
      font-size: 16px;
      color: #c00000;
    }
  }
}
```



### 4. 封装 Goods 组件

在 `components` 目录上鼠标右键，选择 `新建组件`：

![image-20220517195856104](images/mini_program/image-20220517195856104.png)



将 `goods_list` 页面中，关于商品 item 项相关的 UI 结构、样式、data 数据，封装到 `my-goods` 组件中：

```html
<template>
  <view class="goods-item">
    <!-- 商品左侧图片区域 -->
    <view class="goods-item-left">
      <image :src="goods.goods_small_logo || defaultPic" class="goods-pic"></image>
    </view>
    <!-- 商品右侧信息区域 -->
    <view class="goods-item-right">
      <!-- 商品标题 -->
      <view class="goods-name">{{goods.goods_name}}</view>
      <view class="goods-info-box">
        <!-- 商品价格 -->
        <view class="goods-price">￥{{goods.goods_price}}</view>
      </view>
    </view>
  </view>
</template>

<script>
  export default {
    // 定义 props 属性，用来接收外界传递到当前组件的数据
    props: {
      // 商品的信息对象
      goods: {
        type: Object,
        defaul: {},
      },
    },
    data() {
      return {
        // 默认的空图片
        defaultPic: 'https://img3.doubanio.com/f/movie/8dd0c794499fe925ae2ae89ee30cd225750457b4/pics/movie/celebrity-default-medium.png',
      }
    },
  }
</script>

<style lang="scss">
  .goods-item {
    display: flex;
    padding: 10px 5px;
    border-bottom: 1px solid #f0f0f0;

    .goods-item-left {
      margin-right: 5px;

      .goods-pic {
        width: 100px;
        height: 100px;
        display: block;
      }
    }

    .goods-item-right {
      display: flex;
      flex-direction: column;
      justify-content: space-between;

      .goods-name {
        font-size: 13px;
      }

      .goods-price {
        font-size: 16px;
        color: #c00000;
      }
    }
  }
</style>
```



在 `goods_list` 组件中，循环渲染 `my-goods` 组件即可：

```xml
<view class="goods-list">
  <block v-for="(goods, i) in goodsList" :key="i">
    <!-- 为 my-goods 组件动态绑定 goods 属性的值 -->
    <my-goods :goods="goods"></my-goods>
  </block>
</view>
```



### 5.使用过滤器处理价格

在 `my-goods` 组件中，和 `data` 节点平级，声明 `filters` 过滤器节点如下：

```js
filters: {
  // 把数字处理为带两位小数点的数字
  tofixed(num) {
    return Number(num).toFixed(2)
  }
}
```



在渲染商品价格的时候，通过管道符 `|` 调用过滤器：

```xml
<!-- 商品价格 -->
<view class="goods-price">￥{{goods.goods_price | tofixed}}</view>
```



### 6. 上拉加载更多

打开项目根目录中的 `pages.json` 配置文件，为 `subPackages` 分包中的 `goods_list` 页面配置上拉触底的距离：

```js
 "subPackages": [
   {
     "root": "subpkg",
     "pages": [
       {
         "path": "goods_detail/goods_detail",
         "style": {}
       },
       {
         "path": "goods_list/goods_list",
         "style": {
           "onReachBottomDistance": 150
         }
       },
       {
         "path": "search/search",
         "style": {}
       }
     ]
   }
 ]
```



在 `goods_list` 页面中，和 `methods` 节点平级，声明 `onReachBottom` 事件处理函数，用来监听页面的上拉触底行为：

```js
// 触底的事件
onReachBottom() {
  // 让页码值自增 +1
  this.queryObj.pagenum += 1
  // 重新获取列表数据
  this.getGoodsList()
}
```



改造 `methods` 中的 `getGoodsList` 函数，当列表数据请求成功之后，进行新旧数据的拼接处理：

```js
// 获取商品列表数据的方法
async getGoodsList() {
  // 发起请求
  const { data: res } = await uni.$http.get('/api/public/v1/goods/search', this.queryObj)
  if (res.meta.status !== 200) return uni.$showMsg()

  // 为数据赋值：通过展开运算符的形式，进行新旧数据的拼接
  this.goodsList = [...this.goodsList, ...res.message.goods]
  this.total = res.message.total
}
```



### 7. 通过节流阀防止发起额外的请求

在 data 中定义 `isloading` 节流阀如下：

```js
data() {
  return {
    // 是否正在请求数据
    isloading: false
  }
}
```



修改 `getGoodsList` 方法，在请求数据前后，分别打开和关闭节流阀：

```js
// 获取商品列表数据的方法
async getGoodsList() {
  // ** 打开节流阀
  this.isloading = true
  // 发起请求
  const { data: res } = await uni.$http.get('/api/public/v1/goods/search', this.queryObj)
  // ** 关闭节流阀
  this.isloading = false

  // 省略其它代码...
}
```



在 `onReachBottom` 触底事件处理函数中，根据节流阀的状态，来决定是否发起请求：

```js
// 触底的事件
onReachBottom() {
  // 判断是否正在请求其它数据，如果是，则不发起额外的请求
  if (this.isloading) return

  this.queryObj.pagenum += 1
  this.getGoodsList()
}
```



### 8. 判断数据是否加载完毕

如果下面的公式成立，则证明没有下一页数据了：

```text
当前的页码值 * 每页显示多少条数据 >= 总数条数
pagenum * pagesize >= total
```



修改 `onReachBottom` 事件处理函数如下：

```js
// 触底的事件
onReachBottom() {
  // 判断是否还有下一页数据
  if (this.queryObj.pagenum * this.queryObj.pagesize >= this.total) return uni.$showMsg('数据加载完毕！')

  // 判断是否正在请求其它数据，如果是，则不发起额外的请求
  if (this.isloading) return

  this.queryObj.pagenum += 1
  this.getGoodsList()
}
```



### 9. 下拉刷新

在 `pages.json` 配置文件中，为当前的 `goods_list` 页面单独开启下拉刷新效果：

```js
"subPackages": [{
  "root": "subpkg",
  "pages": [{
    "path": "goods_detail/goods_detail",
    "style": {}
  }, {
    "path": "goods_list/goods_list",
    "style": {
      "onReachBottomDistance": 150,
      "enablePullDownRefresh": true,
      "backgroundColor": "#F8F8F8"
    }
  }, {
    "path": "search/search",
    "style": {}
  }]
}]
```



监听页面的 `onPullDownRefresh` 事件处理函数：

```js
// 下拉刷新的事件
onPullDownRefresh() {
  // 1. 重置关键数据
  this.queryObj.pagenum = 1
  this.total = 0
  this.isloading = false
  this.goodsList = []

  // 2. 重新发起请求
  this.getGoodsList(() => uni.stopPullDownRefresh())
}
```



修改 `getGoodsList` 函数，接收 `cb` 回调函数并按需进行调用：

```js
// 获取商品列表数据的方法
async getGoodsList(cb) {
  this.isloading = true
  const { data: res } = await uni.$http.get('/api/public/v1/goods/search', this.queryObj)
  this.isloading = false
  // 只要数据请求完毕，就立即按需调用 cb 回调函数
  cb && cb()

  if (res.meta.status !== 200) return uni.$showMsg()
  this.goodsList = [...this.goodsList, ...res.message.goods]
  this.total = res.message.total
}
```



### 10. 点击商品 item 项跳转到详情页面

将循环时的 `block` 组件修改为 `view` 组件，并绑定 `click` 点击事件处理函数：

```xml
<view class="goods-list">
  <view v-for="(item, i) in goodsList" :key="i" @click="gotoDetail(item)">
    <!-- 为 my-goods 组件动态绑定 goods 属性的值 -->
    <my-goods :goods="item"></my-goods>
  </view>
</view>
```



在 `methods` 节点中，定义 `gotoDetail` 事件处理函数：

```js
// 点击跳转到商品详情页面
gotoDetail(item) {
  uni.navigateTo({
    url: '/subpkg/goods_detail/goods_detail?goods_id=' + item.goods_id
  })
}
```



## 12. 商品详情

### 1. 获取商品详情数据

在微信开发者工具中，点击工具栏上的编译模式下拉菜单，选择 `添加编译模式` 选项：

![image-20220517210252784](images/mini_program/image-20220517210252784.png)



在 `data` 中定义商品详情的数据节点：

```js
data() {
  return {
    // 商品详情对象
    goods_info: {}
  }
}
```



在 `onLoad` 中获取商品的 Id，并调用请求商品详情的方法：

```js
onLoad(options) {
  // 获取商品 Id
  const goods_id = options.goods_id
  // 调用请求商品详情数据的方法
  this.getGoodsDetail(goods_id)
}
```



在 `methods` 中声明 `getGoodsDetail` 方法：

```js
methods: {
  // 定义请求商品详情数据的方法
  async getGoodsDetail(goods_id) {
    const { data: res } = await uni.$http.get('/api/public/v1/goods/detail', { goods_id })
    if (res.meta.status !== 200) return uni.$showMsg()
    // 为 data 中的数据赋值
    this.goods_info = res.message
  }
}
```



### 2. 渲染轮播图区域

使用 `v-for` 指令，循环渲染如下的轮播图 UI 结构：

```xml
<!-- 轮播图区域 -->
<swiper :indicator-dots="true" :autoplay="true" :interval="3000" :duration="1000" :circular="true">
  <swiper-item v-for="(item, i) in goods_info.pics" :key="i">
    <image :src="item.pics_big"></image>
  </swiper-item>
</swiper>
```



美化轮播图的样式：

```scss
swiper {
  height: 750rpx;

  image {
    width: 100%;
    height: 100%;
  }
}
```



为轮播图中的 `image` 图片绑定 `click` 事件处理函数：

```xml
<swiper-item v-for="(item, i) in goods_info.pics" :key="i">
  <!-- 把当前点击的图片的索引，传递到 preview() 处理函数中 -->
  <image :src="item.pics_big" @click="preview(i)"></image>
</swiper-item>
```



在 `methods` 中定义 `preview` 事件处理函数：

```js
// 实现轮播图的预览效果
preview(i) {
  // 调用 uni.previewImage() 方法预览图片
  uni.previewImage({
    // 预览时，默认显示图片的索引
    current: i,
    // 所有图片 url 地址的数组
    urls: this.goods_info.pics.map(x => x.pics_big)
  })
}
```



### 3. 渲染商品信息区域

定义商品信息区域的 UI 结构如下：

```xml
<!-- 商品信息区域 -->
<view class="goods-info-box">
  <!-- 商品价格 -->
  <view class="price">￥{{goods_info.goods_price}}</view>
  <!-- 信息主体区域 -->
  <view class="goods-info-body">
    <!-- 商品名称 -->
    <view class="goods-name">{{goods_info.goods_name}}</view>
    <!-- 收藏 -->
    <view class="favi">
      <uni-icons type="star" size="18" color="gray"></uni-icons>
      <text>收藏</text>
    </view>
  </view>
  <!-- 运费 -->
  <view class="yf">快递：免运费</view>
</view>
```



美化商品信息区域的样式：

```scss
// 商品信息区域的样式
.goods-info-box {
  padding: 10px;
  padding-right: 0;

  .price {
    color: #c00000;
    font-size: 18px;
    margin: 10px 0;
  }

  .goods-info-body {
    display: flex;
    justify-content: space-between;

    .goods-name {
      font-size: 13px;
      padding-right: 10px;
    }
    // 收藏区域
    .favi {
      width: 120px;
      font-size: 12px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      border-left: 1px solid #efefef;
      color: gray;
    }
  }

  // 运费
  .yf {
    margin: 10px 0;
    font-size: 12px;
    color: gray;
  }
}
```



### 4. 渲染商品详情信息

在页面结构中，使用 `rich-text` 组件，将带有 HTML 标签的内容，渲染为小程序的页面结构：

```xml
<!-- 商品详情信息 -->
<rich-text :nodes="goods_info.goods_introduce"></rich-text>
```



修改 `getGoodsDetail` 方法，从而解决图片底部 `空白间隙` 的问题：

```js
// 定义请求商品详情数据的方法
async getGoodsDetail(goods_id) {
  const { data: res } = await uni.$http.get('/api/public/v1/goods/detail', { goods_id })
  if (res.meta.status !== 200) return uni.$showMsg()

  // 使用字符串的 replace() 方法，为 img 标签添加行内的 style 样式，从而解决图片底部空白间隙的问题
  res.message.goods_introduce = res.message.goods_introduce.replace(/<img /g, '<img style="display:block;" ')
  this.goods_info = res.message
}
```



解决 `.webp` 格式图片在 `ios` 设备上无法正常显示的问题：

```js
// 定义请求商品详情数据的方法
async getGoodsDetail(goods_id) {
  const { data: res } = await uni.$http.get('/api/public/v1/goods/detail', { goods_id })
  if (res.meta.status !== 200) return uni.$showMsg()

  // 使用字符串的 replace() 方法，将 webp 的后缀名替换为 jpg 的后缀名
  res.message.goods_introduce = res.message.goods_introduce.replace(/<img /g, '<img style="display:block;" ').replace(/webp/g, 'jpg')
  this.goods_info = res.message
}
```



### 5. 解决商品价格闪烁的问题

1. 导致问题的原因：在商品详情数据请求回来之前，data 中 `goods_info` 的值为 `{}`，因此初次渲染页面时，会导致 `商品价格、商品名称` 等闪烁的问题。
2. 解决方案：判断 `goods_info.goods_name` 属性的值是否存在，从而使用 `v-if` 指令控制页面的显示与隐藏：

```xml
<template>
  <view v-if="goods_info.goods_name">
   <!-- 省略其它代码 -->
  </view>
</template>
```



### 6. 渲染商品导航区域的 UI 结构

> 基于 uni-ui 提供的 [GoodsNav](https://ext.dcloud.net.cn/plugin?id=865) 组件来实现商品导航区域的效果

在 data 中，通过 `options` 和 `buttonGroup` 两个数组，来声明商品导航组件的按钮配置对象：

```js
data() {
  return {
    // 商品详情对象
    goods_info: {},
    // 左侧按钮组的配置对象
    options: [{
      icon: 'shop',
      text: '店铺'
    }, {
      icon: 'cart',
      text: '购物车',
      info: 2
    }],
    // 右侧按钮组的配置对象
    buttonGroup: [{
        text: '加入购物车',
        backgroundColor: '#ff0000',
        color: '#fff'
      },
      {
        text: '立即购买',
        backgroundColor: '#ffa200',
        color: '#fff'
      }
    ]
  }
}
```



在页面中使用 `uni-goods-nav` 商品导航组件：

```xml
<!-- 商品导航组件 -->
<view class="goods_nav">
  <!-- fill 控制右侧按钮的样式 -->
  <!-- options 左侧按钮的配置项 -->
  <!-- buttonGroup 右侧按钮的配置项 -->
  <!-- click 左侧按钮的点击事件处理函数 -->
  <!-- buttonClick 右侧按钮的点击事件处理函数 -->
  <uni-goods-nav :fill="true" :options="options" :buttonGroup="buttonGroup" @click="onClick" @buttonClick="buttonClick" />
</view>
```



美化商品导航组件，使之固定在页面最底部：

```scss
.goods-detail-container {
  // 给页面外层的容器，添加 50px 的内padding，
  // 防止页面内容被底部的商品导航组件遮盖
  padding-bottom: 50px;
}

.goods_nav {
  // 为商品导航组件添加固定定位
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
}
```



### 7. 点击跳转到购物车页面

点击商品导航组件左侧的按钮，会触发 `uni-goods-nav` 的 `@click` 事件处理函数，事件对象 `e` 中会包含当前点击的按钮相关的信息：

```js
// 左侧按钮的点击事件处理函数
onClick(e) {
  console.log(e)
}
```



打印的按钮信息对象如下：

![image-20220517221653605](images/mini_program/image-20220517221653605.png)



根据 `e.content.text` 的值，来决定进一步的操作：

```js
// 左侧按钮的点击事件处理函数
onClick(e) {
  if (e.content.text === '购物车') {
    // 切换到购物车页面
    uni.switchTab({
      url: '/pages/cart/cart'
    })
  }
}
```



## 13. 加入购物车

### 1. 配置 vuex

1. 在项目根目录中创建 `store` 文件夹，专门用来存放 vuex 相关的模块
2. 在 `store` 目录上鼠标右键，选择 `新建 -> js文件`，新建 `store.js` 文件：

![image-20220519135412194](images/mini_program/image-20220519135412194.png)



在 `store.js` 中按照如下 4 个步骤**初始化 Store 的实例对象**：

```js
// 1. 导入 Vue 和 Vuex
import Vue from 'vue'
import Vuex from 'vuex'

// 2. 将 Vuex 安装为 Vue 的插件
Vue.use(Vuex)

// 3. 创建 Store 的实例对象
const store = new Vuex.Store({
  // TODO：挂载 store 模块
  modules: {},
})

// 4. 向外共享 Store 的实例对象
export default store
```



在 `main.js` 中导入 `store` 实例对象并挂载到 Vue 的实例上：

```js
// 1. 导入 store 的实例对象
import store from './store/store.js'

// 省略其它代码...

const app = new Vue({
  ...App,
  // 2. 将 store 挂载到 Vue 实例上
  store,
})
app.$mount()
```



### 2. 创建购物车的 store 模块

在 `store` 目录上鼠标右键，选择 `新建 -> js文件`，创建购物车的 store 模块，命名为 `cart.js`：

![image-20220519135644956](images/mini_program/image-20220519135644956.png)



在 `cart.js` 中，初始化如下的 vuex 模块：

```js
export default {
  // 为当前模块开启命名空间
  namespaced: true,

  // 模块的 state 数据
  state: () => ({
    // 购物车的数组，用来存储购物车中每个商品的信息对象
    // 每个商品的信息对象，都包含如下 6 个属性：
    // { goods_id, goods_name, goods_price, goods_count, goods_small_logo, goods_state }
    cart: [],
  }),

  // 模块的 mutations 方法
  mutations: {},

  // 模块的 getters 属性
  getters: {},
}
```



在 `store/store.js` 模块中，导入并挂载购物车的 vuex 模块，示例代码如下：

```js
import Vue from 'vue'
import Vuex from 'vuex'
// 1. 导入购物车的 vuex 模块
import moduleCart from './cart.js'

Vue.use(Vuex)

const store = new Vuex.Store({
  // TODO：挂载 store 模块
  modules: {
    // 2. 挂载购物车的 vuex 模块，模块内成员的访问路径被调整为 m_cart，例如：
    //    购物车模块中 cart 数组的访问路径是 m_cart/cart
    m_cart: moduleCart,
  },
})

export default store
```



### 3. 在商品详情页中使用 Store 中的数据

在 `goods_detail.vue` 页面中，修改 `<script></script>` 标签中的代码如下：

```js
// 从 vuex 中按需导出 mapState 辅助方法
import { mapState } from 'vuex'

export default {
  computed: {
    // 调用 mapState 方法，把 m_cart 模块中的 cart 数组映射到当前页面中，作为计算属性来使用
    // ...mapState('模块的名称', ['要映射的数据名称1', '要映射的数据名称2'])
    ...mapState('m_cart', ['cart']),
  },
  // 省略其它代码...
}
```

> **注意：今后无论映射 mutations 方法，还是 getters 属性，还是 state 中的数据，都需要指定模块的名称，才能进行映射。**



在页面渲染时，可以直接使用映射过来的数据，例如：

```xml
<!-- 运费 -->
<view class="yf">快递：免运费 -- {{cart.length}}</view>
```



### 4. 实现加入购物车的功能

在 store 目录下的 `cart.js` 模块中，封装一个将商品信息加入购物车的 mutations 方法，命名为 `addToCart`。示例代码如下：

```js
export default {
  // 为当前模块开启命名空间
  namespaced: true,

  // 模块的 state 数据
  state: () => ({
    // 购物车的数组，用来存储购物车中每个商品的信息对象
    // 每个商品的信息对象，都包含如下 6 个属性：
    // { goods_id, goods_name, goods_price, goods_count, goods_small_logo, goods_state }
    cart: [],
  }),

  // 模块的 mutations 方法
  mutations: {
    addToCart(state, goods) {
      // 根据提交的商品的Id，查询购物车中是否存在这件商品
      // 如果不存在，则 findResult 为 undefined；否则，为查找到的商品信息对象
      const findResult = state.cart.find((x) => x.goods_id === goods.goods_id)

      if (!findResult) {
        // 如果购物车中没有这件商品，则直接 push
        state.cart.push(goods)
      } else {
        // 如果购物车中有这件商品，则只更新数量即可
        findResult.goods_count++
      }
    },
  },

  // 模块的 getters 属性
  getters: {},
}
```



在商品详情页面中，通过 `mapMutations` 这个辅助方法，把 vuex 中 `m_cart` 模块下的 `addToCart` 方法映射到当前页面：

```js
// 按需导入 mapMutations 这个辅助方法
import { mapMutations } from 'vuex'

export default {
  methods: {
    // 把 m_cart 模块中的 addToCart 方法映射到当前页面使用
    ...mapMutations('m_cart', ['addToCart']),
  },
}
```



为商品导航组件 `uni-goods-nav` 绑定 `@buttonClick="buttonClick"` 事件处理函数：

```js
// 右侧按钮的点击事件处理函数
buttonClick(e) {
   // 1. 判断是否点击了 加入购物车 按钮
   if (e.content.text === '加入购物车') {

      // 2. 组织一个商品的信息对象
      const goods = {
         goods_id: this.goods_info.goods_id,       // 商品的Id
         goods_name: this.goods_info.goods_name,   // 商品的名称
         goods_price: this.goods_info.goods_price, // 商品的价格
         goods_count: 1,                           // 商品的数量
         goods_small_logo: this.goods_info.goods_small_logo, // 商品的图片
         goods_state: true                         // 商品的勾选状态
      }

      // 3. 通过 this 调用映射过来的 addToCart 方法，把商品信息对象存储到购物车中
      this.addToCart(goods)

   }
}
```



### 5. 动态统计购物车中商品的总数量

在 `cart.js` 模块中，在 `getters` 节点下定义一个 `total` 方法，用来统计购物车中商品的总数量：

```js
// 模块的 getters 属性
getters: {
   // 统计购物车中商品的总数量
   total(state) {
      let c = 0
      // 循环统计商品的数量，累加到变量 c 中
      state.cart.forEach(goods => c += goods.goods_count)
      return c
   }
}
```



在商品详情页面的 `script` 标签中，按需导入 `mapGetters` 方法并进行使用：

```js
// 按需导入 mapGetters 这个辅助方法
import { mapGetters } from 'vuex'

export default {
  computed: {
    // 把 m_cart 模块中名称为 total 的 getter 映射到当前页面中使用
    ...mapGetters('m_cart', ['total']),
  },
}
```



通过 `watch` 侦听器，监听计算属性 `total` 值的变化，从而**动态为购物车按钮的徽标赋值**：

```js
export default {
  watch: {
    // 1. 监听 total 值的变化，通过第一个形参得到变化后的新值
    total(newVal) {
      // 2. 通过数组的 find() 方法，找到购物车按钮的配置对象
      const findResult = this.options.find((x) => x.text === '购物车')

      if (findResult) {
        // 3. 动态为购物车按钮的 info 属性赋值
        findResult.info = newVal
      }
    },
  },
}
```



### 6. 持久化存储购物车中的商品

在 `cart.js` 模块中，声明一个叫做 `saveToStorage` 的 mutations 方法，此方法负责将购物车中的数据持久化存储到本地：

```js
// 将购物车中的数据持久化存储到本地
saveToStorage(state) {
   uni.setStorageSync('cart', JSON.stringify(state.cart))
}
```



修改 `mutations` 节点中的 `addToCart` 方法，在处理完商品信息后，调用步骤 1 中定义的 `saveToStorage` 方法：

```js
addToCart(state, goods) {
   // 根据提交的商品的Id，查询购物车中是否存在这件商品
   // 如果不存在，则 findResult 为 undefined；否则，为查找到的商品信息对象
   const findResult = state.cart.find(x => x.goods_id === goods.goods_id)

   if (!findResult) {
      // 如果购物车中没有这件商品，则直接 push
      state.cart.push(goods)
   } else {
      // 如果购物车中有这件商品，则只更新数量即可
      findResult.goods_count++
   }

   // 通过 commit 方法，调用 m_cart 命名空间下的 saveToStorage 方法
   this.commit('m_cart/saveToStorage')
}
```



修改 `cart.js` 模块中的 `state` 函数，读取本地存储的购物车数据，对 cart 数组进行初始化：

```js
// 模块的 state 数据
state: () => ({
   // 购物车的数组，用来存储购物车中每个商品的信息对象
   // 每个商品的信息对象，都包含如下 6 个属性：
   // { goods_id, goods_name, goods_price, goods_count, goods_small_logo, goods_state }
   cart: JSON.parse(uni.getStorageSync('cart') || '[]')
}),
```



### 7. 优化商品详情页的 total 侦听器

使用**普通函数的形式**定义的 watch 侦听器，**在页面首次加载后不会被调用**。因此导致了商品详情页在首次加载完毕之后，不会将商品的总数量显示到商品导航区域：

```js
watch: {
   // 页面首次加载完毕后，不会调用这个侦听器
   total(newVal) {
      const findResult = this.options.find(x => x.text === '购物车')
      if (findResult) {
         findResult.info = newVal
      }
   }
}
```



为了防止这个上述问题，可以使用**对象的形式**来定义 watch 侦听器（详细文档请参考 Vue 官方的 [watch 侦听器](https://cn.vuejs.org/v2/api/#watch)教程），示例代码如下：

```js
watch: {
   // 定义 total 侦听器，指向一个配置对象
   total: {
      // handler 属性用来定义侦听器的 function 处理函数
      handler(newVal) {
         const findResult = this.options.find(x => x.text === '购物车')
         if (findResult) {
            findResult.info = newVal
         }
      },
      // immediate 属性用来声明此侦听器，是否在页面初次加载完毕后立即调用
      immediate: true
   }
}
```



### 8. 动态为 tabBar 页面设置数字徽标

> 需求描述：从商品详情页面导航到购物车页面之后，需要为 tabBar 中的购物车动态设置数字徽标。



把 Store 中的 total 映射到 `cart.vue` 中使用：

```js
// 按需导入 mapGetters 这个辅助方法
import { mapGetters } from 'vuex'

export default {
  data() {
    return {}
  },
  computed: {
    // 将 m_cart 模块中的 total 映射为当前页面的计算属性
    ...mapGetters('m_cart', ['total']),
  },
}
```



在页面刚显示出来的时候，立即调用 `setBadge` 方法，为 tabBar 设置数字徽标：

```js
onShow() {
   // 在页面刚展示的时候，设置数字徽标
   this.setBadge()
}
```



在 `methods` 节点中，声明 `setBadge` 方法如下，通过 `uni.setTabBarBadge()` 为 tabBar 设置数字徽标：

```js
methods: {
   setBadge() {
      // 调用 uni.setTabBarBadge() 方法，为购物车设置右上角的徽标
      uni.setTabBarBadge({
         index: 2, // 索引
         text: this.total + '' // 注意：text 的值必须是字符串，不能是数字
      })
   }
}
```



### 9. 将设置 tabBar 徽标的代码抽离为 mixins

> 注意：除了要在 cart.vue 页面中设置购物车的数字徽标，还需要在其它 3 个 tabBar 页面中，为购物车设置数字徽标。

> 此时可以使用 Vue 提供的 [mixins](https://cn.vuejs.org/v2/guide/mixins.html) 特性，提高代码的可维护性。



在项目根目录中新建 `mixins` 文件夹，并在 `mixins` 文件夹之下新建 `tabbar-badge.js` 文件，用来把设置 tabBar 徽标的代码封装为一个 mixin 文件：

```js
import { mapGetters } from 'vuex'

// 导出一个 mixin 对象
export default {
  computed: {
    ...mapGetters('m_cart', ['total']),
  },
  onShow() {
    // 在页面刚展示的时候，设置数字徽标
    this.setBadge()
  },
  methods: {
    setBadge() {
      // 调用 uni.setTabBarBadge() 方法，为购物车设置右上角的徽标
      uni.setTabBarBadge({
        index: 2,
        text: this.total + '', // 注意：text 的值必须是字符串，不能是数字
      })
    },
  },
}
```



修改 `home.vue`，`cate.vue`，`cart.vue`，`my.vue` 这 4 个 tabBar 页面的源代码，分别导入 `@/mixins/tabbar-badge.js` 模块并进行使用：

```js
// 导入自己封装的 mixin 模块
import badgeMix from '@/mixins/tabbar-badge.js'

export default {
  // 将 badgeMix 混入到当前的页面中进行使用
  mixins: [badgeMix],
  // 省略其它代码...
}
```



## 14. 购物车页面

### 1. 商品列表区域

#### 1.1 渲染购物车商品列表的标题区域

1. 定义如下的 UI 结构：

   ```xml
   <!-- 购物车商品列表的标题区域 -->
   <view class="cart-title">
     <!-- 左侧的图标 -->
     <uni-icons type="shop" size="18"></uni-icons>
     <!-- 描述文本 -->
     <text class="cart-title-text">购物车</text>
   </view>
   ```

2. 美化样式：

   ```scss
   .cart-title {
     height: 40px;
     display: flex;
     align-items: center;
     font-size: 14px;
     padding-left: 5px;
     border-bottom: 1px solid #efefef;
     .cart-title-text {
       margin-left: 10px;
     }
   }
   ```



#### 1.2 渲染商品列表区域的基本结构

1. 通过 `mapState` 辅助函数，将 Store 中的 `cart` 数组映射到当前页面中使用：

   ```js
   import badgeMix from '@/mixins/tabbar-badge.js'
   // 按需导入 mapState 这个辅助函数
   import { mapState } from 'vuex'
   
   export default {
     mixins: [badgeMix],
     computed: {
       // 将 m_cart 模块中的 cart 数组映射到当前页面中使用
       ...mapState('m_cart', ['cart']),
     },
     data() {
       return {}
     },
   }
   ```

2. 在 UI 结构中，通过 `v-for` 指令循环渲染自定义的 `my-goods` 组件：

   ```xml
   <!-- 商品列表区域 -->
   <block v-for="(goods, i) in cart" :key="i">
     <my-goods :goods="goods"></my-goods>
   </block>
   ```



#### 1.3 为 my-goods 组件封装 radio 勾选状态

1. 打开 `my-goods.vue` 组件的源代码，为商品的左侧图片区域添加 `radio` 组件：

   ```xml
   <!-- 商品左侧图片区域 -->
   <view class="goods-item-left">
     <radio checked color="#C00000"></radio>
     <image :src="goods.goods_small_logo || defaultPic" class="goods-pic"></image>
   </view>
   ```

2. 给类名为 `goods-item-left` 的 `view` 组件添加样式，实现 `radio` 组件和 `image` 组件的左右布局：

   ```css
   .goods-item-left {
     margin-right: 5px;
     display: flex;
     justify-content: space-between;
     align-items: center;
   
     .goods-pic {
       width: 100px;
       height: 100px;
       display: block;
     }
   }
   ```

3. 封装名称为 `showRadio` 的 `props` 属性，来控制当前组件中是否显示 radio 组件：

   ```js
   export default {
     // 定义 props 属性，用来接收外界传递到当前组件的数据
     props: {
       // 商品的信息对象
       goods: {
         type: Object,
         default: {},
       },
       // 是否展示图片左侧的 radio
       // 小驼峰命名方法，如果传入的属性值为 show-radio 的话
       showRadio: {
         type: Boolean,
         // 如果外界没有指定 show-radio 属性的值，则默认不展示 radio 组件
         default: false,
       },
     },
   }
   ```

4. 使用 `v-if` 指令控制 `radio` 组件的按需展示：

   ```xml
   <!-- 商品左侧图片区域 -->
   <view class="goods-item-left">
     <!-- 使用 v-if 指令控制 radio 组件的显示与隐藏 -->
     <radio checked color="#C00000" v-if="showRadio"></radio>
     <image :src="goods.goods_small_logo || defaultPic" class="goods-pic"></image>
   </view>
   ```

5. 在 `cart.vue` 页面中的商品列表区域，指定 `:show-radio="true"` 属性，从而显示 radio 组件：

   ```xml
   <!-- 商品列表区域 -->
   <block v-for="(goods, i) in cart" :key="i">
     <my-goods :goods="goods" :show-radio="true"></my-goods>
   </block>
   ```

6. 目前所有的 radio 都是 checked 状态，在代码中写死，需要通过 goods 中的属性 `goods.goods_state` 来判断物品的选中状态。

   修改 `my-goods.vue` 组件，动态为 `radio` 绑定选中状态：
   
   ```xml
   <!-- 商品左侧图片区域 -->
   <view class="goods-item-left">
     <!-- 存储在购物车中的商品，包含 goods_state 属性，表示商品的勾选状态 -->
     <radio :checked="goods.goods_state" color="#C00000" v-if="showRadio"></radio>
     <image :src="goods.goods_small_logo || defaultPic" class="goods-pic"></image>
   </view>
   ```



#### 1.4 为 my-goods 组件封装 radio-change 事件

1. 当用户点击 radio 组件，**希望修改当前商品的勾选状态**，但是我们不能在 my-goods 组件中直接更改 goods 中的数据，因为组件中的 goods 数据是 props，无法直接更改。我们的数据在父组件 cart.vue 上，所以需要做一个子传父通信操作。

   

   在子组件 `my-goods.vue` 组件中，为 `radio` 组件绑定 `@click` 事件处理函数如下：

   ```xml
   <!-- 商品左侧图片区域 -->
   <view class="goods-item-left">
     <radio :checked="goods.goods_state" color="#C00000" v-if="showRadio" @click="radioClickHandler"></radio>
     <image :src="goods.goods_small_logo || defaultPic" class="goods-pic"></image>
   </view>
   ```

   > 给 radio 元素绑定一个点击事件，触发子组件中的方法 radioClickHandler

   

2. 在 `my-goods.vue` 组件的 methods 节点中，定义 `radioClickHandler` 事件处理函数：

   通过 radioClickHandler 里边的 $emit 方法，触发父组件中调用子组件时绑定的方法，并将 goods_id 和 goods_state 当做参数传出去

   ```js
   methods: {
     // radio 组件的点击事件处理函数
     radioClickHandler() {
       // 通过 this.$emit() 触发外界通过 @ 绑定的 radio-change 事件，
       // 同时把商品的 Id 和 勾选状态 作为参数传递给 radio-change 事件处理函数
       this.$emit('radio-change', {
         // 商品的 Id
         goods_id: this.goods.goods_id,
         // 商品最新的勾选状态
         goods_state: !this.goods.goods_state
       })
     }
   }
   ```

   

3. 在父组件中为 `my-goods` 组件绑定自定义事件 `@radio-change` ，从而获取当前商品的 `goods_id` 和 `goods_state`：

   ```xml
   <!-- 商品列表区域 -->
   <block v-for="(goods, i) in cart" :key="i">
     <!-- 在 radioChangeHandler 事件处理函数中，通过事件对象 e，得到商品的 goods_id 和 goods_state -->
     <my-goods :goods="goods" :show-radio="true" @radio-change="radioChangeHandler"></my-goods>
   </block>
   ```

   

   定义 `radioChangeHandler` 事件处理函数如下：

   ```js
   methods: {
     // 商品的勾选状态发生了变化
     radioChangeHandler(e) {
       console.log(e) // 输出得到的数据 -> {goods_id: 395, goods_state: false}
     }
   }
   ```



#### 1.5 修改购物车中商品的勾选状态

现在我们拿到商品的 id 以及更改后的选中状态，那么就需要修改购物车中的 goods 数据，而购物车中的数据是保存在 store 中的，所以唯一修改 state 中数据的方法就是利用 mutations。

1. 在 `store/cart.js` 模块中，声明如下的 `mutations` 方法，用来修改对应商品的勾选状态：

   ```js
   // 更新购物车中商品的勾选状态
   updateGoodsState(state, goods) {
     // 根据 goods_id 查询购物车中对应商品的信息对象
     const findResult = state.cart.find(x => x.goods_id === goods.goods_id)
   
     // 有对应的商品信息对象
     if (findResult) {
       // 更新对应商品的勾选状态
       findResult.goods_state = goods.goods_state
       // 持久化存储到本地
       this.commit('m_cart/saveToStorage')
     }
   }
   ```

2. 在父组件 `cart.vue` 页面中，导入 `mapMutations` 这个辅助函数，从而将需要的 mutations 方法映射到当前页面中使用：

   ```js
   import badgeMix from '@/mixins/tabbar-badge.js'
   import { mapState, mapMutations } from 'vuex'
   
   export default {
     mixins: [badgeMix],
     computed: {
       ...mapState('m_cart', ['cart']),
     },
     data() {
       return {}
     },
     methods: {
       ...mapMutations('m_cart', ['updateGoodsState']),
       // 商品的勾选状态发生了变化
       radioChangeHandler(e) {
         this.updateGoodsState(e)
       },
     },
   }
   ```



#### 1.6 为 my-goods 组件封装 NumberBox

> 注意：[NumberBox](https://ext.dcloud.net.cn/plugin?id=31) 组件是 uni-ui 提供的

1. 修改 `my-goods.vue` 组件的源代码，在类名为 `goods-info-box` 的 view 组件内部渲染 `NumberBox` 组件的基本结构：

   ```xml
   <view class="goods-info-box">
     <!-- 商品价格 -->
     <view class="goods-price">￥{{goods.goods_price | tofixed}}</view>
     <!-- 商品数量 -->
     <uni-number-box :min="1"></uni-number-box>
   </view>
   ```

2. 美化页面的结构：

   ```scss
   .goods-item-right {
     display: flex;
     flex: 1;
     flex-direction: column;
     justify-content: space-between;
   
     .goods-name {
       font-size: 13px;
     }
   
     .goods-info-box {
       display: flex;
       align-items: center;
       justify-content: space-between;
     }
   
     .goods-price {
       font-size: 16px;
       color: #c00000;
     }
   }
   ```

3. 在 `my-goods.vue` 组件中，动态为 `NumberBox` 组件绑定商品的数量值：

   ```xml
   <view class="goods-info-box">
     <!-- 商品价格 -->
     <view class="goods-price">￥{{goods.goods_price | tofixed}}</view>
     <!-- 商品数量 -->
     <uni-number-box :min="1" :value="goods.goods_count"></uni-number-box>
   </view>
   ```

4. 现在的 Numberbox 组件和之前的 radio 选中框一样，都会在所有调用 my-goods 组件的页面中呈现，我们需要在 `my-goods.vue` 组件中，封装名称为 `showNum` 的 `props` 属性，来控制当前组件中是否显示 `NumberBox` 组件：

   ```js
   export default {
     // 定义 props 属性，用来接收外界传递到当前组件的数据
     props: {
       // 商品的信息对象
       goods: {
         type: Object,
         defaul: {},
       },
       // 是否展示图片左侧的 radio
       showRadio: {
         type: Boolean,
         // 如果外界没有指定 show-radio 属性的值，则默认不展示 radio 组件
         default: false,
       },
       // 是否展示价格右侧的 NumberBox 组件
       showNum: {
         type: Boolean,
         default: false,
       },
     },
   }
   ```

5. 在 `my-goods.vue` 组件中，使用 `v-if` 指令控制 `NumberBox` 组件的按需展示：

   ```xml
   <view class="goods-info-box">
     <!-- 商品价格 -->
     <view class="goods-price">￥{{goods.goods_price | tofixed}}</view>
     <!-- 商品数量 -->
     <uni-number-box :min="1" :value="goods.goods_count" @change="numChangeHandler" v-if="showNum"></uni-number-box>
   </view>
   ```

6. 在 `cart.vue` 页面中的商品列表区域，指定 `:show-num="true"` 属性，从而显示 `NumberBox` 组件：

   ```xml
   <!-- 商品列表区域 -->
   <block v-for="(goods, i) in cart" :key="i">
     <my-goods :goods="goods" :show-radio="true" :show-num="true" @radio-change="radioChangeHandler"></my-goods>
   </block>
   ```



#### 1.7 为 my-goods 组件封装 num-change 事件

1. 当用户修改了 `NumberBox` 的值以后，希望将最新的商品数量更新到购物车中，此时用户可以为 `my-goods` 组件绑定 `@num-change` 事件，从而获取当前商品的 `goods_id` 和 `goods_count：`

   ```xml
   <!-- 商品列表区域 -->
   <block v-for="(goods, i) in cart" :key="i">
     <my-goods :goods="goods" :show-radio="true" :show-num="true" @radio-change="radioChangeHandler" @num-change="numberChangeHandler"></my-goods>
   </block>
   ```

   定义 `numberChangeHandler` 事件处理函数如下：

   ```js
   // 商品的数量发生了变化
   numberChangeHandler(e) {
     console.log(e)
   }
   ```

2. 在 `my-goods.vue` 组件中，为 `uni-number-box` 组件绑定 `@change` 事件处理函数如下：

   ```xml
   <view class="goods-info-box">
     <!-- 商品价格 -->
     <view class="goods-price">￥{{goods.goods_price | tofixed}}</view>
     <!-- 商品数量 -->
     <uni-number-box :min="1" :value="goods.goods_count" @change="numChangeHandler"></uni-number-box>
   </view>
   ```

3. 在 `my-goods.vue` 组件的 `methods` 节点中，定义 `numChangeHandler` 事件处理函数：

   ```js
   methods: {
     // NumberBox 组件的 change 事件处理函数
     numChangeHandler(val) {
       // 通过 this.$emit() 触发外界通过 @ 绑定的 num-change 事件
       this.$emit('num-change', {
         // 商品的 Id
         goods_id: this.goods.goods_id,
         // 商品的最新数量，隐式转换为数字类型
         goods_count: +val
       })
     }
   }
   ```



#### 1.8 解决 NumberBox 数据不合法的问题（新版已修复）

> 问题说明：当用户在 NumberBox 中输入字母等非法字符之后，会导致 NumberBox 数据紊乱的问题

1. 打开项目根目录中 `components/uni-number-box/uni-number-box.vue` 组件，修改 `methods` 节点中的 `_onBlur` 函数如下：

   ```js
   _onBlur(event) {
     // 官方的代码没有进行数值转换，用户输入的 value 值可能是非法字符：
     // let value = event.detail.value;
   
     // 将用户输入的内容转化为整数
     let value = parseInt(event.detail.value);
   
     if (!value) {
       // 如果转化之后的结果为 NaN，则给定默认值为 1
       this.inputValue = 1;
       return;
     }
   
     // 省略其它代码...
   }
   ```

2. 修改完毕之后，用户输入**小数**会**被转化为整数**，用户输入**非法字符**会**被替换为默认值 1**



#### 1.9 完善 NumberBox 的 inputValue 侦听器（新版已修复）

> 问题说明：在用户每次输入内容之后，都会触发 inputValue 侦听器，从而调用 this.$emit("change", newVal) 方法。这种做法可能会把不合法的内容传递出去！

1. 打开项目根目录中 `components/uni-number-box/uni-number-box.vue` 组件，修改 `watch` 节点中的 `inputValue` 侦听器如下：

   ```js
   inputValue(newVal, oldVal) {
     // 官方提供的 if 判断条件，在用户每次输入内容时，都会调用 this.$emit("change", newVal)
     // if (+newVal !== +oldVal) {
   
     // 新旧内容不同 && 新值内容合法 && 新值中不包含小数点
     if (+newVal !== +oldVal && Number(newVal) && String(newVal).indexOf('.') === -1) {
       this.$emit("change", newVal);
     }
   }
   ```

2. 修改完毕之后，NumberBox 组件只会把**合法的、且不包含小数点的新值**传递出去



#### 1.10 修改购物车中商品的数量

1. 在 `store/cart.js` 模块中，声明如下的 mutations 方法，用来修改对应商品的数量：

   ```js
   // 更新购物车中商品的数量
   updateGoodsCount(state, goods) {
     // 根据 goods_id 查询购物车中对应商品的信息对象
     const findResult = state.cart.find(x => x.goods_id === goods.goods_id)
   
     if(findResult) {
       // 更新对应商品的数量
       findResult.goods_count = goods.goods_count
       // 持久化存储到本地
       this.commit('m_cart/saveToStorage')
     }
   }
   ```

2. 在 `cart.vue` 页面中，通过 `mapMutations` 这个辅助函数，将需要的 `mutations` 方法映射到当前页面中使用：

   ```js
   import badgeMix from '@/mixins/tabbar-badge.js'
   import { mapState, mapMutations } from 'vuex'
   
   export default {
     mixins: [badgeMix],
     computed: {
       ...mapState('m_cart', ['cart']),
     },
     data() {
       return {}
     },
     methods: {
       ...mapMutations('m_cart', ['updateGoodsState', 'updateGoodsCount']),
       // 商品的勾选状态发生了变化
       radioChangeHandler(e) {
         this.updateGoodsState(e)
       },
       // 商品的数量发生了变化
       numberChangeHandler(e) {
         this.updateGoodsCount(e)
       },
     },
   }
   ```



#### 1.11 渲染滑动删除的 UI 效果

> 滑动删除需要用到 uni-ui 的 uni-swipe-action 组件和 uni-swipe-action-item。详细的官方文档请参考[SwipeAction 滑动操作](https://ext.dcloud.net.cn/plugin?id=181)。

1. 改造 `cart.vue` 页面的 UI 结构，将商品列表区域的结构修改如下（可以使用 **uSwipeAction** 代码块快速生成基本的 UI 结构）：

   

   - 注意需要使用 `:right-options`, `:left-options` 来定义滑动按钮的配置信息
   - click 事件为点击滑动按钮的触发事件

   ```xml
   <!-- 商品列表区域 -->
   <!-- uni-swipe-action 是最外层包裹性质的容器 -->
   <uni-swipe-action>
     <block v-for="(goods, i) in cart" :key="i">
       <!-- uni-swipe-action-item 可以为其子节点提供滑动操作的效果。需要通过 options 属性来指定操作按钮的配置信息 -->
       <!-- left-options, right-options 左滑/右滑 -->
       <uni-swipe-action-item :right-options="options" @click="swipeActionClickHandler(goods)">
         <my-goods :goods="goods" :show-radio="true" :show-num="true" @radio-change="radioChangeHandler" @num-change="numberChangeHandler"></my-goods>
       </uni-swipe-action-item>
     </block>
   </uni-swipe-action>
   ```

2. 在 data 节点中声明 `options` 数组，用来定义操作按钮的配置信息：

   ```js
   data() {
     return {
       options: [{
         text: '删除', // 显示的文本内容
         style: {
           backgroundColor: '#C00000' // 按钮的背景颜色
         }
       }]
     }
   }
   ```

3. 在 `methods` 中声明 `uni-swipe-action-item` 组件的 `@click` 事件处理函数：

   ```js
   // 点击了滑动操作按钮
   swipeActionClickHandler(goods) {
     console.log(goods)
   }
   ```

4. 美化 `my-goods.vue` 组件的样式：

   ```scss
   .goods-item {
     // 让 goods-item 项占满整个屏幕的宽度
     width: 750rpx;
     // 设置盒模型为 border-box
     box-sizing: border-box;
     display: flex;
     padding: 10px 5px;
     border-bottom: 1px solid #f0f0f0;
   }
   ```



#### 1.12 实现滑动删除的功能

1. 在 `store/cart.js` 模块的 `mutations` 节点中声明如下的方法，从而根据商品的 Id 从购物车中移除对应的商品：

   ```js
   // 根据 Id 从购物车中删除对应的商品信息
   removeGoodsById(state, goods_id) {
     // 调用数组的 filter 方法进行过滤
     state.cart = state.cart.filter(x => x.goods_id !== goods_id)
     // 持久化存储到本地
     this.commit('m_cart/saveToStorage')
   }
   ```

2. 在 `cart.vue` 页面中，使用 `mapMutations` 辅助函数，把需要的方法映射到当前页面中使用：

   ```js
   methods: {
     ...mapMutations('m_cart', ['updateGoodsState', 'updateGoodsCount', 'removeGoodsById']),
     // 商品的勾选状态发生了变化
     radioChangeHandler(e) {
       this.updateGoodsState(e)
     },
     // 商品的数量发生了变化
     numberChangeHandler(e) {
       this.updateGoodsCount(e)
     },
     // 点击了滑动操作按钮
     swipeActionClickHandler(goods) {
       this.removeGoodsById(goods.goods_id)
     }
   }
   ```



#### PS：出现 ReferenceError: isPC is not defined 解决办法

修改项目路径/uni_modules/uni-swipe-action/components/uni-swipe-action-item/mpwxs.js”，添加代码

~~~
let isPC=function(){return false}
~~~



### 2. 收货地址

#### 2.1 创建收货地址组件

在 `components` 目录上鼠标右键，选择 `新建组件`，新建 my-address 组件：



渲染收货地址组件的基本结构：

```xml
<view>

  <!-- 选择收货地址的盒子 -->
  <view class="address-choose-box">
    <button type="primary" size="mini" class="btnChooseAddress">请选择收货地址+</button>
  </view>

  <!-- 渲染收货信息的盒子 -->
  <view class="address-info-box">
    <view class="row1">
      <view class="row1-left">
        <view class="username">收货人：<text>escook</text></view>
      </view>
      <view class="row1-right">
        <view class="phone">电话：<text>138XXXX5555</text></view>
        <uni-icons type="arrowright" size="16"></uni-icons>
      </view>
    </view>
    <view class="row2">
      <view class="row2-left">收货地址：</view>
      <view class="row2-right">河北省邯郸市肥乡区xxx 河北省邯郸市肥乡区xxx 河北省邯郸市肥乡区xxx 河北省邯郸市肥乡区xxx </view>
    </view>
  </view>

  <!-- 底部的边框线 -->
  <image src="/static/cart_border@2x.png" class="address-border"></image>
</view>
```



美化收货地址组件的样式：

```scss
// 底部边框线的样式
.address-border {
  display: block;
  width: 100%;
  height: 5px;
}

// 选择收货地址的盒子
.address-choose-box {
  height: 90px;
  display: flex;
  align-items: center;
  justify-content: center;
}

// 渲染收货信息的盒子
.address-info-box {
  font-size: 12px;
  height: 90px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  padding: 0 5px;

  // 第一行
  .row1 {
    display: flex;
    justify-content: space-between;

    .row1-right {
      display: flex;
      align-items: center;

      .phone {
        margin-right: 5px;
      }
    }
  }

  // 第二行
  .row2 {
    display: flex;
    align-items: center;
    margin-top: 10px;

    .row2-left {
      white-space: nowrap;
    }
  }
}
```



#### 2.2 实现收货地址区域的按需展示

在 data 中定义收货地址的信息对象

```js
export default {
  data() {
    return {
      // 收货地址
      address: {},
    }
  },
}
```



使用 `v-if` 和 `v-else` 实现按需展示：

```xml
<!-- 选择收货地址的盒子 -->
<view class="address-choose-box" v-if="JSON.stringify(address) === '{}'">
  <button type="primary" size="mini" class="btnChooseAddress">请选择收货地址+</button>
</view>

<!-- 渲染收货信息的盒子 -->
<view class="address-info-box" v-else>
  <!-- 省略其它代码 -->
</view>
```



#### 2.3 实现选择收货地址的功能

为 `请选择收货地址+` 的 `button` 按钮绑定点击事件处理函数：

```xml
<!-- 选择收货地址的盒子 -->
<view class="address-choose-box" v-if="JSON.stringify(address) === '{}'">
  <button type="primary" size="mini" class="btnChooseAddress" @click="chooseAddress">请选择收货地址+</button>
</view>
```



定义 `chooseAddress` 事件处理函数，调用小程序提供的 `uni.chooseAddress()` API 实现选择收货地址的功能：

~~~js
methods:{
    async chooseAddress(){
        const [err, succ] = await uni.chooseAddress()
        console.log(err)
        console.log(succ)
    }
}
~~~



拿到地址对象的情况

![image-20220521215837109](images/mini_program/image-20220521215837109.png)

> err 为 null，success 为地址对象



取消地址的情况

![image-20220521215915674](images/mini_program/image-20220521215915674.png)

> err 为错误对象， succ 为 undefined



- API 返回一个数组
  - err  错误对象
  - succ  收货地址对象
- 链式操作对其进行异常捕获，返回 err 错误
- 判断 err 为空，并且地址对象中的 errMsg 为 chooseAddress:ok 的情况下，将对象赋值给 address

```js
methods: {
  // 选择收货地址
  async chooseAddress() {
    // 1. 调用小程序提供的 chooseAddress() 方法，即可使用选择收货地址的功能
    //    返回值是一个数组：第 1 项为错误对象；第 2 项为成功之后的收货地址对象
    const [err, succ] = await uni.chooseAddress().catch(err => err)

    // 2. 用户成功的选择了收货地址
    if (err === null && succ.errMsg === 'chooseAddress:ok') {
      // 为 data 里面的收货地址对象赋值
      this.address = succ
    }
  }
}
```



定义**收货详细地址**的计算属性：

```js
computed: {
  // 收货详细地址的计算属性
  addstr() {
    if (!this.address.provinceName) return ''

    // 拼接 省，市，区，详细地址 的字符串并返回给用户
    return this.address.provinceName + this.address.cityName + this.address.countyName + this.address.detailInfo
  }
}
```



渲染收货地址区域的数据：

```xml
<!-- 渲染收货信息的盒子 -->
<view class="address-info-box" v-else>
  <view class="row1">
    <view class="row1-left">
      <view class="username">收货人：<text>{{address.userName}}</text></view>
    </view>
    <view class="row1-right">
      <view class="phone">电话：<text>{{address.telNumber}}</text></view>
      <uni-icons type="arrowright" size="16"></uni-icons>
    </view>
  </view>
  <view class="row2">
    <view class="row2-left">收货地址：</view>
    <view class="row2-right">{{addstr}}</view>
  </view>
</view>
```



#### 2.4 将 address 信息存储到 vuex 中

在 `store` 目录中，创建用户相关的 `vuex` 模块，命名为 `user.js`：

```js
export default {
  // 开启命名空间
  namespaced: true,

  // state 数据
  state: () => ({
    // 收货地址
    address: {},
  }),

  // 方法
  mutations: {
    // 更新收货地址
    updateAddress(state, address) {
      state.address = address
    },
  },

  // 数据包装器
  getters: {},
}
```



在 `store/store.js` 模块中，导入并挂载 `user.js` 模块：

```js
// 1. 导入 Vue 和 Vuex
import Vue from 'vue'
import Vuex from 'vuex'
// 导入购物车的 vuex 模块
import moduleCart from './cart.js'
// 导入用户的 vuex 模块
import moduleUser from './user.js'

// 2. 将 Vuex 安装为 Vue 的插件
Vue.use(Vuex)

// 3. 创建 Store 的实例对象
const store = new Vuex.Store({
  // TODO：挂载 store 模块
  modules: {
    // 挂载购物车的 vuex 模块，模块内成员的访问路径被调整为 m_cart，例如：
    // 购物车模块中 cart 数组的访问路径是 m_cart/cart
    m_cart: moduleCart,
    // 挂载用户的 vuex 模块，访问路径为 m_user
    m_user: moduleUser,
  },
})

// 4. 向外共享 Store 的实例对象
export default store
```



改造 `address.vue` 组件中的代码，使用 **vuex 提供的 address 计算属性** 替代 **data 中定义的本地 address 对象**：

```js
// 1. 按需导入 mapState 和 mapMutations 这两个辅助函数
import { mapState, mapMutations } from 'vuex'

export default {
  data() {
    return {
      // 2.1 注释掉下面的 address 对象，使用 2.2 中的代码替代之
      // address: {}
    }
  },
  methods: {
    // 3.1 把 m_user 模块中的 updateAddress 函数映射到当前组件
    ...mapMutations('m_user', ['updateAddress']),
    // 选择收货地址
    async chooseAddress() {
      const [err, succ] = await uni.chooseAddress().catch((err) => err)

      // 用户成功的选择了收货地址
      if (err === null && succ.errMsg === 'chooseAddress:ok') {
        // 3.2 把下面这行代码注释掉，使用 3.3 中的代码替代之
        // this.address = succ

        // 3.3 调用 Store 中提供的 updateAddress 方法，将 address 保存到 Store 里面
        this.updateAddress(succ)
      }
    },
  },
  computed: {
    // 2.2 把 m_user 模块中的 address 对象映射当前组件中使用，代替 data 中 address 对象
    ...mapState('m_user', ['address']),
    // 收货详细地址的计算属性
    addstr() {
      if (!this.address.provinceName) return ''

      // 拼接 省，市，区，详细地址 的字符串并返回给用户
      return this.address.provinceName + this.address.cityName + this.address.countyName + this.address.detailInfo
    },
  },
}
```



####  2.5 将 Store 中的 address 持久化存储到本地

修改 `store/user.js` 模块中的代码如下：

```js
export default {
  // 开启命名空间
  namespaced: true,

  // state 数据
  state: () => ({
    // 3. 读取本地的收货地址数据，初始化 address 对象
    address: JSON.parse(uni.getStorageSync('address') || '{}'),
  }),

  // 方法
  mutations: {
    // 更新收货地址
    updateAddress(state, address) {
      state.address = address

      // 2. 通过 this.commit() 方法，调用 m_user 模块下的 saveAddressToStorage 方法将 address 对象持久化存储到本地
      this.commit('m_user/saveAddressToStorage')
    },
    // 1. 定义将 address 持久化存储到本地 mutations 方法
    saveAddressToStorage(state) {
      uni.setStorageSync('address', JSON.stringify(state.address))
    },
  },

  // 数据包装器
  getters: {},
}
```



#### 2.6 将 addstr 抽离为 getters

**目的：为了提高代码的复用性，可以把收货的详细地址抽离为 getters，方便在多个页面和组件之间实现复用。**



剪切 `my-address.vue` 组件中的 `addstr` 计算属性的代码，粘贴到 `user.js` 模块中，作为一个 getters 节点：

```js
// 数据包装器
getters: {
  // 收货详细地址的计算属性
  addstr(state) {
    if (!state.address.provinceName) return ''

    // 拼接 省，市，区，详细地址 的字符串并返回给用户
    return state.address.provinceName + state.address.cityName + state.address.countyName + state.address.detailInfo
  }
}
```



改造 `my-address.vue` 组件中的代码，通过 `mapGetters` 辅助函数，将 `m_user` 模块中的 `addstr` 映射到当前组件中使用：

```js
// 按需导入 mapGetters 辅助函数
import { mapState, mapMutations, mapGetters } from 'vuex'

export default {
  // 省略其它代码
  computed: {
    ...mapState('m_user', ['address']),
    // 将 m_user 模块中的 addstr 映射到当前组件中使用
    ...mapGetters('m_user', ['addstr']),
  },
}
```



#### 2.7 重新选择收货地址

为 class 类名为 `address-info-box` 的盒子绑定 `click` 事件处理函数如下：

```xml
<!-- 渲染收货信息的盒子 -->
<view class="address-info-box" v-else @click="chooseAddress">
  <!-- 省略其它代码 -->
</view>
```



####  2.8 解决收货地址授权失败的问题

> **如果在选择收货地址的时候，用户点击了****取消授权****，则需要进行****特殊的处理****，否则****用户将无法再次选择收货地址****！**



改造 `chooseAddress` 方法如下：

```js
// 选择收货地址
async chooseAddress() {
  // 1. 调用小程序提供的 chooseAddress() 方法，即可使用选择收货地址的功能
  //    返回值是一个数组：第1项为错误对象；第2项为成功之后的收货地址对象
  const [err, succ] = await uni.chooseAddress().catch(err => err)

  // 2. 用户成功的选择了收货地址
  if (succ && succ.errMsg === 'chooseAddress:ok') {
    // 更新 vuex 中的收货地址
    this.updateAddress(succ)
  }

  // 3. 用户没有授权
  if (err && err.errMsg === 'chooseAddress:fail auth deny') {
    this.reAuth() // 调用 this.reAuth() 方法，向用户重新发起授权申请
  }
}
```



在 `methods` 节点中声明 `reAuth` 方法如下：

```js
// 调用此方法，重新发起收货地址的授权
async reAuth() {
  // 3.1 提示用户对地址进行授权
  const [err2, confirmResult] = await uni.showModal({
    content: '检测到您没打开地址权限，是否去设置打开？',
    confirmText: "确认",
    cancelText: "取消",
  })

  // 3.2 如果弹框异常，则直接退出
  if (err2) return

  // 3.3 如果用户点击了 “取消” 按钮，则提示用户 “您取消了地址授权！”
  if (confirmResult.cancel) return uni.$showMsg('您取消了地址授权！')

  // 3.4 如果用户点击了 “确认” 按钮，则调用 uni.openSetting() 方法进入授权页面，让用户重新进行授权
  if (confirmResult.confirm) return uni.openSetting({
    // 3.4.1 授权结束，需要对授权的结果做进一步判断
    success: (settingResult) => {
      // 3.4.2 地址授权的值等于 true，提示用户 “授权成功”
      if (settingResult.authSetting['scope.address']) return uni.$showMsg('授权成功！请选择地址')
      // 3.4.3 地址授权的值等于 false，提示用户 “您取消了地址授权”
      if (!settingResult.authSetting['scope.address']) return uni.$showMsg('您取消了地址授权！')
    }
  })
}
```



#### 2.9 解决 iPhone 真机上无法重新授权的问题

> **问题说明：在 iPhone 设备上，当用户取消授权之后，再次点击选择收货地址按钮的时候，无法弹出授权的提示框！**



导致问题的原因 - 用户取消授权后，再次点击 “选择收货地址” 按钮的时候：

- 在**模拟器**和**安卓真机**上，错误消息 `err.errMsg` 的值为 `chooseAddress:fail auth deny`
- 在 **iPhone 真机**上，错误消息 `err.errMsg` 的值为 `chooseAddress:fail authorize no response`



解决问题的方案 - 修改 `chooseAddress` 方法中的代码，进一步完善用户没有授权时的 `if` 判断条件即可：

```js
async chooseAddress() {
  // 1. 调用小程序提供的 chooseAddress() 方法，即可使用选择收货地址的功能
  //    返回值是一个数组：第1项为错误对象；第2项为成功之后的收货地址对象
  const [err, succ] = await uni.chooseAddress().catch(err => err)

  // 2. 用户成功的选择了收货地址
  if (succ && succ.errMsg === 'chooseAddress:ok') {
    this.updateAddress(succ)
  }

  // 3. 用户没有授权
  if (err && (err.errMsg === 'chooseAddress:fail auth deny' || err.errMsg === 'chooseAddress:fail authorize no response')) {
    this.reAuth()
  }
}
```



### 3. 结算区域

#### 1. 把结算区域封装为组件

在 `components` 目录中，新建 `my-settle` 结算组件



初始化 `my-settle` 组件的基本结构和样式：

```vue
<template>
  <!-- 最外层的容器 -->
  <view class="my-settle-container">
    结算组件
  </view>
</template>

<script>
export default {
  data() {
    return {}
  },
}
</script>

<style lang="scss">
.my-settle-container {
  /* 底部固定定位 */
  position: fixed;
  bottom: 0;
  left: 0;
  /* 设置宽高和背景色 */
  width: 100%;
  height: 50px;
  background-color: cyan;
}
</style>
```



在 `cart.vue` 页面中使用自定义的 `my-settle` 组件，并美化页面样式，防止页面底部被覆盖：

```vue
<template>
  <view class="cart-container">
    <!-- 使用自定义的 address 组件 -->

    <!-- 购物车商品列表的标题区域 -->

    <!-- 商品列表区域 -->

    <!-- 结算区域 -->
    <my-settle></my-settle>
  </view>
</template>

<style lang="scss">
.cart-container {
  padding-bottom: 50px;
}
</style>
```



#### 2. 渲染结算区域的结构和样式

定义如下的 UI 结构：

```xml
<!-- 最外层的容器 -->
<view class="my-settle-container">
  <!-- 全选区域 -->
  <label class="radio">
    <radio color="#C00000" :checked="true" /><text>全选</text>
  </label>

  <!-- 合计区域 -->
  <view class="amount-box">
    合计:<text class="amount">￥1234.00</text>
  </view>

  <!-- 结算按钮 -->
  <view class="btn-settle">结算(0)</view>
</view>
```



美化样式：

```scss
.my-settle-container {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 50px;
  // 将背景色从 cyan 改为 white
  background-color: white;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-left: 5px;
  font-size: 14px;

  .radio {
    display: flex;
    align-items: center;
  }

  .amount {
    color: #c00000;
  }

  .btn-settle {
    height: 50px;
    min-width: 100px;
    background-color: #c00000;
    color: white;
    line-height: 50px;
    text-align: center;
    padding: 0 10px;
  }
}
```



#### 3. 动态渲染已勾选商品的总数量

在 `store/cart.js` 模块中，定义一个名称为 `checkedCount` 的 getters，用来统计已勾选商品的总数量：

```js
// 勾选的商品的总数量
checkedCount(state) {
  // 先使用 filter 方法，从购物车中过滤器已勾选的商品
  // 再使用 reduce 方法，将已勾选的商品总数量进行累加
  // reduce() 的返回值就是已勾选的商品的总数量
  return state.cart.filter(x => x.goods_state).reduce((total, item) => total += item.goods_count, 0)
}
```



在 `my-settle` 组件中，通过 `mapGetters` 辅助函数，将需要的 getters 映射到当前组件中使用：

```js
import { mapGetters } from 'vuex'

export default {
  computed: {
    ...mapGetters('m_cart', ['checkedCount']),
  },
  data() {
    return {}
  },
}
```



将 `checkedCount` 的值渲染到页面中：

```xml
<!-- 结算按钮 -->
<view class="btn-settle">结算({{checkedCount}})</view>
```



#### 4. 动态渲染全选按钮的选中状态

使用 `mapGetters` 辅助函数，将**商品的总数量**映射到当前组件中使用，并定义一个叫做 `isFullCheck` 的计算属性：

```js
import { mapGetters } from 'vuex'

export default {
  computed: {
    // 1. 将 total 映射到当前组件中
    ...mapGetters('m_cart', ['checkedCount', 'total']),
    // 2. 是否全选
    isFullCheck() {
      return this.total === this.checkedCount
    },
  },
  data() {
    return {}
  },
}
```



为 radio 组件动态绑定 `checked` 属性的值：

```xml
<!-- 全选区域 -->
<label class="radio">
  <radio color="#C00000" :checked="isFullCheck" /><text>全选</text>
</label>
```



重构计算 total 方法，`cart.js`

~~~js
state.cart.reduce((total, item)=>{total += item.goods_count}, 0)
~~~



#### 5. 实现商品的全选/反选功能

在 `store/cart.js` 模块中，定义一个叫做 `updateAllGoodsState` 的 mutations 方法，用来修改所有商品的勾选状态：

```js
// 更新所有商品的勾选状态
updateAllGoodsState(state, newState) {
  // 循环更新购物车中每件商品的勾选状态
  state.cart.forEach(x => x.goods_state = newState)
  // 持久化存储到本地
  this.commit('m_cart/saveToStorage')
}
```



在 `my-settle` 组件中，通过 `mapMutations` 辅助函数，将需要的 mutations 方法映射到当前组件中使用：

```js
// 1. 按需导入 mapMutations 辅助函数
import { mapGetters, mapMutations } from 'vuex'

export default {
  // 省略其它代码
  methods: {
    // 2. 使用 mapMutations 辅助函数，把 m_cart 模块提供的 updateAllGoodsState 方法映射到当前组件中使用
    ...mapMutations('m_cart', ['updateAllGoodsState']),
  },
}

```



为 UI 中的 `label` 组件绑定 `click` 事件处理函数：

```xml
<!-- 全选区域 -->
<label class="radio" @click="changeAllState">
  <radio color="#C00000" :checked="isFullCheck" /><text>全选</text>
</label>
```



在 `my-settle` 组件的 methods 节点中，声明 `changeAllState` 事件处理函数：

```js
methods: {
  ...mapMutations('m_cart', ['updateAllGoodsState']),
  // label 的点击事件处理函数
  changeAllState() {
    // 修改购物车中所有商品的选中状态
    // !this.isFullCheck 表示：当前全选按钮的状态取反之后，就是最新的勾选状态
    this.updateAllGoodsState(!this.isFullCheck)
  }
}
```



#### 6. 动态渲染已勾选商品的总价格

在 `store/cart.js` 模块中，定义一个叫做 `checkedGoodsAmount` 的 getters，用来统计已勾选商品的总价格：

```js
// 已勾选的商品的总价
checkedGoodsAmount(state) {
  // 先使用 filter 方法，从购物车中过滤器已勾选的商品
  // 再使用 reduce 方法，将已勾选的商品数量 * 单价之后，进行累加
  // reduce() 的返回值就是已勾选的商品的总价
  // 最后调用 toFixed(2) 方法，保留两位小数
  return state.cart.filter(x => x.goods_state)
                   .reduce((total, item) => total += item.goods_count * item.goods_price, 0)
                   .toFixed(2)
}
```



在 `my-settle` 组件中，使用 `mapGetters` 辅助函数，把需要的 `checkedGoodsAmount` 映射到当前组件中使用：

```js
...mapGetters('m_cart', ['total', 'checkedCount', 'checkedGoodsAmount'])
```



在组件的 UI 结构中，渲染已勾选的商品的总价：

```xml
<!-- 合计区域 -->
<view class="amount-box">
  合计:<text class="amount">￥{{checkedGoodsAmount}}</text>
</view>
```



#### 7. 动态计算购物车徽标的数值

1. **问题说明**：当修改购物车中商品的数量之后，tabBar 上的数字徽标不会自动更新。
2. **解决方案**：改造 `mixins/tabbar-badge.js` 中的代码，使用 `watch` 侦听器，监听 `total` 总数量的变化，从而动态为 tabBar 的徽标赋值：

```js
import { mapGetters } from 'vuex'

// 导出一个 mixin 对象
export default {
  computed: {
    ...mapGetters('m_cart', ['total']),
  },
  watch: {
    // 监听 total 值的变化
    total() {
      // 调用 methods 中的 setBadge 方法，重新为 tabBar 的数字徽章赋值
      this.setBadge()
    },
  },
  onShow() {
    // 在页面刚展示的时候，设置数字徽标
    this.setBadge()
  },
  methods: {
    setBadge() {
      // 调用 uni.setTabBarBadge() 方法，为购物车设置右上角的徽标
      uni.setTabBarBadge({
        index: 2,
        text: this.total + '', // 注意：text 的值必须是字符串，不能是数字
      })
    },
  },
}
```



#### 8. 渲染购物车为空时的页面结构

1. 将 `资料` 目录中的 `cart_empty@2x.png` 图片复制到项目的 `/static/` 目录中
2. 改造 `cart.vue` 页面的 UI 结构，使用 `v-if` 和 `v-else` 控制**购物车区域**和**空白购物车区域**的按需展示：

```xml
<template>
  <view class="cart-container" v-if="cart.length !== 0">

    <!-- 使用自定义的 address 组件 -->

    <!-- 购物车商品列表的标题区域 -->

    <!-- 商品列表区域 -->

    <!-- 结算区域 -->

  </view>

  <!-- 空白购物车区域 -->
  <view class="empty-cart" v-else>
    <image src="/static/cart_empty@2x.png" class="empty-img"></image>
    <text class="tip-text">空空如也~</text>
  </view>
</template>
```



美化空白购物车区域的样式：

```scss
.empty-cart {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding-top: 150px;

  .empty-img {
    width: 90px;
    height: 90px;
  }

  .tip-text {
    font-size: 12px;
    color: gray;
    margin-top: 15px;
  }
}
```



## 15. 登录

### 1. 点击结算按钮进行条件判断

> 说明：用户点击了结算按钮之后，需要先后判断是否勾选了要结算的商品、是否选择了收货地址、是否登录。

在 `my-settle` 组件中，为结算按钮绑定点击事件处理函数：

```xml
<!-- 结算按钮 -->
<view class="btn-settle" @click="settlement">结算({{checkedCount}})</view>
```



在 `my-settle` 组件的 methods 节点中声明 settlement 事件处理函数如下：

```js
// 点击了结算按钮
settlement() {
  // 1. 先判断是否勾选了要结算的商品
  if (!this.checkedCount) return uni.$showMsg('请选择要结算的商品！')

  // 2. 再判断用户是否选择了收货地址
  if (!this.addstr) return uni.$showMsg('请选择收货地址！')

  // 3. 最后判断用户是否登录了
  if (!this.token) return uni.$showMsg('请先登录！')
}
```



在 `my-settle` 组件中，使用 `mapGetters` 辅助函数，从 `m_user` 模块中将 `addstr` 映射到当前组件中使用：

```js
export default {
  computed: {
    ...mapGetters('m_cart', ['total', 'checkedCount', 'checkedGoodsAmount']),
    // addstr 是详细的收货地址
    ...mapGetters('m_user', ['addstr']),
    isFullCheck() {
      return this.total === this.checkedCount
    },
  },
}
```



在 `store/user.js` 模块的 `state` 节点中，声明 `token` 字符串：

```js
export default {
  // 开启命名空间
  namespaced: true,

  // state 数据
  state: () => ({
    // 收货地址
    address: JSON.parse(uni.getStorageSync('address') || '{}'),
    // 登录成功之后的 token 字符串
    token: '',
  }),

  // 省略其它代码
}
```



在 `my-settle` 组件中，使用 `mapState` 辅助函数，从 `m_user` 模块中将 `token` 映射到当前组件中使用：

```js
// 按需从 vuex 中导入 mapState 辅助函数
import { mapGetters, mapMutations, mapState } from 'vuex'

export default {
  computed: {
    ...mapGetters('m_cart', ['total', 'checkedCount', 'checkedGoodsAmount']),
    ...mapGetters('m_user', ['addstr']),
    // token 是用户登录成功之后的 token 字符串
    ...mapState('m_user', ['token']),
    isFullCheck() {
      return this.total === this.checkedCount
    },
  },
}
```



### 2. 创建登录页面及其相关组件

定义 my 页面的编译模式

![image-20220523153106111](images/mini_program/image-20220523153106111.png)



在 `components` 目录中新建**登录组件**：

![image-20220523153153828](images/mini_program/image-20220523153153828.png)



在 `components` 目录中新建**用户信息组件**：

![image-20220523153220932](images/mini_program/image-20220523153220932.png)



### 3. 实现登录和用户信息组件的按需展示

在 `my.vue` 页面中，通过 `mapState` 辅助函数，导入需要的 `token` 字符串：

```js
import badgeMix from '@/mixins/tabbar-badge.js'
// 1. 从 vuex 中按需导入 mapState 辅助函数
import { mapState } from 'vuex'

export default {
  mixins: [badgeMix],
  computed: {
    // 2. 从 m_user 模块中导入需要的 token 字符串
    ...mapState('m_user', ['token']),
  },
  data() {
    return {}
  },
}
```



在 `my.vue` 页面中，实现**登录组件**和**用户信息组件**的按需展示：

```xml
<template>
  <view>

    <!-- 用户未登录时，显示登录组件 -->
    <my-login v-if="!token"></my-login>

    <!-- 用户登录后，显示用户信息组件 -->
    <my-userinfo v-else></my-userinfo>

  </view>
</template>
```



### 4. 实现登录组件的基本布局

为 `my-login` 组件定义如下的 UI 结构：

```xml
<template>
  <view class="login-container">
    <!-- 提示登录的图标 -->
    <uni-icons type="contact-filled" size="100" color="#AFAFAF"></uni-icons>
    <!-- 登录按钮 -->
    <button type="primary" class="btn-login">一键登录</button>
    <!-- 登录提示 -->
    <view class="tips-text">登录后尽享更多权益</view>
  </view>
</template>
```



美化登录组件的样式：

```scss
.login-container {
  // 登录盒子的样式
  height: 750rpx;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: #f8f8f8;
  position: relative;
  overflow: hidden;

  // 绘制登录盒子底部的半椭圆造型
  &::after {
    content: ' ';
    display: block;
    position: absolute;
    width: 100%;
    height: 40px;
    left: 0;
    bottom: 0;
    background-color: white;
    border-radius: 100%;
    transform: translateY(50%);
  }

  // 登录按钮的样式
  .btn-login {
    width: 90%;
    border-radius: 100px;
    margin: 15px 0;
    background-color: #c00000;
  }

  // 按钮下方提示消息的样式
  .tips-text {
    font-size: 12px;
    color: gray;
  }
}

```



### 5. 点击登录按钮获取微信用户的基本信息

> 需求描述：需要获取微信用户的头像、昵称等基本信息。



登录接口说明

![image-20220523155149654](images/mini_program/image-20220523155149654.png)



为登录的 `button` 按钮绑定 `open-type="getUserInfo"` 属性，表示点击按钮时，希望获取用户的基本信息：

```xml
<!-- 登录按钮 -->
<!-- 可以从 @getuserinfo 事件处理函数的形参中，获取到用户的基本信息 -->
<!-- open-type 与 getuserinfo 是开发工具自定义属性和方法 -->
<button type="primary" class="btn-login" open-type="getUserInfo" @getuserinfo="getUserInfo">一键登录</button>
```



在 `methods` 节点中声明 `getUserInfo` 事件处理函数如下：

```js
methods: {
  // 获取微信用户的基本信息
  getUserInfo(e) {
      console.log(e)
  }
}
```



其中参数 e 为触发事件的对象，其保存的是用户的授权信息，其中 e.detail 中是用户的一些数据

![image-20220523155703060](images/mini_program/image-20220523155703060.png)



通过判断 errMsg 可以知道用户是否授权登录

~~~js
methods: {
    // 获取微信用户的基本信息
    getUserInfo(e) {
        // 判断是否获取用户信息成功
        if (e.detail.errMsg === 'getUserInfo:fail auth deny') return uni.$showMsg('您取消了登录授权！')
        // 获取用户信息成功， e.detail.userInfo 就是用户的基本信息
        console.log(e.detail.userInfo)
    }
}
~~~



**更新**：新版 HBuilderX 直接调用 `@click=getUserInfo` 不需要 `open-type` 属性，在方法中使用 `uni.getUserProfile` API 获取用户授权信息

~~~js
// 获取微信用户的基本信息
getUserInfo() {
    uni.getUserProfile({
        desc:'Wexin',     // 这个参数是必须的
        success:res=>{
            console.log("用户信息",res)
        }
    })
}
~~~



![image-20220523161107032](images/mini_program/image-20220523161107032.png)



### 6. 将用户的基本信息存储到 vuex

先在 user.js 中的 state 定义一个 userinfo

在 `store/user.js` 模块的 state 节点中，声明 `userinfo` 的信息对象如下：

~~~js
// state 数据
state: () => ({
  // 收货地址
  // address: {}
  address: JSON.parse(uni.getStorageSync('address') || '{}'),
  // 登录成功之后的 token 字符串
  token: '',
  // 用户的基本信息
  userinfo: {}
}),
~~~



然后再 mutations 中创建 updateUserInfo 方法，用于将传递过来用户信息保存到 state

~~~js
// 方法
mutations: {
  // 省略其它代码...

  // 更新用户的基本信息
  updateUserInfo(state, userinfo) {
    state.userinfo = userinfo
  },
}
~~~



最后在 my-login 组件中，调用 mutations 方法，把 userinfo 传递到 state

~~~js
// 1. 按需导入 mapMutations 辅助函数
import { mapMutations } from 'vuex'

export default {
  data() {
    return {}
  },
  methods: {
    // 2. 调用 mapMutations 辅助方法，把 m_user 模块中的 updateUserInfo 映射到当前组件中使用
    ...mapMutations('m_user', ['updateUserInfo']),
    // 获取微信用户的基本信息
    getUserInfo(e) {
      // 判断是否获取用户信息成功
      if (e.detail.errMsg === 'getUserInfo:fail auth deny') return uni.$showMsg('您取消了登录授权！')
      // 获取用户信息成功， e.detail.userInfo 就是用户的基本信息
      // console.log(e.detail.userInfo)

      // 3. 将用户的基本信息存储到 vuex 中
      this.updateUserInfo(e.detail.userInfo)
    },
  },
}

~~~



持久化处理：

在 `store/user.js` 模块的 mutations 节点中，声明如下的两个方法：

```js
// 方法
mutations: {
  // 省略其它代码...

  // 更新用户的基本信息
  updateUserInfo(state, userinfo) {
    state.userinfo = userinfo
    // 通过 this.commit() 方法，调用 m_user 模块下的 saveUserInfoToStorage 方法，将 userinfo 对象持久化存储到本地
    this.commit('m_user/saveUserInfoToStorage')
  },

  // 将 userinfo 持久化存储到本地
  saveUserInfoToStorage(state) {
    uni.setStorageSync('userinfo', JSON.stringify(state.userinfo))
  }
}
```



持久化从本地中读取用户信息：

```js
// state 数据
state: () => ({
  // 收货地址
  // address: {}
  address: JSON.parse(uni.getStorageSync('address') || '{}'),
  // 登录成功之后的 token 字符串
  token: '',
  // 用户的基本信息
  userinfo: JSON.parse(uni.getStorageSync('userinfo') || '{}')
}),
```





### 7. 登录获取 Token 字符串

> 需求说明：当获取到了微信用户的基本信息之后，还需要进一步调用登录相关的接口，从而换取登录成功之后的 Token 字符串。



在`my-login.vue` 中的  `getUserInfo` 方法中，预调用 `this.getToken()` 方法，同时把获取到的用户信息传递进去：

```js
// 获取微信用户的基本信息
getUserInfo(e) {
  // 判断是否获取用户信息成功
  if (e.detail.errMsg === 'getUserInfo:fail auth deny') return uni.$showMsg('您取消了登录授权！')

  // 将用户的基本信息存储到 vuex 中
  this.updateUserInfo(e.detail.userInfo)

  // 获取登录成功后的 Token 字符串
  this.getToken(e.detail)
}
```



在 `methods` 中定义 `getToken` 方法，调用登录相关的 API，实现登录的功能：

- 定义 getToken() 方法，传入 getUserInfo 方法得到的 userinfo
- 调用 uni.login() 微信接口，获取临时 code
- 构造登录参数 query
- 将信息 post 到自定义登录接口，验证成功后返回 token



接口返回示例：

~~~json
{
  "message": {
    "user_id": 23,
    "user_email_code": null,
    "is_active": null,
    "user_sex": "男",
    "user_qq": "",
    "user_tel": "",
    "user_xueli": "本科",
    "user_hobby": "",
    "user_introduce": null,
    "create_time": 1562221487,
    "update_time": 1562221487,
    "token": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOjIzLCJpYXQiOjE1NjQ3MzAwNzksImV4cCI6MTAwMTU2NDczMDA3OH0.YPt-XeLnjV-_1ITaXGY2FhxmCe4NvXuRnRB8OMCfnPo"
  },
  "meta": {
    "msg": "登录成功",
    "status": 200
  }
}
~~~



```js
// 调用登录接口，换取永久的 token
async getToken(info) {
  // 调用微信登录接口
  const [err, res] = await uni.login().catch(err => err)
  // 判断是否 uni.login() 调用失败
  if (err || res.errMsg !== 'login:ok') return uni.$showError('登录失败！')

  // 准备参数对象
  const query = {
    code: res.code,
    encryptedData: info.encryptedData,
    iv: info.iv,
    rawData: info.rawData,
    signature: info.signature
  }

  // 换取 token
  const { data: loginResult } = await uni.$http.post('/api/public/v1/users/wxlogin', query)
  console.log(loginResult)
  if (loginResult.meta.status !== 200) return uni.$showMsg('登录失败！')
  uni.$showMsg('登录成功')
  
}
```

> 由于接口需要授权验证，我们自己构造一个 loginResult



### 8. 将 Token 存储到 vuex

拿到 loginResult 后，我们需要将里边的 token 保存到 vuex 中，由于是操作 state，所以我们需要在 mutations 中定义方法，然后在组件中调用。



在 `store/user.js` 模块的 `mutations` 节点中，声明如下的两个方法：

```js
mutations: {
  // 省略其它代码...

  // 更新 token 字符串
  updateToken(state, token) {
    state.token = token
    // 通过 this.commit() 方法，调用 m_user 模块下的 saveTokenToStorage 方法，将 token 字符串持久化存储到本地
    this.commit('m_user/saveTokenToStorage')
  },

  // 将 token 字符串持久化存储到本地
  saveTokenToStorage(state) {
    uni.setStorageSync('token', state.token)
  }
}
```



修改 `store/user.js` 模块的 `state` 节点如下：

```js
// state 数据
state: () => ({
  // 收货地址
  address: JSON.parse(uni.getStorageSync('address') || '{}'),
  // 登录成功之后的 token 字符串
  token: uni.getStorageSync('token') || '',
  // 用户的基本信息
  userinfo: JSON.parse(uni.getStorageSync('userinfo') || '{}')
}),
```



在 `my-login` 组件中，把 vuex 中的 `updateToken` 方法映射到当前组件中使用：

```js
methods: {
  // 1. 使用 mapMutations 辅助方法，把 m_user 模块中的 updateToken 方法映射到当前组件中使用
  ...mapMutations('m_user', ['updateUserInfo', 'updateToken'])

  // 省略其它代码...

  // 调用登录接口，换取永久的 token
  async getToken(info) {
    // 调用微信登录接口
    const [err, res] = await uni.login().catch(err => err)
    // 判断是否 uni.login() 调用失败
    if (err || res.errMsg !== 'login:ok') return uni.$showError('登录失败！')

    // 准备参数对象
    const query = {
      code: res.code,
      encryptedData: info.encryptedData,
      iv: info.iv,
      rawData: info.rawData,
      signature: info.signature
    }

    // 换取 token
    const { data: loginResult } = await uni.$http.post('/api/public/v1/users/wxlogin', query)
    if (loginResult.meta.status !== 200) return uni.$showMsg('登录失败！')

    // 2. 更新 vuex 中的 token
    this.updateToken(loginResult.message.token)
  }
}
```



### 9. 实现用户头像昵称区域的基本布局

在 `my-userinfo` 组件中，定义如下的 UI 结构：

```xml
<template>
  <view class="my-userinfo-container">

    <!-- 头像昵称区域 -->
    <view class="top-box">
      <image src="" class="avatar"></image>
      <view class="nickname">xxx</view>
    </view>

  </view>
</template>
```



美化当前组件的样式：

```scss
.my-userinfo-container {
  height: 100%;
  // 为整个组件的结构添加浅灰色的背景
  background-color: #f4f4f4;

  .top-box {
    height: 400rpx;
    background-color: #c00000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;

    .avatar {
      display: block;
      width: 90px;
      height: 90px;
      border-radius: 45px;
      border: 2px solid white;
      box-shadow: 0 1px 5px black;
    }

    .nickname {
      color: white;
      font-weight: bold;
      font-size: 16px;
      margin-top: 10px;
    }
  }
}
```



在 `my.vue` 页面中，为最外层包裹性质的 `view` 容器，添加 `class="my-container"` 的类名，并美化样式如下：

```scss
page,
.my-container {
  height: 100%;
}
```



### 10. 渲染用户的头像和昵称

在 `my-userinfo` 组件中，通过 `mapState` 辅助函数，将需要的成员映射到当前组件中使用：

```js
// 按需导入 mapState 辅助函数
import { mapState } from 'vuex'

export default {
  computed: {
    // 将 m_user 模块中的 userinfo 映射到当前页面中使用
    ...mapState('m_user', ['userinfo']),
  },
  data() {
    return {}
  },
}
```



将用户的头像和昵称渲染到页面中：

```xml
<!-- 头像昵称区域 -->
<view class="top-box">
  <image :src="userinfo.avatarUrl" class="avatar"></image>
  <view class="nickname">{{userinfo.nickName}}</view>
</view>
```



### 11. 渲染第一个面板区域

在 `my-userinfo` 组件中，定义如下的 UI 结构：

```xml
<!-- 面板的列表区域 -->
<view class="panel-list">
  <!-- 第一个面板 -->
  <view class="panel">
    <!-- panel 的主体区域 -->
    <view class="panel-body">
      <!-- panel 的 item 项 -->
      <view class="panel-item">
        <text>8</text>
        <text>收藏的店铺</text>
      </view>
      <view class="panel-item">
        <text>14</text>
        <text>收藏的商品</text>
      </view>
      <view class="panel-item">
        <text>18</text>
        <text>关注的商品</text>
      </view>
      <view class="panel-item">
        <text>84</text>
        <text>足迹</text>
      </view>
    </view>
  </view>

  <!-- 第二个面板 -->

  <!-- 第三个面板 -->
</view>

```



美化第一个面板的样式：

```scss
.panel-list {
  padding: 0 10px;
  position: relative;
  top: -10px;

  .panel {
    background-color: white;
    border-radius: 3px;
    margin-bottom: 8px;

    .panel-body {
      display: flex;
      justify-content: space-around;

      .panel-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-around;
        font-size: 13px;
        padding: 10px 0;
      }
    }
  }
}
```



### 12. 渲染第二个面板区域

定义第二个面板区域的 UI 结构：

```xml
<!-- 第二个面板 -->
<view class="panel">
  <!-- 面板的标题 -->
  <view class="panel-title">我的订单</view>
  <!-- 面板的主体 -->
  <view class="panel-body">
    <!-- 面板主体中的 item 项 -->
    <view class="panel-item">
      <image src="/static/my-icons/icon1.png" class="icon"></image>
      <text>待付款</text>
    </view>
    <view class="panel-item">
      <image src="/static/my-icons/icon2.png" class="icon"></image>
      <text>待收货</text>
    </view>
    <view class="panel-item">
      <image src="/static/my-icons/icon3.png" class="icon"></image>
      <text>退款/退货</text>
    </view>
    <view class="panel-item">
      <image src="/static/my-icons/icon4.png" class="icon"></image>
      <text>全部订单</text>
    </view>
  </view>
</view>
```



对之前的 SCSS 样式进行改造，从而美化第二个面板的样式：

```scss
.panel-list {
  padding: 0 10px;
  position: relative;
  top: -10px;

  .panel {
    background-color: white;
    border-radius: 3px;
    margin-bottom: 8px;

    .panel-title {
      line-height: 45px;
      padding-left: 10px;
      font-size: 15px;
      border-bottom: 1px solid #f4f4f4;
    }

    .panel-body {
      display: flex;
      justify-content: space-around;

      .panel-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-around;
        font-size: 13px;
        padding: 10px 0;

        .icon {
          width: 35px;
          height: 35px;
        }
      }
    }
  }
}
```



### 13. 渲染第三个面板区域

定义第三个面板区域的 UI 结构：

```xml
<!-- 第三个面板 -->
<view class="panel">
  <view class="panel-list-item">
    <text>收货地址</text>
    <uni-icons type="arrowright" size="15"></uni-icons>
  </view>
  <view class="panel-list-item">
    <text>联系客服</text>
    <uni-icons type="arrowright" size="15"></uni-icons>
  </view>
  <view class="panel-list-item">
    <text>退出登录</text>
    <uni-icons type="arrowright" size="15"></uni-icons>
  </view>
</view>

```



美化第三个面板区域的样式：

```scss
.panel-list-item {
  height: 45px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 15px;
  padding: 0 10px;
}
```



### 14. 实现退出登录的功能

为第三个面板区域中的 `退出登录` 项绑定 `click` 点击事件处理函数：

```xml
<view class="panel-list-item" @click="logout">
  <text>退出登录</text>
  <uni-icons type="arrowright" size="15"></uni-icons>
</view>
```



在 `my-userinfo` 组件的 `methods` 节点中定义 `logout` 事件处理函数：

```js
// 退出登录
async logout() {
  // 询问用户是否退出登录
  const [err, succ] = await uni.showModal({
    title: '提示',
    content: '确认退出登录吗？'
  }).catch(err => err)

  if (succ && succ.confirm) {
     // 用户确认了退出登录的操作
     // 需要清空 vuex 中的 userinfo、token 和 address
     this.updateUserInfo({})
     this.updateToken('')
     this.updateAddress({})
  }
}
```



使用 `mapMutations` 辅助方法，将需要用到的 mutations 方法映射到当前组件中：

```js
// 按需导入辅助函数
import { mapState, mapMutations } from 'vuex'

export default {
  methods: {
    ...mapMutations('m_user', ['updateUserInfo', 'updateToken', 'updateAddress']),
  },
}
```



### 15. 三秒后自动跳转

> 需求描述：在购物车页面，当用户点击 “结算” 按钮时，如果用户没有登录，则 3 秒后自动跳转到登录页面



在 `my-settle` 组件的 `methods` 节点中，声明一个叫做 `showTips` 的方法，专门用来展示倒计时的提示消息：

```js
// 展示倒计时的提示消息
showTips(n) {
  // 调用 uni.showToast() 方法，展示提示消息
  uni.showToast({
    // 不展示任何图标
    icon: 'none',
    // 提示的消息
    title: '请登录后再结算！' + n + ' 秒后自动跳转到登录页',
    // 为页面添加透明遮罩，防止点击穿透
    mask: true,
    // 1.5 秒后自动消失
    duration: 1500
  })
}
```



在 `data` 节点中声明倒计时的秒数：

```js
data() {
  return {
    // 倒计时的秒数
    seconds: 3
  }
}

```



改造 `结算` 按钮的 `click` 事件处理函数，如果用户没有登录，则**预调用**一个叫做 `delayNavigate` 的方法，进行倒计时的导航跳转：

```js
// 点击了结算按钮
settlement() {
  // 1. 先判断是否勾选了要结算的商品
  if (!this.checkedCount) return uni.$showMsg('请选择要结算的商品！')

  // 2. 再判断用户是否选择了收货地址
  if (!this.addstr) return uni.$showMsg('请选择收货地址！')

  // 3. 最后判断用户是否登录了，如果没有登录，则调用 delayNavigate() 进行倒计时的导航跳转
  // if (!this.token) return uni.$showMsg('请先登录！')
  if (!this.token) return this.delayNavigate()
},
```



定义 `delayNavigate` 方法，初步实现**倒计时的提示功能**：

```js
// 延迟导航到 my 页面
delayNavigate() {
  // 1. 展示提示消息，此时 seconds 的值等于 3
  this.showTips(this.seconds)

  // 2. 创建定时器，每隔 1 秒执行一次
  setInterval(() => {
    // 2.1 先让秒数自减 1
    this.seconds--
    // 2.2 再根据最新的秒数，进行消息提示
    this.showTips(this.seconds)
  }, 1000)
},
```

> 上述代码的问题：定时器不会自动停止，此时秒数会出现等于 0 或小于 0 的情况！



在 `data` 节点中声明定时器的 Id 如下：

```js
data() {
  return {
    // 倒计时的秒数
    seconds: 3,
    // 定时器的 Id
    timer: null
  }
}
```



改造 `delayNavigate` 方法如下：

```js
// 延迟导航到 my 页面
delayNavigate() {
  this.showTips(this.seconds)

  // 1. 将定时器的 Id 存储到 timer 中
  this.timer = setInterval(() => {
    this.seconds--

    // 2. 判断秒数是否 <= 0
    if (this.seconds <= 0) {
      // 2.1 清除定时器
      clearInterval(this.timer)

      // 2.2 跳转到 my 页面
      uni.switchTab({
        url: '/pages/my/my'
      })

      // 2.3 终止后续代码的运行（当秒数为 0 时，不再展示 toast 提示消息）
      return
    }

    this.showTips(this.seconds)
  }, 1000)
},
```

> 上述代码的问题：seconds 秒数不会被重置，导致第 2 次，3 次，n 次 的倒计时跳转功能无法正常工作



进一步改造 `delayNavigate` 方法，在执行此方法时，立即将 `seconds` 秒数重置为 `3` 即可：

```js
// 延迟导航到 my 页面
delayNavigate() {
  // 把 data 中的秒数重置成 3 秒
  this.seconds = 3
  this.showTips(this.seconds)

  this.timer = setInterval(() => {
    this.seconds--

    if (this.seconds <= 0) {
      clearInterval(this.timer)
      uni.switchTab({
        url: '/pages/my/my'
      })
      return
    }

    this.showTips(this.seconds)
  }, 1000)
}
```



### 16. 登录成功之后再返回之前的页面

> 核心实现思路：在自动跳转到登录页面成功之后，把返回页面的信息存储到 vuex 中，从而方便登录成功之后，根据返回页面的信息重新跳转回去。
>
> 返回页面的信息对象，主要包含 { openType, from } 两个属性，其中 openType 表示以哪种方式导航回之前的页面；from 表示之前页面的 url 地址；



在 `store/user.js` 模块的 `state` 节点中，声明一个叫做 `redirectInfo` 的对象如下：

```js
// state 数据
state: () => ({
  // 收货地址
  address: JSON.parse(uni.getStorageSync('address') || '{}'),
  // 登录成功之后的 token 字符串
  token: uni.getStorageSync('token') || '',
  // 用户的基本信息
  userinfo: JSON.parse(uni.getStorageSync('userinfo') || '{}'),
  // 重定向的 object 对象 { openType, from }
  redirectInfo: null
}),
    
```



在 `store/user.js` 模块的 `mutations` 节点中，声明一个叫做 `updateRedirectInfo` 的方法：

```js
mutations: {
  // 更新重定向的信息对象
  updateRedirectInfo(state, info) {
    state.redirectInfo = info
  }
}
```



在 `my-settle` 组件中，通过 `mapMutations` 辅助方法，把 `m_user` 模块中的 `updateRedirectInfo` 方法映射到当前页面中使用：

```js
methods: {
  // 把 m_user 模块中的 updateRedirectInfo 方法映射到当前页面中使用
  ...mapMutations('m_user', ['updateRedirectInfo']),
}
```



改造 `my-settle` 组件 methods 节点中的 `delayNavigate` 方法，当成功跳转到 `my 页面` 之后，将重定向的信息对象存储到 vuex 中：

```js
// 延迟导航到 my 页面
delayNavigate() {
  // 把 data 中的秒数重置成 3 秒
  this.seconds = 3
  this.showTips(this.seconds)

  this.timer = setInterval(() => {
    this.seconds--

    if (this.seconds <= 0) {
      // 清除定时器
      clearInterval(this.timer)
      // 跳转到 my 页面
      uni.switchTab({
        url: '/pages/my/my',
        // 页面跳转成功之后的回调函数
        success: () => {
          // 调用 vuex 的 updateRedirectInfo 方法，把跳转信息存储到 Store 中
          this.updateRedirectInfo({
            // 跳转的方式
            openType: 'switchTab',
            // 从哪个页面跳转过去的
            from: '/pages/cart/cart'
          })
        }
      })

      return
    }

    this.showTips(this.seconds)
  }, 1000)
}
```



在 `my-login` 组件中，通过 `mapState` 和 `mapMutations` 辅助方法，将 vuex 中需要的数据和方法，映射到当前页面中使用：

```js
// 按需导入辅助函数
import { mapMutations, mapState } from 'vuex'

export default {
  computed: {
    // 调用 mapState 辅助方法，把 m_user 模块中的数据映射到当前用组件中使用
    ...mapState('m_user', ['redirectInfo']),
  },
  methods: {
    // 调用 mapMutations 辅助方法，把 m_user 模块中的方法映射到当前组件中使用
    ...mapMutations('m_user', ['updateUserInfo', 'updateToken', 'updateRedirectInfo']),
  },
}
```



改造 `my-login` 组件中的 `getToken` 方法，当登录成功之后，预调用 `this.navigateBack()` 方法返回登录之前的页面：

```js
// 调用登录接口，换取永久的 token
async getToken(info) {
  // 省略其它代码...

  // 判断 vuex 中的 redirectInfo 是否为 null
  // 如果不为 null，则登录成功之后，需要重新导航到对应的页面
  this.navigateBack()
}
```



在 `my-login` 组件中，声明 `navigateBack` 方法如下：

```js
// 返回登录之前的页面
navigateBack() {
  // redirectInfo 不为 null，并且导航方式为 switchTab
  if (this.redirectInfo && this.redirectInfo.openType === 'switchTab') {
    // 调用小程序提供的 uni.switchTab() API 进行页面的导航
    uni.switchTab({
      // 要导航到的页面地址
      url: this.redirectInfo.from,
      // 导航成功之后，把 vuex 中的 redirectInfo 对象重置为 null
      complete: () => {
        this.updateRedirectInfo(null)
      }
    })
  }
}

```



## 16. 微信支付

### 1. 在请求头中添加 Token 身份认证的字段

1. 原因说明：**只有在登录之后才允许调用支付相关的接口**，所以必须为有权限的接口添加身份认证的请求头字段
2. 打开项目根目录下的 `main.js`，改造 `$http.beforeRequest` 请求拦截器中的代码如下：

```js
// 请求开始之前做一些事情
$http.beforeRequest = function(options) {
  uni.showLoading({
    title: '数据加载中...',
  })

  // 判断请求的是否为有权限的 API 接口
  if (options.url.indexOf('/my/') !== -1) {
    // 为请求头添加身份认证字段
    options.header = {
      // 字段的值可以直接从 vuex 中进行获取
      Authorization: store.state.m_user.token,
    }
  }
}
```



### 2. 微信支付的流程

1. **创建订单**
   - 请求创建订单的 API 接口：把（订单金额、收货地址、订单中包含的商品信息）发送到服务器
   - 服务器响应的结果：*订单编号*
2. **订单预支付**
   - 请求订单预支付的 API 接口：把（订单编号）发送到服务器
   - 服务器响应的结果：*订单预支付的参数对象*，里面包含了订单支付相关的必要参数
3. **发起微信支付**
   - 调用 `uni.requestPayment()` 这个 API，发起微信支付；把步骤 2 得到的 “订单预支付对象” 作为参数传递给 `uni.requestPayment()` 方法
   - 监听 `uni.requestPayment()` 这个 API 的 `success`，`fail`，`complete` 回调函数



### 3. 创建订单

改造 `my-settle` 组件中的 `settlement` 方法，当前三个判断条件通过之后，调用实现微信支付的方法：

```js
// 点击了结算按钮
settlement() {
  // 1. 先判断是否勾选了要结算的商品
  if (!this.checkedCount) return uni.$showMsg('请选择要结算的商品！')

  // 2. 再判断用户是否选择了收货地址
  if (!this.addstr) return uni.$showMsg('请选择收货地址！')

  // 3. 最后判断用户是否登录了
  // if (!this.token) return uni.$showMsg('请先登录！')
  if (!this.token) return this.delayNavigate()

  // 4. 实现微信支付功能
  this.payOrder()
},
```



在 `my-settle` 组件中定义 `payOrder` 方法如下，先实现创建订单的功能：

```js
// 微信支付
async payOrder() {
  // 1. 创建订单
  // 1.1 组织订单的信息对象
  const orderInfo = {
    // 开发期间，注释掉真实的订单价格，
    // order_price: this.checkedGoodsAmount,
    // 写死订单总价为 1 分钱
    order_price: 0.01,
    consignee_addr: this.addstr,
    goods: this.cart.filter(x => x.goods_state).map(x => ({ goods_id: x.goods_id, goods_number: x.goods_count, goods_price: x.goods_price }))
  }
  // 1.2 发起请求创建订单
  const { data: res } = await uni.$http.post('/api/public/v1/my/orders/create', orderInfo)
  if (res.meta.status !== 200) return uni.$showMsg('创建订单失败！')
  // 1.3 得到服务器响应的“订单编号”
  const orderNumber = res.message.order_number

   // 2. 订单预支付

   // 3. 发起微信支付
 }
```



### 4. 订单预支付

改造 `my-settle` 组件的 `payOrder` 方法，实现订单预支付功能：

```js
// 微信支付
async payOrder() {
  // 1. 创建订单
  // 1.1 组织订单的信息对象
  const orderInfo = {
    // 开发期间，注释掉真实的订单价格，
    // order_price: this.checkedGoodsAmount,
    // 写死订单总价为 1 分钱
    order_price: 0.01,
    consignee_addr: this.addstr,
    goods: this.cart.filter(x => x.goods_state).map(x => ({ goods_id: x.goods_id, goods_number: x.goods_count, goods_price: x.goods_price }))
  }
  // 1.2 发起请求创建订单
  const { data: res } = await uni.$http.post('/api/public/v1/my/orders/create', orderInfo)
  if (res.meta.status !== 200) return uni.$showMsg('创建订单失败！')
  // 1.3 得到服务器响应的“订单编号”
  const orderNumber = res.message.order_number

  // 2. 订单预支付
  // 2.1 发起请求获取订单的支付信息
  const { data: res2 } = await uni.$http.post('/api/public/v1/my/orders/req_unifiedorder', { order_number: orderNumber })
  // 2.2 预付订单生成失败
  if (res2.meta.status !== 200) return uni.$showError('预付订单生成失败！')
  // 2.3 得到订单支付相关的必要参数
  const payInfo = res2.message.pay

   // 3. 发起微信支付
 }
```



### 5. 发起微信支付

改造 `my-settle` 组件的 `payOrder` 方法，实现微信支付的功能：

```js
// 微信支付
async payOrder() {
  // 1. 创建订单
  // 1.1 组织订单的信息对象
  const orderInfo = {
    // 开发期间，注释掉真实的订单价格，
    // order_price: this.checkedGoodsAmount,
    // 写死订单总价为 1 分钱
    order_price: 0.01,
    consignee_addr: this.addstr,
    goods: this.cart.filter(x => x.goods_state).map(x => ({ goods_id: x.goods_id, goods_number: x.goods_count, goods_price: x.goods_price }))
  }
  // 1.2 发起请求创建订单
  const { data: res } = await uni.$http.post('/api/public/v1/my/orders/create', orderInfo)
  if (res.meta.status !== 200) return uni.$showMsg('创建订单失败！')
  // 1.3 得到服务器响应的“订单编号”
  const orderNumber = res.message.order_number

   // 2. 订单预支付
   // 2.1 发起请求获取订单的支付信息
   const { data: res2 } = await uni.$http.post('/api/public/v1/my/orders/req_unifiedorder', { order_number: orderNumber })
   // 2.2 预付订单生成失败
   if (res2.meta.status !== 200) return uni.$showError('预付订单生成失败！')
   // 2.3 得到订单支付相关的必要参数
   const payInfo = res2.message.pay

   // 3. 发起微信支付
   // 3.1 调用 uni.requestPayment() 发起微信支付
   const [err, succ] = await uni.requestPayment(payInfo)
   // 3.2 未完成支付
   if (err) return uni.$showMsg('订单未支付！')
   // 3.3 完成了支付，进一步查询支付的结果
   const { data: res3 } = await uni.$http.post('/api/public/v1/my/orders/chkOrder', { order_number: orderNumber })
   // 3.4 检测到订单未支付
   if (res3.meta.status !== 200) return uni.$showMsg('订单未支付！')
   // 3.5 检测到订单支付完成
   uni.showToast({
     title: '支付完成！',
     icon: 'success'
   })
 }
```



## 16. 发布

1. 小程序只有发布之后，才能被用户搜索并使用
2. 开发期间的小程序为了便于调试，含有 sourcemap 相关的文件，并且代码没有被压缩，因此体积较大，不适合直接当作线上版本进行发布
3. 通过执行 “小程序发布”，能够优化小程序的体积，提高小程序的运行性能



### 1. 发布小程序

点击菜单栏 - 发行 - 选择小程序微信

![image-20220523224759552](images/mini_program/image-20220523224759552.png)



填写 appId 

![image-20220523224901225](images/mini_program/image-20220523224901225.png)



发布编译完成之后，会自动打开一个新的**微信开发者工具界面**，此时，点击工具栏上的上传按钮：

![image-20220523224959450](images/mini_program/image-20220523224959450.png)



填写**版本号**和**项目备注**之后，点击**上传**按钮：

![img](data:image/png;base64,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)



上传完成之后，会出现如下的提示消息，直接点击**确定**按钮即可：

![img](images/mini_program/11-6.d5c408c3.png)



通过微信开发者工具上传的代码，默认处于**版本管理**的**开发版本**列表中，如图所示：

![img](images/mini_program/11-7.ec9045bc.png)





将 `开发版本提交审核` -> 再将 `审核通过的版本发布上线`，即可实现小程序的发布和上线：

![img](images/mini_program/11-8.a251f8b8.png)



### 2. 发布为 Android App 的流程

首先需要登录 HBuilderX



打开项目根目录中的 `manifest.json` 配置文件，在**基础配置**面板中，获取**uni-app 应用标识**，并填写**应用名称**：

![img](images/mini_program/11-11.dc32f303.png)





切换到 **App 图标配置**面板，点击**浏览**按钮，选择合适的图片之后，再点击**自动生成所有图标并替换**即可：

![img](images/mini_program/11-12.e3157064.png)



点击菜单栏上的 **发行** -> **原生 App-云打包**：

![img](images/mini_program/11-13.d176ba65.png)



**勾选打包配置**如下：

![img](images/mini_program/11-14.ddd7bcc3.png)



在**控制台**中**查看打包的进度信息**：

![img](images/mini_program/11-15.c8d3b328.png)



点击链接**下载 apk 的安装包**，并**安装到 Android 手机中**查看打包的效果。

> 注意：由于开发期间没有进行多端适配，所以有些功能在 App 中无法正常运行，例如：选择收货地址、微信登录、微信支付



